
RTOS_Based_Calculator.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000020ac  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000082  00800060  000020ac  00002140  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000069e  008000e2  008000e2  000021c2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000021c2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000021f4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000460  00000000  00000000  00002230  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005626  00000000  00000000  00002690  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000015f4  00000000  00000000  00007cb6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002fcb  00000000  00000000  000092aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000c0c  00000000  00000000  0000c278  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001686  00000000  00000000  0000ce84  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004c97  00000000  00000000  0000e50a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000458  00000000  00000000  000131a1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 eb 08 	jmp	0x11d6	; 0x11d6 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec ea       	ldi	r30, 0xAC	; 172
      68:	f0 e2       	ldi	r31, 0x20	; 32
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 3e       	cpi	r26, 0xE2	; 226
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	a2 ee       	ldi	r26, 0xE2	; 226
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a0 38       	cpi	r26, 0x80	; 128
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 9a 03 	call	0x734	; 0x734 <main>
      8a:	0c 94 54 10 	jmp	0x20a8	; 0x20a8 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Tasks_Init>:
	LCD_GoTo(0,0);
	LCD_WriteString("Made By:");
	LCD_GoTo(1,0);
	LCD_WriteString("Ali Mamdoh");
	_delay_ms(2000);
	LCD_Clear();
      92:	0e 94 51 06 	call	0xca2	; 0xca2 <PORT_Init>
      96:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Init>
      9a:	0e 94 9d 03 	call	0x73a	; 0x73a <KeyPad_Init>
      9e:	60 e0       	ldi	r22, 0x00	; 0
      a0:	80 e0       	ldi	r24, 0x00	; 0
      a2:	0e 94 72 05 	call	0xae4	; 0xae4 <LCD_GoTo>
      a6:	84 e8       	ldi	r24, 0x84	; 132
      a8:	90 e0       	ldi	r25, 0x00	; 0
      aa:	0e 94 c5 04 	call	0x98a	; 0x98a <LCD_WriteString>
      ae:	2f ef       	ldi	r18, 0xFF	; 255
      b0:	87 ea       	ldi	r24, 0xA7	; 167
      b2:	91 e6       	ldi	r25, 0x61	; 97
      b4:	21 50       	subi	r18, 0x01	; 1
      b6:	80 40       	sbci	r24, 0x00	; 0
      b8:	90 40       	sbci	r25, 0x00	; 0
      ba:	e1 f7       	brne	.-8      	; 0xb4 <Tasks_Init+0x22>
      bc:	00 c0       	rjmp	.+0      	; 0xbe <Tasks_Init+0x2c>
      be:	00 00       	nop
      c0:	0e 94 8d 05 	call	0xb1a	; 0xb1a <LCD_Clear>
      c4:	60 e0       	ldi	r22, 0x00	; 0
      c6:	80 e0       	ldi	r24, 0x00	; 0
      c8:	0e 94 72 05 	call	0xae4	; 0xae4 <LCD_GoTo>
      cc:	8f e8       	ldi	r24, 0x8F	; 143
      ce:	90 e0       	ldi	r25, 0x00	; 0
      d0:	0e 94 c5 04 	call	0x98a	; 0x98a <LCD_WriteString>
      d4:	60 e0       	ldi	r22, 0x00	; 0
      d6:	81 e0       	ldi	r24, 0x01	; 1
      d8:	0e 94 72 05 	call	0xae4	; 0xae4 <LCD_GoTo>
      dc:	88 e9       	ldi	r24, 0x98	; 152
      de:	90 e0       	ldi	r25, 0x00	; 0
      e0:	0e 94 c5 04 	call	0x98a	; 0x98a <LCD_WriteString>
      e4:	2f ef       	ldi	r18, 0xFF	; 255
      e6:	87 ea       	ldi	r24, 0xA7	; 167
      e8:	91 e6       	ldi	r25, 0x61	; 97
      ea:	21 50       	subi	r18, 0x01	; 1
      ec:	80 40       	sbci	r24, 0x00	; 0
      ee:	90 40       	sbci	r25, 0x00	; 0
      f0:	e1 f7       	brne	.-8      	; 0xea <Tasks_Init+0x58>
      f2:	00 c0       	rjmp	.+0      	; 0xf4 <Tasks_Init+0x62>
      f4:	00 00       	nop
      f6:	0e 94 8d 05 	call	0xb1a	; 0xb1a <LCD_Clear>
      fa:	40 e0       	ldi	r20, 0x00	; 0
      fc:	61 e0       	ldi	r22, 0x01	; 1
      fe:	83 e2       	ldi	r24, 0x23	; 35
     100:	0e 94 ef 09 	call	0x13de	; 0x13de <xQueueGenericCreate>
     104:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <Queue1_Handle+0x1>
     108:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <Queue1_Handle>
     10c:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <Init_Task_Handle>
     110:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <Init_Task_Handle+0x1>
     114:	0e 94 ef 0e 	call	0x1dde	; 0x1dde <vTaskSuspend>
     118:	bc cf       	rjmp	.-136    	; 0x92 <Tasks_Init>

0000011a <Task2_LCDDisplay>:
     11a:	cf 93       	push	r28
     11c:	df 93       	push	r29
     11e:	1f 92       	push	r1
     120:	cd b7       	in	r28, 0x3d	; 61
     122:	de b7       	in	r29, 0x3e	; 62
     124:	19 82       	std	Y+1, r1	; 0x01
     126:	4f ef       	ldi	r20, 0xFF	; 255
     128:	5f ef       	ldi	r21, 0xFF	; 255
     12a:	be 01       	movw	r22, r28
     12c:	6f 5f       	subi	r22, 0xFF	; 255
     12e:	7f 4f       	sbci	r23, 0xFF	; 255
     130:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <Queue1_Handle>
     134:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <Queue1_Handle+0x1>
     138:	0e 94 bd 0a 	call	0x157a	; 0x157a <xQueueReceive>
     13c:	89 81       	ldd	r24, Y+1	; 0x01
     13e:	88 37       	cpi	r24, 0x78	; 120
     140:	41 f0       	breq	.+16     	; 0x152 <Task2_LCDDisplay+0x38>
     142:	91 ed       	ldi	r25, 0xD1	; 209
     144:	98 0f       	add	r25, r24
     146:	9b 30       	cpi	r25, 0x0B	; 11
     148:	20 f0       	brcs	.+8      	; 0x152 <Task2_LCDDisplay+0x38>
     14a:	8b 32       	cpi	r24, 0x2B	; 43
     14c:	11 f0       	breq	.+4      	; 0x152 <Task2_LCDDisplay+0x38>
     14e:	8d 32       	cpi	r24, 0x2D	; 45
     150:	19 f4       	brne	.+6      	; 0x158 <Task2_LCDDisplay+0x3e>
     152:	0e 94 67 04 	call	0x8ce	; 0x8ce <LCD_WriteChar>
     156:	37 c0       	rjmp	.+110    	; 0x1c6 <Task2_LCDDisplay+0xac>
     158:	8d 33       	cpi	r24, 0x3D	; 61
     15a:	89 f5       	brne	.+98     	; 0x1be <Task2_LCDDisplay+0xa4>
     15c:	80 91 e6 00 	lds	r24, 0x00E6	; 0x8000e6 <Division_By_Zero_Flag>
     160:	81 11       	cpse	r24, r1
     162:	12 c0       	rjmp	.+36     	; 0x188 <Task2_LCDDisplay+0x6e>
     164:	8d e3       	ldi	r24, 0x3D	; 61
     166:	0e 94 67 04 	call	0x8ce	; 0x8ce <LCD_WriteChar>
     16a:	60 e0       	ldi	r22, 0x00	; 0
     16c:	81 e0       	ldi	r24, 0x01	; 1
     16e:	0e 94 72 05 	call	0xae4	; 0xae4 <LCD_GoTo>
     172:	60 91 e7 00 	lds	r22, 0x00E7	; 0x8000e7 <result>
     176:	70 91 e8 00 	lds	r23, 0x00E8	; 0x8000e8 <result+0x1>
     17a:	80 91 e9 00 	lds	r24, 0x00E9	; 0x8000e9 <result+0x2>
     17e:	90 91 ea 00 	lds	r25, 0x00EA	; 0x8000ea <result+0x3>
     182:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <LCD_WriteInteger>
     186:	1f c0       	rjmp	.+62     	; 0x1c6 <Task2_LCDDisplay+0xac>
     188:	81 30       	cpi	r24, 0x01	; 1
     18a:	e9 f4       	brne	.+58     	; 0x1c6 <Task2_LCDDisplay+0xac>
     18c:	8d e3       	ldi	r24, 0x3D	; 61
     18e:	0e 94 67 04 	call	0x8ce	; 0x8ce <LCD_WriteChar>
     192:	60 e0       	ldi	r22, 0x00	; 0
     194:	81 e0       	ldi	r24, 0x01	; 1
     196:	0e 94 72 05 	call	0xae4	; 0xae4 <LCD_GoTo>
     19a:	83 ea       	ldi	r24, 0xA3	; 163
     19c:	90 e0       	ldi	r25, 0x00	; 0
     19e:	0e 94 c5 04 	call	0x98a	; 0x98a <LCD_WriteString>
     1a2:	2f ef       	ldi	r18, 0xFF	; 255
     1a4:	87 ea       	ldi	r24, 0xA7	; 167
     1a6:	91 e6       	ldi	r25, 0x61	; 97
     1a8:	21 50       	subi	r18, 0x01	; 1
     1aa:	80 40       	sbci	r24, 0x00	; 0
     1ac:	90 40       	sbci	r25, 0x00	; 0
     1ae:	e1 f7       	brne	.-8      	; 0x1a8 <Task2_LCDDisplay+0x8e>
     1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <Task2_LCDDisplay+0x98>
     1b2:	00 00       	nop
     1b4:	0e 94 8d 05 	call	0xb1a	; 0xb1a <LCD_Clear>
     1b8:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <Division_By_Zero_Flag>
     1bc:	04 c0       	rjmp	.+8      	; 0x1c6 <Task2_LCDDisplay+0xac>
     1be:	83 36       	cpi	r24, 0x63	; 99
     1c0:	11 f4       	brne	.+4      	; 0x1c6 <Task2_LCDDisplay+0xac>
     1c2:	0e 94 8d 05 	call	0xb1a	; 0xb1a <LCD_Clear>
     1c6:	82 e3       	ldi	r24, 0x32	; 50
     1c8:	90 e0       	ldi	r25, 0x00	; 0
     1ca:	0e 94 75 0e 	call	0x1cea	; 0x1cea <vTaskDelay>
     1ce:	ab cf       	rjmp	.-170    	; 0x126 <Task2_LCDDisplay+0xc>

000001d0 <Clear_Button>:
}

void Clear_Button (void)
{
	 Division_By_Zero_Flag=0;
     1d0:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <Division_By_Zero_Flag>
	 op_cntr=0;
     1d4:	10 92 e4 00 	sts	0x00E4, r1	; 0x8000e4 <op_cntr>
	 num_cntr=0;
     1d8:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <num_cntr>
	 result=0;
     1dc:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <result>
     1e0:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <result+0x1>
     1e4:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <result+0x2>
     1e8:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <result+0x3>
     1ec:	ec ee       	ldi	r30, 0xEC	; 236
     1ee:	f0 e0       	ldi	r31, 0x00	; 0
     1f0:	86 ef       	ldi	r24, 0xF6	; 246
     1f2:	90 e0       	ldi	r25, 0x00	; 0
	 for (i=0; i<Number_Of_Operations ; i++)
	 {
		 Operations[i]=0;
     1f4:	11 92       	st	Z+, r1
{
	 Division_By_Zero_Flag=0;
	 op_cntr=0;
	 num_cntr=0;
	 result=0;
	 for (i=0; i<Number_Of_Operations ; i++)
     1f6:	e8 17       	cp	r30, r24
     1f8:	f9 07       	cpc	r31, r25
     1fa:	e1 f7       	brne	.-8      	; 0x1f4 <Clear_Button+0x24>
     1fc:	8a e0       	ldi	r24, 0x0A	; 10
     1fe:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <i>
     202:	e6 ef       	ldi	r30, 0xF6	; 246
     204:	f0 e0       	ldi	r31, 0x00	; 0
     206:	82 e3       	ldi	r24, 0x32	; 50
     208:	91 e0       	ldi	r25, 0x01	; 1
	 {
		 Operations[i]=0;
	 }
	 for (j=0 ; j<Number_Of_Operands ; j++)
	 {
		 Numbers[j]=0;
     20a:	11 92       	st	Z+, r1
     20c:	11 92       	st	Z+, r1
     20e:	11 92       	st	Z+, r1
     210:	11 92       	st	Z+, r1
	 result=0;
	 for (i=0; i<Number_Of_Operations ; i++)
	 {
		 Operations[i]=0;
	 }
	 for (j=0 ; j<Number_Of_Operands ; j++)
     212:	e8 17       	cp	r30, r24
     214:	f9 07       	cpc	r31, r25
     216:	c9 f7       	brne	.-14     	; 0x20a <Clear_Button+0x3a>
     218:	8f e0       	ldi	r24, 0x0F	; 15
     21a:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__data_end>
     21e:	08 95       	ret

00000220 <Operations_Buttons>:
	 }
}

void Operations_Buttons (void)
{
	Operations[op_cntr] = Key_Value;
     220:	80 91 e4 00 	lds	r24, 0x00E4	; 0x8000e4 <op_cntr>
     224:	e8 2f       	mov	r30, r24
     226:	f0 e0       	ldi	r31, 0x00	; 0
     228:	e4 51       	subi	r30, 0x14	; 20
     22a:	ff 4f       	sbci	r31, 0xFF	; 255
     22c:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <Key_Value>
     230:	90 83       	st	Z, r25
	num_cntr++;
     232:	90 91 e5 00 	lds	r25, 0x00E5	; 0x8000e5 <num_cntr>
     236:	9f 5f       	subi	r25, 0xFF	; 255
     238:	90 93 e5 00 	sts	0x00E5, r25	; 0x8000e5 <num_cntr>
	op_cntr++;
     23c:	8f 5f       	subi	r24, 0xFF	; 255
     23e:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <op_cntr>
     242:	08 95       	ret

00000244 <Numbers_Buttons>:
}

void Numbers_Buttons (void)
{
	Numbers[num_cntr] *=10;
     244:	e0 91 e5 00 	lds	r30, 0x00E5	; 0x8000e5 <num_cntr>
     248:	f0 e0       	ldi	r31, 0x00	; 0
	Numbers[num_cntr] += (Key_Value -'0');
     24a:	ee 0f       	add	r30, r30
     24c:	ff 1f       	adc	r31, r31
     24e:	ee 0f       	add	r30, r30
     250:	ff 1f       	adc	r31, r31
     252:	ea 50       	subi	r30, 0x0A	; 10
     254:	ff 4f       	sbci	r31, 0xFF	; 255
     256:	80 81       	ld	r24, Z
     258:	91 81       	ldd	r25, Z+1	; 0x01
     25a:	a2 81       	ldd	r26, Z+2	; 0x02
     25c:	b3 81       	ldd	r27, Z+3	; 0x03
     25e:	88 0f       	add	r24, r24
     260:	99 1f       	adc	r25, r25
     262:	aa 1f       	adc	r26, r26
     264:	bb 1f       	adc	r27, r27
     266:	ac 01       	movw	r20, r24
     268:	bd 01       	movw	r22, r26
     26a:	44 0f       	add	r20, r20
     26c:	55 1f       	adc	r21, r21
     26e:	66 1f       	adc	r22, r22
     270:	77 1f       	adc	r23, r23
     272:	44 0f       	add	r20, r20
     274:	55 1f       	adc	r21, r21
     276:	66 1f       	adc	r22, r22
     278:	77 1f       	adc	r23, r23
     27a:	84 0f       	add	r24, r20
     27c:	95 1f       	adc	r25, r21
     27e:	a6 1f       	adc	r26, r22
     280:	b7 1f       	adc	r27, r23
     282:	40 91 eb 00 	lds	r20, 0x00EB	; 0x8000eb <Key_Value>
     286:	50 e0       	ldi	r21, 0x00	; 0
     288:	40 53       	subi	r20, 0x30	; 48
     28a:	51 09       	sbc	r21, r1
     28c:	05 2e       	mov	r0, r21
     28e:	00 0c       	add	r0, r0
     290:	66 0b       	sbc	r22, r22
     292:	77 0b       	sbc	r23, r23
     294:	84 0f       	add	r24, r20
     296:	95 1f       	adc	r25, r21
     298:	a6 1f       	adc	r26, r22
     29a:	b7 1f       	adc	r27, r23
     29c:	80 83       	st	Z, r24
     29e:	91 83       	std	Z+1, r25	; 0x01
     2a0:	a2 83       	std	Z+2, r26	; 0x02
     2a2:	b3 83       	std	Z+3, r27	; 0x03
     2a4:	08 95       	ret

000002a6 <Division_By_Zero>:
	}
}

void Division_By_Zero (void)
{
	op_cntr=0;
     2a6:	10 92 e4 00 	sts	0x00E4, r1	; 0x8000e4 <op_cntr>
	num_cntr=0;
     2aa:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <num_cntr>
	result=0;
     2ae:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <result>
     2b2:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <result+0x1>
     2b6:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <result+0x2>
     2ba:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <result+0x3>
     2be:	ec ee       	ldi	r30, 0xEC	; 236
     2c0:	f0 e0       	ldi	r31, 0x00	; 0
     2c2:	86 ef       	ldi	r24, 0xF6	; 246
     2c4:	90 e0       	ldi	r25, 0x00	; 0
	for (i=0; i<Number_Of_Operations ; i++)
	{
		Operations[i]=0;
     2c6:	11 92       	st	Z+, r1
void Division_By_Zero (void)
{
	op_cntr=0;
	num_cntr=0;
	result=0;
	for (i=0; i<Number_Of_Operations ; i++)
     2c8:	e8 17       	cp	r30, r24
     2ca:	f9 07       	cpc	r31, r25
     2cc:	e1 f7       	brne	.-8      	; 0x2c6 <Division_By_Zero+0x20>
     2ce:	8a e0       	ldi	r24, 0x0A	; 10
     2d0:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <i>
     2d4:	e6 ef       	ldi	r30, 0xF6	; 246
     2d6:	f0 e0       	ldi	r31, 0x00	; 0
     2d8:	82 e3       	ldi	r24, 0x32	; 50
     2da:	91 e0       	ldi	r25, 0x01	; 1
	{
		Operations[i]=0;
	}
	for (j=0 ; j<Number_Of_Operands ; j++)
	{
		Numbers[j]=0;
     2dc:	11 92       	st	Z+, r1
     2de:	11 92       	st	Z+, r1
     2e0:	11 92       	st	Z+, r1
     2e2:	11 92       	st	Z+, r1
	result=0;
	for (i=0; i<Number_Of_Operations ; i++)
	{
		Operations[i]=0;
	}
	for (j=0 ; j<Number_Of_Operands ; j++)
     2e4:	e8 17       	cp	r30, r24
     2e6:	f9 07       	cpc	r31, r25
     2e8:	c9 f7       	brne	.-14     	; 0x2dc <Division_By_Zero+0x36>
     2ea:	8f e0       	ldi	r24, 0x0F	; 15
     2ec:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__data_end>
     2f0:	08 95       	ret

000002f2 <Multiplication>:
	}
	result = Numbers[0];	
}

void Multiplication (void)
{
     2f2:	0f 93       	push	r16
     2f4:	1f 93       	push	r17
     2f6:	cf 93       	push	r28
	Numbers[i] *=  Numbers[i+1] ;
     2f8:	c0 91 e3 00 	lds	r28, 0x00E3	; 0x8000e3 <i>
     2fc:	8c 2f       	mov	r24, r28
     2fe:	90 e0       	ldi	r25, 0x00	; 0
     300:	8c 01       	movw	r16, r24
     302:	00 0f       	add	r16, r16
     304:	11 1f       	adc	r17, r17
     306:	00 0f       	add	r16, r16
     308:	11 1f       	adc	r17, r17
     30a:	0a 50       	subi	r16, 0x0A	; 10
     30c:	1f 4f       	sbci	r17, 0xFF	; 255
     30e:	88 0f       	add	r24, r24
     310:	99 1f       	adc	r25, r25
     312:	88 0f       	add	r24, r24
     314:	99 1f       	adc	r25, r25
     316:	fc 01       	movw	r30, r24
     318:	e6 50       	subi	r30, 0x06	; 6
     31a:	ff 4f       	sbci	r31, 0xFF	; 255
     31c:	20 81       	ld	r18, Z
     31e:	31 81       	ldd	r19, Z+1	; 0x01
     320:	42 81       	ldd	r20, Z+2	; 0x02
     322:	53 81       	ldd	r21, Z+3	; 0x03
     324:	f8 01       	movw	r30, r16
     326:	60 81       	ld	r22, Z
     328:	71 81       	ldd	r23, Z+1	; 0x01
     32a:	82 81       	ldd	r24, Z+2	; 0x02
     32c:	93 81       	ldd	r25, Z+3	; 0x03
     32e:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <__mulsi3>
     332:	60 83       	st	Z, r22
     334:	71 83       	std	Z+1, r23	; 0x01
     336:	82 83       	std	Z+2, r24	; 0x02
     338:	93 83       	std	Z+3, r25	; 0x03
	for (j=i; j < op_cntr ; j++)
     33a:	c0 93 e2 00 	sts	0x00E2, r28	; 0x8000e2 <__data_end>
     33e:	50 91 e4 00 	lds	r21, 0x00E4	; 0x8000e4 <op_cntr>
     342:	c5 17       	cp	r28, r21
     344:	40 f5       	brcc	.+80     	; 0x396 <Multiplication+0xa4>
	{
		Operations[j] = Operations[j+1];
     346:	8c 2f       	mov	r24, r28
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	9c 01       	movw	r18, r24
     34c:	2f 5f       	subi	r18, 0xFF	; 255
     34e:	3f 4f       	sbci	r19, 0xFF	; 255
     350:	f9 01       	movw	r30, r18
     352:	e4 51       	subi	r30, 0x14	; 20
     354:	ff 4f       	sbci	r31, 0xFF	; 255
     356:	40 81       	ld	r20, Z
     358:	fc 01       	movw	r30, r24
     35a:	e4 51       	subi	r30, 0x14	; 20
     35c:	ff 4f       	sbci	r31, 0xFF	; 255
     35e:	40 83       	st	Z, r20
		Numbers[j+1] = Numbers [j+2];
     360:	88 0f       	add	r24, r24
     362:	99 1f       	adc	r25, r25
     364:	88 0f       	add	r24, r24
     366:	99 1f       	adc	r25, r25
     368:	fc 01       	movw	r30, r24
     36a:	e2 50       	subi	r30, 0x02	; 2
     36c:	ff 4f       	sbci	r31, 0xFF	; 255
     36e:	80 81       	ld	r24, Z
     370:	91 81       	ldd	r25, Z+1	; 0x01
     372:	a2 81       	ldd	r26, Z+2	; 0x02
     374:	b3 81       	ldd	r27, Z+3	; 0x03
     376:	22 0f       	add	r18, r18
     378:	33 1f       	adc	r19, r19
     37a:	22 0f       	add	r18, r18
     37c:	33 1f       	adc	r19, r19
     37e:	f9 01       	movw	r30, r18
     380:	ea 50       	subi	r30, 0x0A	; 10
     382:	ff 4f       	sbci	r31, 0xFF	; 255
     384:	80 83       	st	Z, r24
     386:	91 83       	std	Z+1, r25	; 0x01
     388:	a2 83       	std	Z+2, r26	; 0x02
     38a:	b3 83       	std	Z+3, r27	; 0x03
     38c:	cf 5f       	subi	r28, 0xFF	; 255
}

void Multiplication (void)
{
	Numbers[i] *=  Numbers[i+1] ;
	for (j=i; j < op_cntr ; j++)
     38e:	c5 13       	cpse	r28, r21
     390:	da cf       	rjmp	.-76     	; 0x346 <Multiplication+0x54>
     392:	50 93 e2 00 	sts	0x00E2, r21	; 0x8000e2 <__data_end>
	{
		Operations[j] = Operations[j+1];
		Numbers[j+1] = Numbers [j+2];
	}
}
     396:	cf 91       	pop	r28
     398:	1f 91       	pop	r17
     39a:	0f 91       	pop	r16
     39c:	08 95       	ret

0000039e <Division>:

void Division (void)
{
     39e:	0f 93       	push	r16
     3a0:	1f 93       	push	r17
     3a2:	cf 93       	push	r28
	if (Numbers[i+1] == 0)
     3a4:	c0 91 e3 00 	lds	r28, 0x00E3	; 0x8000e3 <i>
     3a8:	8c 2f       	mov	r24, r28
     3aa:	90 e0       	ldi	r25, 0x00	; 0
     3ac:	fc 01       	movw	r30, r24
     3ae:	ee 0f       	add	r30, r30
     3b0:	ff 1f       	adc	r31, r31
     3b2:	ee 0f       	add	r30, r30
     3b4:	ff 1f       	adc	r31, r31
     3b6:	e6 50       	subi	r30, 0x06	; 6
     3b8:	ff 4f       	sbci	r31, 0xFF	; 255
     3ba:	20 81       	ld	r18, Z
     3bc:	31 81       	ldd	r19, Z+1	; 0x01
     3be:	42 81       	ldd	r20, Z+2	; 0x02
     3c0:	53 81       	ldd	r21, Z+3	; 0x03
     3c2:	21 15       	cp	r18, r1
     3c4:	31 05       	cpc	r19, r1
     3c6:	41 05       	cpc	r20, r1
     3c8:	51 05       	cpc	r21, r1
     3ca:	21 f4       	brne	.+8      	; 0x3d4 <Division+0x36>
	{
		Division_By_Zero_Flag=1;
     3cc:	81 e0       	ldi	r24, 0x01	; 1
     3ce:	80 93 e6 00 	sts	0x00E6, r24	; 0x8000e6 <Division_By_Zero_Flag>
     3d2:	13 c0       	rjmp	.+38     	; 0x3fa <Division+0x5c>
	}
	else if (Numbers[i+1] != 0)
	{
		Numbers[i] /=  Numbers[i+1] ;
     3d4:	88 0f       	add	r24, r24
     3d6:	99 1f       	adc	r25, r25
     3d8:	88 0f       	add	r24, r24
     3da:	99 1f       	adc	r25, r25
     3dc:	8c 01       	movw	r16, r24
     3de:	0a 50       	subi	r16, 0x0A	; 10
     3e0:	1f 4f       	sbci	r17, 0xFF	; 255
     3e2:	f8 01       	movw	r30, r16
     3e4:	60 81       	ld	r22, Z
     3e6:	71 81       	ldd	r23, Z+1	; 0x01
     3e8:	82 81       	ldd	r24, Z+2	; 0x02
     3ea:	93 81       	ldd	r25, Z+3	; 0x03
     3ec:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <__divmodsi4>
     3f0:	f8 01       	movw	r30, r16
     3f2:	20 83       	st	Z, r18
     3f4:	31 83       	std	Z+1, r19	; 0x01
     3f6:	42 83       	std	Z+2, r20	; 0x02
     3f8:	53 83       	std	Z+3, r21	; 0x03
	}
	for (j = i; j<op_cntr ; j++)
     3fa:	c0 93 e2 00 	sts	0x00E2, r28	; 0x8000e2 <__data_end>
     3fe:	50 91 e4 00 	lds	r21, 0x00E4	; 0x8000e4 <op_cntr>
     402:	c5 17       	cp	r28, r21
     404:	40 f5       	brcc	.+80     	; 0x456 <__LOCK_REGION_LENGTH__+0x56>
	{
		Operations[j] = Operations[j+1];
     406:	8c 2f       	mov	r24, r28
     408:	90 e0       	ldi	r25, 0x00	; 0
     40a:	9c 01       	movw	r18, r24
     40c:	2f 5f       	subi	r18, 0xFF	; 255
     40e:	3f 4f       	sbci	r19, 0xFF	; 255
     410:	f9 01       	movw	r30, r18
     412:	e4 51       	subi	r30, 0x14	; 20
     414:	ff 4f       	sbci	r31, 0xFF	; 255
     416:	40 81       	ld	r20, Z
     418:	fc 01       	movw	r30, r24
     41a:	e4 51       	subi	r30, 0x14	; 20
     41c:	ff 4f       	sbci	r31, 0xFF	; 255
     41e:	40 83       	st	Z, r20
		Numbers[j+1] = Numbers[j+2];
     420:	88 0f       	add	r24, r24
     422:	99 1f       	adc	r25, r25
     424:	88 0f       	add	r24, r24
     426:	99 1f       	adc	r25, r25
     428:	fc 01       	movw	r30, r24
     42a:	e2 50       	subi	r30, 0x02	; 2
     42c:	ff 4f       	sbci	r31, 0xFF	; 255
     42e:	80 81       	ld	r24, Z
     430:	91 81       	ldd	r25, Z+1	; 0x01
     432:	a2 81       	ldd	r26, Z+2	; 0x02
     434:	b3 81       	ldd	r27, Z+3	; 0x03
     436:	22 0f       	add	r18, r18
     438:	33 1f       	adc	r19, r19
     43a:	22 0f       	add	r18, r18
     43c:	33 1f       	adc	r19, r19
     43e:	f9 01       	movw	r30, r18
     440:	ea 50       	subi	r30, 0x0A	; 10
     442:	ff 4f       	sbci	r31, 0xFF	; 255
     444:	80 83       	st	Z, r24
     446:	91 83       	std	Z+1, r25	; 0x01
     448:	a2 83       	std	Z+2, r26	; 0x02
     44a:	b3 83       	std	Z+3, r27	; 0x03
     44c:	cf 5f       	subi	r28, 0xFF	; 255
	}
	else if (Numbers[i+1] != 0)
	{
		Numbers[i] /=  Numbers[i+1] ;
	}
	for (j = i; j<op_cntr ; j++)
     44e:	c5 13       	cpse	r28, r21
     450:	da cf       	rjmp	.-76     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
     452:	50 93 e2 00 	sts	0x00E2, r21	; 0x8000e2 <__data_end>
	{
		Operations[j] = Operations[j+1];
		Numbers[j+1] = Numbers[j+2];
	}
}
     456:	cf 91       	pop	r28
     458:	1f 91       	pop	r17
     45a:	0f 91       	pop	r16
     45c:	08 95       	ret

0000045e <MulDiv_Sequence>:

}

void MulDiv_Sequence (void)
{
	for (i=0 ; i < op_cntr ; i++)
     45e:	10 92 e3 00 	sts	0x00E3, r1	; 0x8000e3 <i>
     462:	80 91 e4 00 	lds	r24, 0x00E4	; 0x8000e4 <op_cntr>
     466:	88 23       	and	r24, r24
     468:	09 f4       	brne	.+2      	; 0x46c <MulDiv_Sequence+0xe>
     46a:	91 c0       	rjmp	.+290    	; 0x58e <MulDiv_Sequence+0x130>
     46c:	80 e0       	ldi	r24, 0x00	; 0
	{
		if (Operations[i] == 'x' && Operations[i+1]== '/')
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	fc 01       	movw	r30, r24
     472:	e4 51       	subi	r30, 0x14	; 20
     474:	ff 4f       	sbci	r31, 0xFF	; 255
     476:	20 81       	ld	r18, Z
     478:	28 37       	cpi	r18, 0x78	; 120
     47a:	69 f5       	brne	.+90     	; 0x4d6 <MulDiv_Sequence+0x78>
     47c:	fc 01       	movw	r30, r24
     47e:	e4 51       	subi	r30, 0x14	; 20
     480:	ff 4f       	sbci	r31, 0xFF	; 255
     482:	81 81       	ldd	r24, Z+1	; 0x01
     484:	8f 32       	cpi	r24, 0x2F	; 47
     486:	09 f0       	breq	.+2      	; 0x48a <MulDiv_Sequence+0x2c>
     488:	53 c0       	rjmp	.+166    	; 0x530 <MulDiv_Sequence+0xd2>
		{
			while (Operations[i] == 'x' && Operations[i+1] == '/')
     48a:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <i>
     48e:	90 e0       	ldi	r25, 0x00	; 0
     490:	fc 01       	movw	r30, r24
     492:	e4 51       	subi	r30, 0x14	; 20
     494:	ff 4f       	sbci	r31, 0xFF	; 255
     496:	20 81       	ld	r18, Z
     498:	28 37       	cpi	r18, 0x78	; 120
     49a:	09 f0       	breq	.+2      	; 0x49e <MulDiv_Sequence+0x40>
     49c:	6e c0       	rjmp	.+220    	; 0x57a <MulDiv_Sequence+0x11c>
     49e:	fc 01       	movw	r30, r24
     4a0:	e4 51       	subi	r30, 0x14	; 20
     4a2:	ff 4f       	sbci	r31, 0xFF	; 255
     4a4:	81 81       	ldd	r24, Z+1	; 0x01
     4a6:	8f 32       	cpi	r24, 0x2F	; 47
     4a8:	09 f0       	breq	.+2      	; 0x4ac <MulDiv_Sequence+0x4e>
     4aa:	67 c0       	rjmp	.+206    	; 0x57a <MulDiv_Sequence+0x11c>
			{
				Multiplication();
     4ac:	0e 94 79 01 	call	0x2f2	; 0x2f2 <Multiplication>
				Division();
     4b0:	0e 94 cf 01 	call	0x39e	; 0x39e <Division>
{
	for (i=0 ; i < op_cntr ; i++)
	{
		if (Operations[i] == 'x' && Operations[i+1]== '/')
		{
			while (Operations[i] == 'x' && Operations[i+1] == '/')
     4b4:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <i>
     4b8:	90 e0       	ldi	r25, 0x00	; 0
     4ba:	fc 01       	movw	r30, r24
     4bc:	e4 51       	subi	r30, 0x14	; 20
     4be:	ff 4f       	sbci	r31, 0xFF	; 255
     4c0:	20 81       	ld	r18, Z
     4c2:	28 37       	cpi	r18, 0x78	; 120
     4c4:	09 f0       	breq	.+2      	; 0x4c8 <MulDiv_Sequence+0x6a>
     4c6:	59 c0       	rjmp	.+178    	; 0x57a <MulDiv_Sequence+0x11c>
     4c8:	fc 01       	movw	r30, r24
     4ca:	e4 51       	subi	r30, 0x14	; 20
     4cc:	ff 4f       	sbci	r31, 0xFF	; 255
     4ce:	81 81       	ldd	r24, Z+1	; 0x01
     4d0:	8f 32       	cpi	r24, 0x2F	; 47
     4d2:	61 f3       	breq	.-40     	; 0x4ac <MulDiv_Sequence+0x4e>
     4d4:	52 c0       	rjmp	.+164    	; 0x57a <MulDiv_Sequence+0x11c>
			{
				Multiplication();
				Division();
			}
		}
		else if (Operations[i] == '/' && Operations[i+1] == 'x')
     4d6:	2f 32       	cpi	r18, 0x2F	; 47
     4d8:	09 f0       	breq	.+2      	; 0x4dc <MulDiv_Sequence+0x7e>
     4da:	4f c0       	rjmp	.+158    	; 0x57a <MulDiv_Sequence+0x11c>
     4dc:	fc 01       	movw	r30, r24
     4de:	e4 51       	subi	r30, 0x14	; 20
     4e0:	ff 4f       	sbci	r31, 0xFF	; 255
     4e2:	81 81       	ldd	r24, Z+1	; 0x01
     4e4:	88 37       	cpi	r24, 0x78	; 120
     4e6:	b9 f5       	brne	.+110    	; 0x556 <MulDiv_Sequence+0xf8>
		{
			while (Operations [i] == '/' && Operations[i+1] == 'x')
     4e8:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <i>
     4ec:	90 e0       	ldi	r25, 0x00	; 0
     4ee:	fc 01       	movw	r30, r24
     4f0:	e4 51       	subi	r30, 0x14	; 20
     4f2:	ff 4f       	sbci	r31, 0xFF	; 255
     4f4:	20 81       	ld	r18, Z
     4f6:	2f 32       	cpi	r18, 0x2F	; 47
     4f8:	09 f0       	breq	.+2      	; 0x4fc <MulDiv_Sequence+0x9e>
     4fa:	3f c0       	rjmp	.+126    	; 0x57a <MulDiv_Sequence+0x11c>
     4fc:	fc 01       	movw	r30, r24
     4fe:	e4 51       	subi	r30, 0x14	; 20
     500:	ff 4f       	sbci	r31, 0xFF	; 255
     502:	81 81       	ldd	r24, Z+1	; 0x01
     504:	88 37       	cpi	r24, 0x78	; 120
     506:	c9 f5       	brne	.+114    	; 0x57a <MulDiv_Sequence+0x11c>
			{
				Division();
     508:	0e 94 cf 01 	call	0x39e	; 0x39e <Division>
			    Multiplication();
     50c:	0e 94 79 01 	call	0x2f2	; 0x2f2 <Multiplication>
				Division();
			}
		}
		else if (Operations[i] == '/' && Operations[i+1] == 'x')
		{
			while (Operations [i] == '/' && Operations[i+1] == 'x')
     510:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <i>
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	fc 01       	movw	r30, r24
     518:	e4 51       	subi	r30, 0x14	; 20
     51a:	ff 4f       	sbci	r31, 0xFF	; 255
     51c:	20 81       	ld	r18, Z
     51e:	2f 32       	cpi	r18, 0x2F	; 47
     520:	61 f5       	brne	.+88     	; 0x57a <MulDiv_Sequence+0x11c>
     522:	fc 01       	movw	r30, r24
     524:	e4 51       	subi	r30, 0x14	; 20
     526:	ff 4f       	sbci	r31, 0xFF	; 255
     528:	81 81       	ldd	r24, Z+1	; 0x01
     52a:	88 37       	cpi	r24, 0x78	; 120
     52c:	69 f3       	breq	.-38     	; 0x508 <MulDiv_Sequence+0xaa>
     52e:	25 c0       	rjmp	.+74     	; 0x57a <MulDiv_Sequence+0x11c>
		}
		else 
		{
			if (Operations[i] == 'x')
			{
				while (Operations [i] == 'x')
     530:	e0 91 e3 00 	lds	r30, 0x00E3	; 0x8000e3 <i>
     534:	f0 e0       	ldi	r31, 0x00	; 0
     536:	e4 51       	subi	r30, 0x14	; 20
     538:	ff 4f       	sbci	r31, 0xFF	; 255
     53a:	80 81       	ld	r24, Z
     53c:	88 37       	cpi	r24, 0x78	; 120
     53e:	e9 f4       	brne	.+58     	; 0x57a <MulDiv_Sequence+0x11c>
				{
					Multiplication();
     540:	0e 94 79 01 	call	0x2f2	; 0x2f2 <Multiplication>
		}
		else 
		{
			if (Operations[i] == 'x')
			{
				while (Operations [i] == 'x')
     544:	e0 91 e3 00 	lds	r30, 0x00E3	; 0x8000e3 <i>
     548:	f0 e0       	ldi	r31, 0x00	; 0
     54a:	e4 51       	subi	r30, 0x14	; 20
     54c:	ff 4f       	sbci	r31, 0xFF	; 255
     54e:	80 81       	ld	r24, Z
     550:	88 37       	cpi	r24, 0x78	; 120
     552:	b1 f3       	breq	.-20     	; 0x540 <MulDiv_Sequence+0xe2>
     554:	12 c0       	rjmp	.+36     	; 0x57a <MulDiv_Sequence+0x11c>
					Multiplication();
				}
			}
			else if (Operations[i] == '/')
			{
				while (Operations [i] == '/')
     556:	e0 91 e3 00 	lds	r30, 0x00E3	; 0x8000e3 <i>
     55a:	f0 e0       	ldi	r31, 0x00	; 0
     55c:	e4 51       	subi	r30, 0x14	; 20
     55e:	ff 4f       	sbci	r31, 0xFF	; 255
     560:	80 81       	ld	r24, Z
     562:	8f 32       	cpi	r24, 0x2F	; 47
     564:	51 f4       	brne	.+20     	; 0x57a <MulDiv_Sequence+0x11c>
				{
					Division();
     566:	0e 94 cf 01 	call	0x39e	; 0x39e <Division>
					Multiplication();
				}
			}
			else if (Operations[i] == '/')
			{
				while (Operations [i] == '/')
     56a:	e0 91 e3 00 	lds	r30, 0x00E3	; 0x8000e3 <i>
     56e:	f0 e0       	ldi	r31, 0x00	; 0
     570:	e4 51       	subi	r30, 0x14	; 20
     572:	ff 4f       	sbci	r31, 0xFF	; 255
     574:	80 81       	ld	r24, Z
     576:	8f 32       	cpi	r24, 0x2F	; 47
     578:	b1 f3       	breq	.-20     	; 0x566 <MulDiv_Sequence+0x108>

}

void MulDiv_Sequence (void)
{
	for (i=0 ; i < op_cntr ; i++)
     57a:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <i>
     57e:	8f 5f       	subi	r24, 0xFF	; 255
     580:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <i>
     584:	90 91 e4 00 	lds	r25, 0x00E4	; 0x8000e4 <op_cntr>
     588:	89 17       	cp	r24, r25
     58a:	08 f4       	brcc	.+2      	; 0x58e <MulDiv_Sequence+0x130>
     58c:	70 cf       	rjmp	.-288    	; 0x46e <MulDiv_Sequence+0x10>
					Division();
				}
			}
		}
	}
	result = Numbers[0];	
     58e:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <Numbers>
     592:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <Numbers+0x1>
     596:	a0 91 f8 00 	lds	r26, 0x00F8	; 0x8000f8 <Numbers+0x2>
     59a:	b0 91 f9 00 	lds	r27, 0x00F9	; 0x8000f9 <Numbers+0x3>
     59e:	80 93 e7 00 	sts	0x00E7, r24	; 0x8000e7 <result>
     5a2:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <result+0x1>
     5a6:	a0 93 e9 00 	sts	0x00E9, r26	; 0x8000e9 <result+0x2>
     5aa:	b0 93 ea 00 	sts	0x00EA, r27	; 0x8000ea <result+0x3>
     5ae:	08 95       	ret

000005b0 <SumSub_Sequence>:
		Numbers[j+1] = Numbers[j+2];
	}
}

void SumSub_Sequence (void)
{
     5b0:	cf 92       	push	r12
     5b2:	df 92       	push	r13
     5b4:	ef 92       	push	r14
     5b6:	ff 92       	push	r15
	for(i = 0 ; i < op_cntr; i++)
     5b8:	10 92 e3 00 	sts	0x00E3, r1	; 0x8000e3 <i>
     5bc:	90 91 e4 00 	lds	r25, 0x00E4	; 0x8000e4 <op_cntr>
     5c0:	99 23       	and	r25, r25
     5c2:	b9 f1       	breq	.+110    	; 0x632 <SumSub_Sequence+0x82>
     5c4:	40 91 e7 00 	lds	r20, 0x00E7	; 0x8000e7 <result>
     5c8:	50 91 e8 00 	lds	r21, 0x00E8	; 0x8000e8 <result+0x1>
     5cc:	60 91 e9 00 	lds	r22, 0x00E9	; 0x8000e9 <result+0x2>
     5d0:	70 91 ea 00 	lds	r23, 0x00EA	; 0x8000ea <result+0x3>
     5d4:	ec ee       	ldi	r30, 0xEC	; 236
     5d6:	f0 e0       	ldi	r31, 0x00	; 0
     5d8:	aa ef       	ldi	r26, 0xFA	; 250
     5da:	b0 e0       	ldi	r27, 0x00	; 0
     5dc:	2f ef       	ldi	r18, 0xFF	; 255
     5de:	29 0f       	add	r18, r25
     5e0:	30 e0       	ldi	r19, 0x00	; 0
     5e2:	23 51       	subi	r18, 0x13	; 19
     5e4:	3f 4f       	sbci	r19, 0xFF	; 255
	{
		if(Operations[i] == '+')
     5e6:	81 91       	ld	r24, Z+
     5e8:	8b 32       	cpi	r24, 0x2B	; 43
     5ea:	51 f4       	brne	.+20     	; 0x600 <SumSub_Sequence+0x50>
		result += Numbers[i+1];
     5ec:	cd 90       	ld	r12, X+
     5ee:	dd 90       	ld	r13, X+
     5f0:	ed 90       	ld	r14, X+
     5f2:	fc 90       	ld	r15, X
     5f4:	13 97       	sbiw	r26, 0x03	; 3
     5f6:	4c 0d       	add	r20, r12
     5f8:	5d 1d       	adc	r21, r13
     5fa:	6e 1d       	adc	r22, r14
     5fc:	7f 1d       	adc	r23, r15
     5fe:	0b c0       	rjmp	.+22     	; 0x616 <SumSub_Sequence+0x66>

		else if (Operations[i] == '-')
     600:	8d 32       	cpi	r24, 0x2D	; 45
     602:	49 f4       	brne	.+18     	; 0x616 <SumSub_Sequence+0x66>
		result -= Numbers[i+1];
     604:	cd 90       	ld	r12, X+
     606:	dd 90       	ld	r13, X+
     608:	ed 90       	ld	r14, X+
     60a:	fc 90       	ld	r15, X
     60c:	13 97       	sbiw	r26, 0x03	; 3
     60e:	4c 19       	sub	r20, r12
     610:	5d 09       	sbc	r21, r13
     612:	6e 09       	sbc	r22, r14
     614:	7f 09       	sbc	r23, r15
     616:	14 96       	adiw	r26, 0x04	; 4
	}
}

void SumSub_Sequence (void)
{
	for(i = 0 ; i < op_cntr; i++)
     618:	e2 17       	cp	r30, r18
     61a:	f3 07       	cpc	r31, r19
     61c:	21 f7       	brne	.-56     	; 0x5e6 <SumSub_Sequence+0x36>
     61e:	40 93 e7 00 	sts	0x00E7, r20	; 0x8000e7 <result>
     622:	50 93 e8 00 	sts	0x00E8, r21	; 0x8000e8 <result+0x1>
     626:	60 93 e9 00 	sts	0x00E9, r22	; 0x8000e9 <result+0x2>
     62a:	70 93 ea 00 	sts	0x00EA, r23	; 0x8000ea <result+0x3>
     62e:	90 93 e3 00 	sts	0x00E3, r25	; 0x8000e3 <i>
		result += Numbers[i+1];

		else if (Operations[i] == '-')
		result -= Numbers[i+1];
	}
}
     632:	ff 90       	pop	r15
     634:	ef 90       	pop	r14
     636:	df 90       	pop	r13
     638:	cf 90       	pop	r12
     63a:	08 95       	ret

0000063c <Calculate>:
}


void Calculate (void)
{
	MulDiv_Sequence();
     63c:	0e 94 2f 02 	call	0x45e	; 0x45e <MulDiv_Sequence>
	SumSub_Sequence();
     640:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <SumSub_Sequence>
	
	if (Division_By_Zero_Flag == 1)
     644:	80 91 e6 00 	lds	r24, 0x00E6	; 0x8000e6 <Division_By_Zero_Flag>
     648:	81 30       	cpi	r24, 0x01	; 1
     64a:	11 f4       	brne	.+4      	; 0x650 <Calculate+0x14>
	{
		Division_By_Zero();
     64c:	0e 94 53 01 	call	0x2a6	; 0x2a6 <Division_By_Zero>
     650:	08 95       	ret

00000652 <Task1_KeyPad_GetValue>:

void Task1_KeyPad_GetValue (void *ptr)
{
	while (1)
	{
		Key_Value= KeyPad_GetValue();
     652:	0e 94 ae 03 	call	0x75c	; 0x75c <KeyPad_GetValue>
     656:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <Key_Value>
		if (Key_Value != 0)
     65a:	88 23       	and	r24, r24
     65c:	51 f1       	breq	.+84     	; 0x6b2 <Task1_KeyPad_GetValue+0x60>
		{
			xQueueSend(	Queue1_Handle,(const void *) &Key_Value,(TickType_t) portMAX_DELAY );
     65e:	20 e0       	ldi	r18, 0x00	; 0
     660:	4f ef       	ldi	r20, 0xFF	; 255
     662:	5f ef       	ldi	r21, 0xFF	; 255
     664:	6b ee       	ldi	r22, 0xEB	; 235
     666:	70 e0       	ldi	r23, 0x00	; 0
     668:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <Queue1_Handle>
     66c:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <Queue1_Handle+0x1>
     670:	0e 94 1c 0a 	call	0x1438	; 0x1438 <xQueueGenericSend>
			
			if (Key_Value == 'x' || Key_Value == '/' || Key_Value == '+' || Key_Value == '-')
     674:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <Key_Value>
     678:	88 37       	cpi	r24, 0x78	; 120
     67a:	31 f0       	breq	.+12     	; 0x688 <Task1_KeyPad_GetValue+0x36>
     67c:	98 2f       	mov	r25, r24
     67e:	9b 7f       	andi	r25, 0xFB	; 251
     680:	9b 32       	cpi	r25, 0x2B	; 43
     682:	11 f0       	breq	.+4      	; 0x688 <Task1_KeyPad_GetValue+0x36>
     684:	8d 32       	cpi	r24, 0x2D	; 45
     686:	19 f4       	brne	.+6      	; 0x68e <Task1_KeyPad_GetValue+0x3c>
			{
				Operations_Buttons();
     688:	0e 94 10 01 	call	0x220	; 0x220 <Operations_Buttons>
     68c:	12 c0       	rjmp	.+36     	; 0x6b2 <Task1_KeyPad_GetValue+0x60>
			}
			else if (Key_Value >= '0' && Key_Value <= '9')
     68e:	90 ed       	ldi	r25, 0xD0	; 208
     690:	98 0f       	add	r25, r24
     692:	9a 30       	cpi	r25, 0x0A	; 10
     694:	18 f4       	brcc	.+6      	; 0x69c <Task1_KeyPad_GetValue+0x4a>
			{
				Numbers_Buttons();
     696:	0e 94 22 01 	call	0x244	; 0x244 <Numbers_Buttons>
     69a:	0b c0       	rjmp	.+22     	; 0x6b2 <Task1_KeyPad_GetValue+0x60>
			}
			else if (Key_Value == '=')
     69c:	8d 33       	cpi	r24, 0x3D	; 61
     69e:	29 f4       	brne	.+10     	; 0x6aa <Task1_KeyPad_GetValue+0x58>
			{
				Calculate();
     6a0:	0e 94 1e 03 	call	0x63c	; 0x63c <Calculate>
				Calculate();
     6a4:	0e 94 1e 03 	call	0x63c	; 0x63c <Calculate>
     6a8:	04 c0       	rjmp	.+8      	; 0x6b2 <Task1_KeyPad_GetValue+0x60>
			}
			else if (Key_Value == 'c')
     6aa:	83 36       	cpi	r24, 0x63	; 99
     6ac:	11 f4       	brne	.+4      	; 0x6b2 <Task1_KeyPad_GetValue+0x60>
			{
				Clear_Button();
     6ae:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <Clear_Button>
			}
		}
		vTaskDelay( (const TickType_t) 100);
     6b2:	84 e6       	ldi	r24, 0x64	; 100
     6b4:	90 e0       	ldi	r25, 0x00	; 0
     6b6:	0e 94 75 0e 	call	0x1cea	; 0x1cea <vTaskDelay>
	}
     6ba:	cb cf       	rjmp	.-106    	; 0x652 <Task1_KeyPad_GetValue>

000006bc <App>:
		vTaskDelay( (const TickType_t) 50);
	}
}

void App (void)
{
     6bc:	ef 92       	push	r14
     6be:	ff 92       	push	r15
     6c0:	0f 93       	push	r16
	xTaskCreate(    Tasks_Init ,
     6c2:	0f 2e       	mov	r0, r31
     6c4:	f8 e3       	ldi	r31, 0x38	; 56
     6c6:	ef 2e       	mov	r14, r31
     6c8:	f1 e0       	ldi	r31, 0x01	; 1
     6ca:	ff 2e       	mov	r15, r31
     6cc:	f0 2d       	mov	r31, r0
     6ce:	03 e0       	ldi	r16, 0x03	; 3
     6d0:	20 e0       	ldi	r18, 0x00	; 0
     6d2:	30 e0       	ldi	r19, 0x00	; 0
     6d4:	44 e6       	ldi	r20, 0x64	; 100
     6d6:	50 e0       	ldi	r21, 0x00	; 0
     6d8:	6e ea       	ldi	r22, 0xAE	; 174
     6da:	70 e0       	ldi	r23, 0x00	; 0
     6dc:	89 e4       	ldi	r24, 0x49	; 73
     6de:	90 e0       	ldi	r25, 0x00	; 0
     6e0:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <xTaskCreate>
	NULL,
	3,
	&Init_Task_Handle
	);
	
	xTaskCreate(    Task1_KeyPad_GetValue,
     6e4:	0f 2e       	mov	r0, r31
     6e6:	f6 e3       	ldi	r31, 0x36	; 54
     6e8:	ef 2e       	mov	r14, r31
     6ea:	f1 e0       	ldi	r31, 0x01	; 1
     6ec:	ff 2e       	mov	r15, r31
     6ee:	f0 2d       	mov	r31, r0
     6f0:	02 e0       	ldi	r16, 0x02	; 2
     6f2:	20 e0       	ldi	r18, 0x00	; 0
     6f4:	30 e0       	ldi	r19, 0x00	; 0
     6f6:	44 e6       	ldi	r20, 0x64	; 100
     6f8:	50 e0       	ldi	r21, 0x00	; 0
     6fa:	68 eb       	ldi	r22, 0xB8	; 184
     6fc:	70 e0       	ldi	r23, 0x00	; 0
     6fe:	89 e2       	ldi	r24, 0x29	; 41
     700:	93 e0       	ldi	r25, 0x03	; 3
     702:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <xTaskCreate>
	NULL,
	2,
	&Task_1_Handle
	);
	
	xTaskCreate(    Task2_LCDDisplay,
     706:	0f 2e       	mov	r0, r31
     708:	f4 e3       	ldi	r31, 0x34	; 52
     70a:	ef 2e       	mov	r14, r31
     70c:	f1 e0       	ldi	r31, 0x01	; 1
     70e:	ff 2e       	mov	r15, r31
     710:	f0 2d       	mov	r31, r0
     712:	01 e0       	ldi	r16, 0x01	; 1
     714:	20 e0       	ldi	r18, 0x00	; 0
     716:	30 e0       	ldi	r19, 0x00	; 0
     718:	44 e6       	ldi	r20, 0x64	; 100
     71a:	50 e0       	ldi	r21, 0x00	; 0
     71c:	60 ec       	ldi	r22, 0xC0	; 192
     71e:	70 e0       	ldi	r23, 0x00	; 0
     720:	8d e8       	ldi	r24, 0x8D	; 141
     722:	90 e0       	ldi	r25, 0x00	; 0
     724:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <xTaskCreate>
	NULL,
	1,
	&Task_2_Handle
	);
	
	vTaskStartScheduler();
     728:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <vTaskStartScheduler>

     72c:	0f 91       	pop	r16
     72e:	ff 90       	pop	r15
     730:	ef 90       	pop	r14
     732:	08 95       	ret

00000734 <main>:

#include "Calculator.h"

int main(void)
{
   App();
     734:	0e 94 5e 03 	call	0x6bc	; 0x6bc <App>
     738:	ff cf       	rjmp	.-2      	; 0x738 <main+0x4>

0000073a <KeyPad_Init>:
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void KeyPad_Init(void)
{
	DIO_WriteChannel( KEYPAD_ROW_0 , PIN_HIGH);
     73a:	61 e0       	ldi	r22, 0x01	; 1
     73c:	8c e0       	ldi	r24, 0x0C	; 12
     73e:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel( KEYPAD_ROW_1 , PIN_HIGH);
     742:	61 e0       	ldi	r22, 0x01	; 1
     744:	8d e0       	ldi	r24, 0x0D	; 13
     746:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel( KEYPAD_ROW_2 , PIN_HIGH);
     74a:	61 e0       	ldi	r22, 0x01	; 1
     74c:	8e e0       	ldi	r24, 0x0E	; 14
     74e:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel( KEYPAD_ROW_3 , PIN_HIGH);
     752:	61 e0       	ldi	r22, 0x01	; 1
     754:	8f e0       	ldi	r24, 0x0F	; 15
     756:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
     75a:	08 95       	ret

0000075c <KeyPad_GetValue>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
uint8 KeyPad_GetValue (void)
{
     75c:	df 92       	push	r13
     75e:	ef 92       	push	r14
     760:	ff 92       	push	r15
     762:	0f 93       	push	r16
     764:	1f 93       	push	r17
     766:	cf 93       	push	r28
     768:	df 93       	push	r29
     76a:	0f 2e       	mov	r0, r31
     76c:	fc ec       	ldi	r31, 0xCC	; 204
     76e:	ef 2e       	mov	r14, r31
     770:	f0 e0       	ldi	r31, 0x00	; 0
     772:	ff 2e       	mov	r15, r31
     774:	f0 2d       	mov	r31, r0
	uint8 ROW_LOC = 0 , COL_LOC = 0 , Button_Val = 0 , Temp_Val = 0;
     776:	d1 2c       	mov	r13, r1
	for (ROW_LOC = KEYPAD_ROW_START ; ROW_LOC <= KEYPAD_ROW_END ; ROW_LOC++)
     778:	dc e0       	ldi	r29, 0x0C	; 12
	{
		DIO_WriteChannel( ROW_LOC , PIN_LOW);
     77a:	60 e0       	ldi	r22, 0x00	; 0
     77c:	8d 2f       	mov	r24, r29
     77e:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
     782:	87 01       	movw	r16, r14
		
		for(COL_LOC= KEYPAD_COL_START ; COL_LOC <= KEYPAD_COL_END ; COL_LOC++)
     784:	ca e1       	ldi	r28, 0x1A	; 26
		{
			Temp_Val = DIO_ReadChannel(COL_LOC);
     786:	8c 2f       	mov	r24, r28
     788:	0e 94 1e 06 	call	0xc3c	; 0xc3c <DIO_ReadChannel>
			
			if (Temp_Val == 0)
     78c:	81 11       	cpse	r24, r1
     78e:	0d c0       	rjmp	.+26     	; 0x7aa <KeyPad_GetValue+0x4e>
			{
				Button_Val = KeyPad_Values[ROW_LOC - KEYPAD_ROW_START][COL_LOC - KEYPAD_COL_START];
     790:	f8 01       	movw	r30, r16
     792:	d0 80       	ld	r13, Z
				while(Temp_Val == 0)
				{
					Temp_Val = DIO_ReadChannel(COL_LOC);
     794:	8c 2f       	mov	r24, r28
     796:	0e 94 1e 06 	call	0xc3c	; 0xc3c <DIO_ReadChannel>
			Temp_Val = DIO_ReadChannel(COL_LOC);
			
			if (Temp_Val == 0)
			{
				Button_Val = KeyPad_Values[ROW_LOC - KEYPAD_ROW_START][COL_LOC - KEYPAD_COL_START];
				while(Temp_Val == 0)
     79a:	88 23       	and	r24, r24
     79c:	d9 f3       	breq	.-10     	; 0x794 <KeyPad_GetValue+0x38>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     79e:	8f e3       	ldi	r24, 0x3F	; 63
     7a0:	9c e9       	ldi	r25, 0x9C	; 156
     7a2:	01 97       	sbiw	r24, 0x01	; 1
     7a4:	f1 f7       	brne	.-4      	; 0x7a2 <KeyPad_GetValue+0x46>
     7a6:	00 c0       	rjmp	.+0      	; 0x7a8 <KeyPad_GetValue+0x4c>
     7a8:	00 00       	nop
	uint8 ROW_LOC = 0 , COL_LOC = 0 , Button_Val = 0 , Temp_Val = 0;
	for (ROW_LOC = KEYPAD_ROW_START ; ROW_LOC <= KEYPAD_ROW_END ; ROW_LOC++)
	{
		DIO_WriteChannel( ROW_LOC , PIN_LOW);
		
		for(COL_LOC= KEYPAD_COL_START ; COL_LOC <= KEYPAD_COL_END ; COL_LOC++)
     7aa:	cf 5f       	subi	r28, 0xFF	; 255
     7ac:	0f 5f       	subi	r16, 0xFF	; 255
     7ae:	1f 4f       	sbci	r17, 0xFF	; 255
     7b0:	ce 31       	cpi	r28, 0x1E	; 30
     7b2:	49 f7       	brne	.-46     	; 0x786 <KeyPad_GetValue+0x2a>
					Temp_Val = DIO_ReadChannel(COL_LOC);
				}
				_delay_ms(10);
			}
		}
		DIO_WriteChannel(ROW_LOC , PIN_HIGH);
     7b4:	61 e0       	ldi	r22, 0x01	; 1
     7b6:	8d 2f       	mov	r24, r29
     7b8:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
*                                    E_NOT_OK
*******************************************************************************/
uint8 KeyPad_GetValue (void)
{
	uint8 ROW_LOC = 0 , COL_LOC = 0 , Button_Val = 0 , Temp_Val = 0;
	for (ROW_LOC = KEYPAD_ROW_START ; ROW_LOC <= KEYPAD_ROW_END ; ROW_LOC++)
     7bc:	df 5f       	subi	r29, 0xFF	; 255
     7be:	94 e0       	ldi	r25, 0x04	; 4
     7c0:	e9 0e       	add	r14, r25
     7c2:	f1 1c       	adc	r15, r1
     7c4:	d0 31       	cpi	r29, 0x10	; 16
     7c6:	c9 f6       	brne	.-78     	; 0x77a <KeyPad_GetValue+0x1e>
		}
		DIO_WriteChannel(ROW_LOC , PIN_HIGH);
	}
	
	return Button_Val;
}
     7c8:	8d 2d       	mov	r24, r13
     7ca:	df 91       	pop	r29
     7cc:	cf 91       	pop	r28
     7ce:	1f 91       	pop	r17
     7d0:	0f 91       	pop	r16
     7d2:	ff 90       	pop	r15
     7d4:	ef 90       	pop	r14
     7d6:	df 90       	pop	r13
     7d8:	08 95       	ret

000007da <LCD_WriteCommand>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void LCD_WriteCommand(uint8 cmd)
{
     7da:	cf 93       	push	r28
     7dc:	c8 2f       	mov	r28, r24
	DIO_WriteChannel(LCD_RS_PIN , PIN_LOW);
     7de:	60 e0       	ldi	r22, 0x00	; 0
     7e0:	81 e0       	ldi	r24, 0x01	; 1
     7e2:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_E_PIN , PIN_LOW);
     7e6:	60 e0       	ldi	r22, 0x00	; 0
     7e8:	82 e0       	ldi	r24, 0x02	; 2
     7ea:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_D4_PIN , GET_BIT(cmd , 4));
     7ee:	c4 fb       	bst	r28, 4
     7f0:	66 27       	eor	r22, r22
     7f2:	60 f9       	bld	r22, 0
     7f4:	83 e0       	ldi	r24, 0x03	; 3
     7f6:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D5_PIN , GET_BIT(cmd , 5));
     7fa:	c5 fb       	bst	r28, 5
     7fc:	66 27       	eor	r22, r22
     7fe:	60 f9       	bld	r22, 0
     800:	84 e0       	ldi	r24, 0x04	; 4
     802:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D6_PIN , GET_BIT(cmd , 6));
     806:	c6 fb       	bst	r28, 6
     808:	66 27       	eor	r22, r22
     80a:	60 f9       	bld	r22, 0
     80c:	85 e0       	ldi	r24, 0x05	; 5
     80e:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D7_PIN , GET_BIT(cmd , 7));
     812:	6c 2f       	mov	r22, r28
     814:	66 1f       	adc	r22, r22
     816:	66 27       	eor	r22, r22
     818:	66 1f       	adc	r22, r22
     81a:	86 e0       	ldi	r24, 0x06	; 6
     81c:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_E_PIN , PIN_HIGH);
     820:	61 e0       	ldi	r22, 0x01	; 1
     822:	82 e0       	ldi	r24, 0x02	; 2
     824:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
     828:	8f e9       	ldi	r24, 0x9F	; 159
     82a:	9f e0       	ldi	r25, 0x0F	; 15
     82c:	01 97       	sbiw	r24, 0x01	; 1
     82e:	f1 f7       	brne	.-4      	; 0x82c <LCD_WriteCommand+0x52>
     830:	00 c0       	rjmp	.+0      	; 0x832 <LCD_WriteCommand+0x58>
     832:	00 00       	nop
	_delay_ms(1);
	DIO_WriteChannel(LCD_E_PIN , PIN_LOW);
     834:	60 e0       	ldi	r22, 0x00	; 0
     836:	82 e0       	ldi	r24, 0x02	; 2
     838:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_D4_PIN , GET_BIT(cmd , 0));
     83c:	6c 2f       	mov	r22, r28
     83e:	61 70       	andi	r22, 0x01	; 1
     840:	83 e0       	ldi	r24, 0x03	; 3
     842:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D5_PIN , GET_BIT(cmd , 1));
     846:	c1 fb       	bst	r28, 1
     848:	66 27       	eor	r22, r22
     84a:	60 f9       	bld	r22, 0
     84c:	84 e0       	ldi	r24, 0x04	; 4
     84e:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D6_PIN , GET_BIT(cmd , 2));
     852:	c2 fb       	bst	r28, 2
     854:	66 27       	eor	r22, r22
     856:	60 f9       	bld	r22, 0
     858:	85 e0       	ldi	r24, 0x05	; 5
     85a:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D7_PIN , GET_BIT(cmd , 3));
     85e:	c3 fb       	bst	r28, 3
     860:	66 27       	eor	r22, r22
     862:	60 f9       	bld	r22, 0
     864:	86 e0       	ldi	r24, 0x06	; 6
     866:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_E_PIN , PIN_HIGH);
     86a:	61 e0       	ldi	r22, 0x01	; 1
     86c:	82 e0       	ldi	r24, 0x02	; 2
     86e:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
     872:	8f e9       	ldi	r24, 0x9F	; 159
     874:	9f e0       	ldi	r25, 0x0F	; 15
     876:	01 97       	sbiw	r24, 0x01	; 1
     878:	f1 f7       	brne	.-4      	; 0x876 <__stack+0x17>
     87a:	00 c0       	rjmp	.+0      	; 0x87c <__stack+0x1d>
     87c:	00 00       	nop
	_delay_ms(1);
	DIO_WriteChannel(LCD_E_PIN , PIN_LOW);
     87e:	60 e0       	ldi	r22, 0x00	; 0
     880:	82 e0       	ldi	r24, 0x02	; 2
     882:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
     886:	8f e1       	ldi	r24, 0x1F	; 31
     888:	9e e4       	ldi	r25, 0x4E	; 78
     88a:	01 97       	sbiw	r24, 0x01	; 1
     88c:	f1 f7       	brne	.-4      	; 0x88a <__stack+0x2b>
     88e:	00 c0       	rjmp	.+0      	; 0x890 <__stack+0x31>
     890:	00 00       	nop
	
	_delay_ms(5);
}
     892:	cf 91       	pop	r28
     894:	08 95       	ret

00000896 <LCD_Init>:
*******************************************************************************/
void LCD_Init(void)
{
	#if (LCD_OPERATION_MODE == 4)
	/*LCD 4 BIT MODE COMMANDS*/
	LCD_WriteCommand(0X33);
     896:	83 e3       	ldi	r24, 0x33	; 51
     898:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_WriteCommand>
	LCD_WriteCommand(0X32);
     89c:	82 e3       	ldi	r24, 0x32	; 50
     89e:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_WriteCommand>
	LCD_WriteCommand(0X28); // 2Lines and 5*8 dots
     8a2:	88 e2       	ldi	r24, 0x28	; 40
     8a4:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_WriteCommand>
	
	LCD_WriteCommand(0X01); // Clear Display
     8a8:	81 e0       	ldi	r24, 0x01	; 1
     8aa:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_WriteCommand>
	LCD_WriteCommand(0X06); // Increase Cursor to the Right, and Shift entire Display OFF
     8ae:	86 e0       	ldi	r24, 0x06	; 6
     8b0:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_WriteCommand>
	LCD_WriteCommand(0x0C); // Display ON , Cursor OFF , Cursor Blink OFF
     8b4:	8c e0       	ldi	r24, 0x0C	; 12
     8b6:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_WriteCommand>
	LCD_WriteCommand(0X02); // Return Home Instruction 
     8ba:	82 e0       	ldi	r24, 0x02	; 2
     8bc:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_WriteCommand>
     8c0:	8f e1       	ldi	r24, 0x1F	; 31
     8c2:	9e e4       	ldi	r25, 0x4E	; 78
     8c4:	01 97       	sbiw	r24, 0x01	; 1
     8c6:	f1 f7       	brne	.-4      	; 0x8c4 <LCD_Init+0x2e>
     8c8:	00 c0       	rjmp	.+0      	; 0x8ca <LCD_Init+0x34>
     8ca:	00 00       	nop
     8cc:	08 95       	ret

000008ce <LCD_WriteChar>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void LCD_WriteChar(uint8 Data)
{
     8ce:	cf 93       	push	r28
     8d0:	c8 2f       	mov	r28, r24
	DIO_WriteChannel(LCD_RS_PIN , PIN_HIGH);
     8d2:	61 e0       	ldi	r22, 0x01	; 1
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_E_PIN , PIN_LOW);
     8da:	60 e0       	ldi	r22, 0x00	; 0
     8dc:	82 e0       	ldi	r24, 0x02	; 2
     8de:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_D4_PIN , GET_BIT(Data , 4));
     8e2:	c4 fb       	bst	r28, 4
     8e4:	66 27       	eor	r22, r22
     8e6:	60 f9       	bld	r22, 0
     8e8:	83 e0       	ldi	r24, 0x03	; 3
     8ea:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D5_PIN , GET_BIT(Data , 5));
     8ee:	c5 fb       	bst	r28, 5
     8f0:	66 27       	eor	r22, r22
     8f2:	60 f9       	bld	r22, 0
     8f4:	84 e0       	ldi	r24, 0x04	; 4
     8f6:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D6_PIN , GET_BIT(Data , 6));
     8fa:	c6 fb       	bst	r28, 6
     8fc:	66 27       	eor	r22, r22
     8fe:	60 f9       	bld	r22, 0
     900:	85 e0       	ldi	r24, 0x05	; 5
     902:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D7_PIN , GET_BIT(Data , 7));
     906:	6c 2f       	mov	r22, r28
     908:	66 1f       	adc	r22, r22
     90a:	66 27       	eor	r22, r22
     90c:	66 1f       	adc	r22, r22
     90e:	86 e0       	ldi	r24, 0x06	; 6
     910:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_E_PIN , PIN_HIGH);
     914:	61 e0       	ldi	r22, 0x01	; 1
     916:	82 e0       	ldi	r24, 0x02	; 2
     918:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
     91c:	8f e9       	ldi	r24, 0x9F	; 159
     91e:	9f e0       	ldi	r25, 0x0F	; 15
     920:	01 97       	sbiw	r24, 0x01	; 1
     922:	f1 f7       	brne	.-4      	; 0x920 <LCD_WriteChar+0x52>
     924:	00 c0       	rjmp	.+0      	; 0x926 <LCD_WriteChar+0x58>
     926:	00 00       	nop
	_delay_ms(1);
	DIO_WriteChannel(LCD_E_PIN , PIN_LOW);
     928:	60 e0       	ldi	r22, 0x00	; 0
     92a:	82 e0       	ldi	r24, 0x02	; 2
     92c:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_D4_PIN , GET_BIT(Data , 0));
     930:	6c 2f       	mov	r22, r28
     932:	61 70       	andi	r22, 0x01	; 1
     934:	83 e0       	ldi	r24, 0x03	; 3
     936:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D5_PIN , GET_BIT(Data , 1));
     93a:	c1 fb       	bst	r28, 1
     93c:	66 27       	eor	r22, r22
     93e:	60 f9       	bld	r22, 0
     940:	84 e0       	ldi	r24, 0x04	; 4
     942:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D6_PIN , GET_BIT(Data , 2));
     946:	c2 fb       	bst	r28, 2
     948:	66 27       	eor	r22, r22
     94a:	60 f9       	bld	r22, 0
     94c:	85 e0       	ldi	r24, 0x05	; 5
     94e:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D7_PIN , GET_BIT(Data , 3));
     952:	c3 fb       	bst	r28, 3
     954:	66 27       	eor	r22, r22
     956:	60 f9       	bld	r22, 0
     958:	86 e0       	ldi	r24, 0x06	; 6
     95a:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_E_PIN , PIN_HIGH);
     95e:	61 e0       	ldi	r22, 0x01	; 1
     960:	82 e0       	ldi	r24, 0x02	; 2
     962:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
     966:	8f e9       	ldi	r24, 0x9F	; 159
     968:	9f e0       	ldi	r25, 0x0F	; 15
     96a:	01 97       	sbiw	r24, 0x01	; 1
     96c:	f1 f7       	brne	.-4      	; 0x96a <LCD_WriteChar+0x9c>
     96e:	00 c0       	rjmp	.+0      	; 0x970 <LCD_WriteChar+0xa2>
     970:	00 00       	nop
	_delay_ms(1);
	DIO_WriteChannel(LCD_E_PIN , PIN_LOW);
     972:	60 e0       	ldi	r22, 0x00	; 0
     974:	82 e0       	ldi	r24, 0x02	; 2
     976:	0e 94 97 05 	call	0xb2e	; 0xb2e <DIO_WriteChannel>
     97a:	8f e1       	ldi	r24, 0x1F	; 31
     97c:	9e e4       	ldi	r25, 0x4E	; 78
     97e:	01 97       	sbiw	r24, 0x01	; 1
     980:	f1 f7       	brne	.-4      	; 0x97e <LCD_WriteChar+0xb0>
     982:	00 c0       	rjmp	.+0      	; 0x984 <LCD_WriteChar+0xb6>
     984:	00 00       	nop
	
	_delay_ms(5);
}
     986:	cf 91       	pop	r28
     988:	08 95       	ret

0000098a <LCD_WriteString>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void LCD_WriteString(uint8* str)
{
     98a:	0f 93       	push	r16
     98c:	1f 93       	push	r17
     98e:	cf 93       	push	r28
     990:	fc 01       	movw	r30, r24
	uint8 i=0;
	while(str[i]!='\0')
     992:	80 81       	ld	r24, Z
     994:	88 23       	and	r24, r24
     996:	59 f0       	breq	.+22     	; 0x9ae <LCD_WriteString+0x24>
     998:	8f 01       	movw	r16, r30
     99a:	c0 e0       	ldi	r28, 0x00	; 0
	{
		LCD_WriteChar(str[i]);
     99c:	0e 94 67 04 	call	0x8ce	; 0x8ce <LCD_WriteChar>
		i++;
     9a0:	cf 5f       	subi	r28, 0xFF	; 255
*                                    E_NOT_OK
*******************************************************************************/
void LCD_WriteString(uint8* str)
{
	uint8 i=0;
	while(str[i]!='\0')
     9a2:	f8 01       	movw	r30, r16
     9a4:	ec 0f       	add	r30, r28
     9a6:	f1 1d       	adc	r31, r1
     9a8:	80 81       	ld	r24, Z
     9aa:	81 11       	cpse	r24, r1
     9ac:	f7 cf       	rjmp	.-18     	; 0x99c <LCD_WriteString+0x12>
     9ae:	8f e1       	ldi	r24, 0x1F	; 31
     9b0:	9e e4       	ldi	r25, 0x4E	; 78
     9b2:	01 97       	sbiw	r24, 0x01	; 1
     9b4:	f1 f7       	brne	.-4      	; 0x9b2 <LCD_WriteString+0x28>
     9b6:	00 c0       	rjmp	.+0      	; 0x9b8 <LCD_WriteString+0x2e>
     9b8:	00 00       	nop
	{
		LCD_WriteChar(str[i]);
		i++;
	}
	_delay_ms(5);
}
     9ba:	cf 91       	pop	r28
     9bc:	1f 91       	pop	r17
     9be:	0f 91       	pop	r16
     9c0:	08 95       	ret

000009c2 <LCD_WriteInteger>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void LCD_WriteInteger(sint32 num)
{
     9c2:	4f 92       	push	r4
     9c4:	5f 92       	push	r5
     9c6:	6f 92       	push	r6
     9c8:	7f 92       	push	r7
     9ca:	8f 92       	push	r8
     9cc:	9f 92       	push	r9
     9ce:	af 92       	push	r10
     9d0:	bf 92       	push	r11
     9d2:	cf 92       	push	r12
     9d4:	df 92       	push	r13
     9d6:	ef 92       	push	r14
     9d8:	ff 92       	push	r15
     9da:	6b 01       	movw	r12, r22
     9dc:	7c 01       	movw	r14, r24
	 sint32 temp = 1;
	 if(num == 0)
     9de:	61 15       	cp	r22, r1
     9e0:	71 05       	cpc	r23, r1
     9e2:	81 05       	cpc	r24, r1
     9e4:	91 05       	cpc	r25, r1
     9e6:	51 f4       	brne	.+20     	; 0x9fc <LCD_WriteInteger+0x3a>
	 {
		 LCD_WriteChar('0');
     9e8:	80 e3       	ldi	r24, 0x30	; 48
     9ea:	0e 94 67 04 	call	0x8ce	; 0x8ce <LCD_WriteChar>
     9ee:	67 c0       	rjmp	.+206    	; 0xabe <LCD_WriteInteger+0xfc>
		 LCD_WriteChar('-');
		 num *= -1;
	 }

		 
	 while(num > 0)
     9f0:	1c 14       	cp	r1, r12
     9f2:	1d 04       	cpc	r1, r13
     9f4:	1e 04       	cpc	r1, r14
     9f6:	1f 04       	cpc	r1, r15
     9f8:	7c f0       	brlt	.+30     	; 0xa18 <LCD_WriteInteger+0x56>
     9fa:	61 c0       	rjmp	.+194    	; 0xabe <LCD_WriteInteger+0xfc>
	 if(num == 0)
	 {
		 LCD_WriteChar('0');
	 }

	 else if(num < 0)
     9fc:	99 23       	and	r25, r25
     9fe:	c4 f7       	brge	.-16     	; 0x9f0 <LCD_WriteInteger+0x2e>
	 {
		 LCD_WriteChar('-');
     a00:	8d e2       	ldi	r24, 0x2D	; 45
     a02:	0e 94 67 04 	call	0x8ce	; 0x8ce <LCD_WriteChar>
		 num *= -1;
     a06:	f0 94       	com	r15
     a08:	e0 94       	com	r14
     a0a:	d0 94       	com	r13
     a0c:	c0 94       	com	r12
     a0e:	c1 1c       	adc	r12, r1
     a10:	d1 1c       	adc	r13, r1
     a12:	e1 1c       	adc	r14, r1
     a14:	f1 1c       	adc	r15, r1
     a16:	ec cf       	rjmp	.-40     	; 0x9f0 <LCD_WriteInteger+0x2e>
	 }

		 
	 while(num > 0)
     a18:	61 e0       	ldi	r22, 0x01	; 1
     a1a:	70 e0       	ldi	r23, 0x00	; 0
     a1c:	80 e0       	ldi	r24, 0x00	; 0
     a1e:	90 e0       	ldi	r25, 0x00	; 0
	 {
	  temp = ((temp*10) + (num%10));
     a20:	0f 2e       	mov	r0, r31
     a22:	fa e0       	ldi	r31, 0x0A	; 10
     a24:	8f 2e       	mov	r8, r31
     a26:	91 2c       	mov	r9, r1
     a28:	a1 2c       	mov	r10, r1
     a2a:	b1 2c       	mov	r11, r1
     a2c:	f0 2d       	mov	r31, r0
     a2e:	dc 01       	movw	r26, r24
     a30:	cb 01       	movw	r24, r22
     a32:	88 0f       	add	r24, r24
     a34:	99 1f       	adc	r25, r25
     a36:	aa 1f       	adc	r26, r26
     a38:	bb 1f       	adc	r27, r27
     a3a:	2c 01       	movw	r4, r24
     a3c:	3d 01       	movw	r6, r26
     a3e:	44 0c       	add	r4, r4
     a40:	55 1c       	adc	r5, r5
     a42:	66 1c       	adc	r6, r6
     a44:	77 1c       	adc	r7, r7
     a46:	44 0c       	add	r4, r4
     a48:	55 1c       	adc	r5, r5
     a4a:	66 1c       	adc	r6, r6
     a4c:	77 1c       	adc	r7, r7
     a4e:	48 0e       	add	r4, r24
     a50:	59 1e       	adc	r5, r25
     a52:	6a 1e       	adc	r6, r26
     a54:	7b 1e       	adc	r7, r27
     a56:	c7 01       	movw	r24, r14
     a58:	b6 01       	movw	r22, r12
     a5a:	a5 01       	movw	r20, r10
     a5c:	94 01       	movw	r18, r8
     a5e:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <__divmodsi4>
     a62:	64 0d       	add	r22, r4
     a64:	75 1d       	adc	r23, r5
     a66:	86 1d       	adc	r24, r6
     a68:	97 1d       	adc	r25, r7
	  num /= 10;
     a6a:	c2 2e       	mov	r12, r18
     a6c:	d3 2e       	mov	r13, r19
     a6e:	e4 2e       	mov	r14, r20
     a70:	f5 2e       	mov	r15, r21
		 LCD_WriteChar('-');
		 num *= -1;
	 }

		 
	 while(num > 0)
     a72:	1c 14       	cp	r1, r12
     a74:	1d 04       	cpc	r1, r13
     a76:	1e 04       	cpc	r1, r14
     a78:	1f 04       	cpc	r1, r15
     a7a:	cc f2       	brlt	.-78     	; 0xa2e <LCD_WriteInteger+0x6c>
	 {
	  temp = ((temp*10) + (num%10));
	  num /= 10;
	 }
	 
	 while(temp > 1 )
     a7c:	62 30       	cpi	r22, 0x02	; 2
     a7e:	71 05       	cpc	r23, r1
     a80:	81 05       	cpc	r24, r1
     a82:	91 05       	cpc	r25, r1
     a84:	e4 f0       	brlt	.+56     	; 0xabe <LCD_WriteInteger+0xfc>
	 {
	  LCD_WriteChar(((temp%10)+48));
     a86:	0f 2e       	mov	r0, r31
     a88:	fa e0       	ldi	r31, 0x0A	; 10
     a8a:	8f 2e       	mov	r8, r31
     a8c:	91 2c       	mov	r9, r1
     a8e:	a1 2c       	mov	r10, r1
     a90:	b1 2c       	mov	r11, r1
     a92:	f0 2d       	mov	r31, r0
     a94:	a5 01       	movw	r20, r10
     a96:	94 01       	movw	r18, r8
     a98:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <__divmodsi4>
     a9c:	c2 2e       	mov	r12, r18
     a9e:	d3 2e       	mov	r13, r19
     aa0:	e4 2e       	mov	r14, r20
     aa2:	f5 2e       	mov	r15, r21
     aa4:	80 e3       	ldi	r24, 0x30	; 48
     aa6:	86 0f       	add	r24, r22
     aa8:	0e 94 67 04 	call	0x8ce	; 0x8ce <LCD_WriteChar>
	  temp /= 10;
     aac:	6c 2d       	mov	r22, r12
     aae:	7d 2d       	mov	r23, r13
     ab0:	8e 2d       	mov	r24, r14
     ab2:	9f 2d       	mov	r25, r15
	 {
	  temp = ((temp*10) + (num%10));
	  num /= 10;
	 }
	 
	 while(temp > 1 )
     ab4:	62 30       	cpi	r22, 0x02	; 2
     ab6:	71 05       	cpc	r23, r1
     ab8:	81 05       	cpc	r24, r1
     aba:	91 05       	cpc	r25, r1
     abc:	5c f7       	brge	.-42     	; 0xa94 <LCD_WriteInteger+0xd2>
     abe:	8f e1       	ldi	r24, 0x1F	; 31
     ac0:	9e e4       	ldi	r25, 0x4E	; 78
     ac2:	01 97       	sbiw	r24, 0x01	; 1
     ac4:	f1 f7       	brne	.-4      	; 0xac2 <LCD_WriteInteger+0x100>
     ac6:	00 c0       	rjmp	.+0      	; 0xac8 <LCD_WriteInteger+0x106>
     ac8:	00 00       	nop
	 {
	  LCD_WriteChar(((temp%10)+48));
	  temp /= 10;
	 }
	 _delay_ms(5);
}
     aca:	ff 90       	pop	r15
     acc:	ef 90       	pop	r14
     ace:	df 90       	pop	r13
     ad0:	cf 90       	pop	r12
     ad2:	bf 90       	pop	r11
     ad4:	af 90       	pop	r10
     ad6:	9f 90       	pop	r9
     ad8:	8f 90       	pop	r8
     ada:	7f 90       	pop	r7
     adc:	6f 90       	pop	r6
     ade:	5f 90       	pop	r5
     ae0:	4f 90       	pop	r4
     ae2:	08 95       	ret

00000ae4 <LCD_GoTo>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void LCD_GoTo(uint8 Row, uint8 Column)
{
     ae4:	cf 93       	push	r28
     ae6:	df 93       	push	r29
     ae8:	00 d0       	rcall	.+0      	; 0xaea <LCD_GoTo+0x6>
     aea:	cd b7       	in	r28, 0x3d	; 61
     aec:	de b7       	in	r29, 0x3e	; 62
	uint8 LCD_Loc[2]={0X80 , 0XC0};	
     aee:	90 e8       	ldi	r25, 0x80	; 128
     af0:	99 83       	std	Y+1, r25	; 0x01
     af2:	90 ec       	ldi	r25, 0xC0	; 192
     af4:	9a 83       	std	Y+2, r25	; 0x02
	LCD_WriteCommand(LCD_Loc[Row] + Column);
     af6:	fe 01       	movw	r30, r28
     af8:	e8 0f       	add	r30, r24
     afa:	f1 1d       	adc	r31, r1
     afc:	81 81       	ldd	r24, Z+1	; 0x01
     afe:	86 0f       	add	r24, r22
     b00:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_WriteCommand>
     b04:	8f e1       	ldi	r24, 0x1F	; 31
     b06:	9e e4       	ldi	r25, 0x4E	; 78
     b08:	01 97       	sbiw	r24, 0x01	; 1
     b0a:	f1 f7       	brne	.-4      	; 0xb08 <LCD_GoTo+0x24>
     b0c:	00 c0       	rjmp	.+0      	; 0xb0e <LCD_GoTo+0x2a>
     b0e:	00 00       	nop
	_delay_ms(5);
}
     b10:	0f 90       	pop	r0
     b12:	0f 90       	pop	r0
     b14:	df 91       	pop	r29
     b16:	cf 91       	pop	r28
     b18:	08 95       	ret

00000b1a <LCD_Clear>:
*                                    E_NOT_OK
*******************************************************************************/
void LCD_Clear(void)
{
	//command to clear LCD
	LCD_WriteCommand(0X01);
     b1a:	81 e0       	ldi	r24, 0x01	; 1
     b1c:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_WriteCommand>
     b20:	8f e1       	ldi	r24, 0x1F	; 31
     b22:	9e e4       	ldi	r25, 0x4E	; 78
     b24:	01 97       	sbiw	r24, 0x01	; 1
     b26:	f1 f7       	brne	.-4      	; 0xb24 <LCD_Clear+0xa>
     b28:	00 c0       	rjmp	.+0      	; 0xb2a <LCD_Clear+0x10>
     b2a:	00 00       	nop
     b2c:	08 95       	ret

00000b2e <DIO_WriteChannel>:
*                                    E_NOT_OK
*******************************************************************************/
void DIO_WriteChannel (uint8 Pin_Order, PIN_VAL_e Pin_Val)
{
	uint8 PORT =0, PIN=0 ;
	PORT= Pin_Order / NUMBER_OF_PORT_PINS;
     b2e:	98 2f       	mov	r25, r24
     b30:	96 95       	lsr	r25
     b32:	96 95       	lsr	r25
     b34:	96 95       	lsr	r25
	PIN=  Pin_Order  % NUMBER_OF_PORT_PINS;
     b36:	87 70       	andi	r24, 0x07	; 7
	
	switch (Pin_Val)
     b38:	66 23       	and	r22, r22
     b3a:	09 f4       	brne	.+2      	; 0xb3e <DIO_WriteChannel+0x10>
     b3c:	3f c0       	rjmp	.+126    	; 0xbbc <DIO_WriteChannel+0x8e>
     b3e:	61 30       	cpi	r22, 0x01	; 1
     b40:	09 f0       	breq	.+2      	; 0xb44 <DIO_WriteChannel+0x16>
     b42:	7b c0       	rjmp	.+246    	; 0xc3a <DIO_WriteChannel+0x10c>
	{
		case PIN_HIGH :
		switch(PORT)
     b44:	91 30       	cpi	r25, 0x01	; 1
     b46:	99 f0       	breq	.+38     	; 0xb6e <DIO_WriteChannel+0x40>
     b48:	28 f0       	brcs	.+10     	; 0xb54 <DIO_WriteChannel+0x26>
     b4a:	92 30       	cpi	r25, 0x02	; 2
     b4c:	e9 f0       	breq	.+58     	; 0xb88 <DIO_WriteChannel+0x5a>
     b4e:	93 30       	cpi	r25, 0x03	; 3
     b50:	41 f1       	breq	.+80     	; 0xba2 <DIO_WriteChannel+0x74>
     b52:	08 95       	ret
		{
			case 0:
			SET_BIT (PORTA , PIN);
     b54:	4b b3       	in	r20, 0x1b	; 27
     b56:	21 e0       	ldi	r18, 0x01	; 1
     b58:	30 e0       	ldi	r19, 0x00	; 0
     b5a:	b9 01       	movw	r22, r18
     b5c:	02 c0       	rjmp	.+4      	; 0xb62 <DIO_WriteChannel+0x34>
     b5e:	66 0f       	add	r22, r22
     b60:	77 1f       	adc	r23, r23
     b62:	8a 95       	dec	r24
     b64:	e2 f7       	brpl	.-8      	; 0xb5e <DIO_WriteChannel+0x30>
     b66:	cb 01       	movw	r24, r22
     b68:	84 2b       	or	r24, r20
     b6a:	8b bb       	out	0x1b, r24	; 27
			break;
     b6c:	08 95       	ret
			case 1:
			SET_BIT (PORTB , PIN);
     b6e:	48 b3       	in	r20, 0x18	; 24
     b70:	21 e0       	ldi	r18, 0x01	; 1
     b72:	30 e0       	ldi	r19, 0x00	; 0
     b74:	b9 01       	movw	r22, r18
     b76:	02 c0       	rjmp	.+4      	; 0xb7c <DIO_WriteChannel+0x4e>
     b78:	66 0f       	add	r22, r22
     b7a:	77 1f       	adc	r23, r23
     b7c:	8a 95       	dec	r24
     b7e:	e2 f7       	brpl	.-8      	; 0xb78 <DIO_WriteChannel+0x4a>
     b80:	cb 01       	movw	r24, r22
     b82:	84 2b       	or	r24, r20
     b84:	88 bb       	out	0x18, r24	; 24
			break;
     b86:	08 95       	ret
			case 2:
			SET_BIT (PORTC , PIN);
     b88:	45 b3       	in	r20, 0x15	; 21
     b8a:	21 e0       	ldi	r18, 0x01	; 1
     b8c:	30 e0       	ldi	r19, 0x00	; 0
     b8e:	b9 01       	movw	r22, r18
     b90:	02 c0       	rjmp	.+4      	; 0xb96 <DIO_WriteChannel+0x68>
     b92:	66 0f       	add	r22, r22
     b94:	77 1f       	adc	r23, r23
     b96:	8a 95       	dec	r24
     b98:	e2 f7       	brpl	.-8      	; 0xb92 <DIO_WriteChannel+0x64>
     b9a:	cb 01       	movw	r24, r22
     b9c:	84 2b       	or	r24, r20
     b9e:	85 bb       	out	0x15, r24	; 21
			break;
     ba0:	08 95       	ret
			case 3:
			SET_BIT (PORTD , PIN);
     ba2:	42 b3       	in	r20, 0x12	; 18
     ba4:	21 e0       	ldi	r18, 0x01	; 1
     ba6:	30 e0       	ldi	r19, 0x00	; 0
     ba8:	b9 01       	movw	r22, r18
     baa:	02 c0       	rjmp	.+4      	; 0xbb0 <DIO_WriteChannel+0x82>
     bac:	66 0f       	add	r22, r22
     bae:	77 1f       	adc	r23, r23
     bb0:	8a 95       	dec	r24
     bb2:	e2 f7       	brpl	.-8      	; 0xbac <DIO_WriteChannel+0x7e>
     bb4:	cb 01       	movw	r24, r22
     bb6:	84 2b       	or	r24, r20
     bb8:	82 bb       	out	0x12, r24	; 18
			break;
     bba:	08 95       	ret
			break;
		}
		break;
		
		case PIN_LOW :
		switch(PORT)
     bbc:	91 30       	cpi	r25, 0x01	; 1
     bbe:	a1 f0       	breq	.+40     	; 0xbe8 <DIO_WriteChannel+0xba>
     bc0:	28 f0       	brcs	.+10     	; 0xbcc <DIO_WriteChannel+0x9e>
     bc2:	92 30       	cpi	r25, 0x02	; 2
     bc4:	f9 f0       	breq	.+62     	; 0xc04 <DIO_WriteChannel+0xd6>
     bc6:	93 30       	cpi	r25, 0x03	; 3
     bc8:	59 f1       	breq	.+86     	; 0xc20 <DIO_WriteChannel+0xf2>
     bca:	08 95       	ret
		{
			case 0:
			CLR_BIT (PORTA , PIN);
     bcc:	4b b3       	in	r20, 0x1b	; 27
     bce:	21 e0       	ldi	r18, 0x01	; 1
     bd0:	30 e0       	ldi	r19, 0x00	; 0
     bd2:	b9 01       	movw	r22, r18
     bd4:	02 c0       	rjmp	.+4      	; 0xbda <DIO_WriteChannel+0xac>
     bd6:	66 0f       	add	r22, r22
     bd8:	77 1f       	adc	r23, r23
     bda:	8a 95       	dec	r24
     bdc:	e2 f7       	brpl	.-8      	; 0xbd6 <DIO_WriteChannel+0xa8>
     bde:	cb 01       	movw	r24, r22
     be0:	80 95       	com	r24
     be2:	84 23       	and	r24, r20
     be4:	8b bb       	out	0x1b, r24	; 27
			break;
     be6:	08 95       	ret
			case 1:
			CLR_BIT (PORTB , PIN);
     be8:	48 b3       	in	r20, 0x18	; 24
     bea:	21 e0       	ldi	r18, 0x01	; 1
     bec:	30 e0       	ldi	r19, 0x00	; 0
     bee:	b9 01       	movw	r22, r18
     bf0:	02 c0       	rjmp	.+4      	; 0xbf6 <DIO_WriteChannel+0xc8>
     bf2:	66 0f       	add	r22, r22
     bf4:	77 1f       	adc	r23, r23
     bf6:	8a 95       	dec	r24
     bf8:	e2 f7       	brpl	.-8      	; 0xbf2 <DIO_WriteChannel+0xc4>
     bfa:	cb 01       	movw	r24, r22
     bfc:	80 95       	com	r24
     bfe:	84 23       	and	r24, r20
     c00:	88 bb       	out	0x18, r24	; 24
			break;
     c02:	08 95       	ret
			case 2:
			CLR_BIT (PORTC , PIN);
     c04:	45 b3       	in	r20, 0x15	; 21
     c06:	21 e0       	ldi	r18, 0x01	; 1
     c08:	30 e0       	ldi	r19, 0x00	; 0
     c0a:	b9 01       	movw	r22, r18
     c0c:	02 c0       	rjmp	.+4      	; 0xc12 <DIO_WriteChannel+0xe4>
     c0e:	66 0f       	add	r22, r22
     c10:	77 1f       	adc	r23, r23
     c12:	8a 95       	dec	r24
     c14:	e2 f7       	brpl	.-8      	; 0xc0e <DIO_WriteChannel+0xe0>
     c16:	cb 01       	movw	r24, r22
     c18:	80 95       	com	r24
     c1a:	84 23       	and	r24, r20
     c1c:	85 bb       	out	0x15, r24	; 21
			break;
     c1e:	08 95       	ret
			case 3:
			CLR_BIT (PORTD , PIN);
     c20:	42 b3       	in	r20, 0x12	; 18
     c22:	21 e0       	ldi	r18, 0x01	; 1
     c24:	30 e0       	ldi	r19, 0x00	; 0
     c26:	b9 01       	movw	r22, r18
     c28:	02 c0       	rjmp	.+4      	; 0xc2e <DIO_WriteChannel+0x100>
     c2a:	66 0f       	add	r22, r22
     c2c:	77 1f       	adc	r23, r23
     c2e:	8a 95       	dec	r24
     c30:	e2 f7       	brpl	.-8      	; 0xc2a <DIO_WriteChannel+0xfc>
     c32:	cb 01       	movw	r24, r22
     c34:	80 95       	com	r24
     c36:	84 23       	and	r24, r20
     c38:	82 bb       	out	0x12, r24	; 18
     c3a:	08 95       	ret

00000c3c <DIO_ReadChannel>:

PIN_VAL_e DIO_ReadChannel (uint8 Pin_Order)
{
		uint8 PORT =0, PIN=0, OUTPUT_Val=0 ;
		PORT= Pin_Order / NUMBER_OF_PORT_PINS;
		PIN=  Pin_Order  % NUMBER_OF_PORT_PINS;
     c3c:	28 2f       	mov	r18, r24
     c3e:	27 70       	andi	r18, 0x07	; 7
		
		switch (PORT)
     c40:	86 95       	lsr	r24
     c42:	86 95       	lsr	r24
     c44:	86 95       	lsr	r24
     c46:	81 30       	cpi	r24, 0x01	; 1
     c48:	79 f0       	breq	.+30     	; 0xc68 <DIO_ReadChannel+0x2c>
     c4a:	28 f0       	brcs	.+10     	; 0xc56 <DIO_ReadChannel+0x1a>
     c4c:	82 30       	cpi	r24, 0x02	; 2
     c4e:	a9 f0       	breq	.+42     	; 0xc7a <DIO_ReadChannel+0x3e>
     c50:	83 30       	cpi	r24, 0x03	; 3
     c52:	e1 f0       	breq	.+56     	; 0xc8c <DIO_ReadChannel+0x50>
     c54:	24 c0       	rjmp	.+72     	; 0xc9e <DIO_ReadChannel+0x62>
		{
			case 0:
			OUTPUT_Val= GET_BIT (PINA , PIN);
     c56:	89 b3       	in	r24, 0x19	; 25
     c58:	90 e0       	ldi	r25, 0x00	; 0
     c5a:	02 c0       	rjmp	.+4      	; 0xc60 <DIO_ReadChannel+0x24>
     c5c:	95 95       	asr	r25
     c5e:	87 95       	ror	r24
     c60:	2a 95       	dec	r18
     c62:	e2 f7       	brpl	.-8      	; 0xc5c <DIO_ReadChannel+0x20>
     c64:	81 70       	andi	r24, 0x01	; 1
			break;
     c66:	08 95       	ret
			case 1:
			OUTPUT_Val= GET_BIT (PINB , PIN);
     c68:	86 b3       	in	r24, 0x16	; 22
     c6a:	90 e0       	ldi	r25, 0x00	; 0
     c6c:	02 c0       	rjmp	.+4      	; 0xc72 <DIO_ReadChannel+0x36>
     c6e:	95 95       	asr	r25
     c70:	87 95       	ror	r24
     c72:	2a 95       	dec	r18
     c74:	e2 f7       	brpl	.-8      	; 0xc6e <DIO_ReadChannel+0x32>
     c76:	81 70       	andi	r24, 0x01	; 1
			break;
     c78:	08 95       	ret
			case 2:
			OUTPUT_Val= GET_BIT (PINC , PIN);
     c7a:	83 b3       	in	r24, 0x13	; 19
     c7c:	90 e0       	ldi	r25, 0x00	; 0
     c7e:	02 c0       	rjmp	.+4      	; 0xc84 <DIO_ReadChannel+0x48>
     c80:	95 95       	asr	r25
     c82:	87 95       	ror	r24
     c84:	2a 95       	dec	r18
     c86:	e2 f7       	brpl	.-8      	; 0xc80 <DIO_ReadChannel+0x44>
     c88:	81 70       	andi	r24, 0x01	; 1
			break;
     c8a:	08 95       	ret
			case 3:
			OUTPUT_Val= GET_BIT (PIND , PIN);
     c8c:	80 b3       	in	r24, 0x10	; 16
     c8e:	90 e0       	ldi	r25, 0x00	; 0
     c90:	02 c0       	rjmp	.+4      	; 0xc96 <DIO_ReadChannel+0x5a>
     c92:	95 95       	asr	r25
     c94:	87 95       	ror	r24
     c96:	2a 95       	dec	r18
     c98:	e2 f7       	brpl	.-8      	; 0xc92 <DIO_ReadChannel+0x56>
     c9a:	81 70       	andi	r24, 0x01	; 1
			break;
     c9c:	08 95       	ret
*                                    E_NOT_OK
*******************************************************************************/

PIN_VAL_e DIO_ReadChannel (uint8 Pin_Order)
{
		uint8 PORT =0, PIN=0, OUTPUT_Val=0 ;
     c9e:	80 e0       	ldi	r24, 0x00	; 0
			break;
			default:
			break;
		}
		return OUTPUT_Val;
}
     ca0:	08 95       	ret

00000ca2 <PORT_Init>:
 */ 

#include "PORT_Core.h"

void PORT_Init(void)
{
     ca2:	e0 e6       	ldi	r30, 0x60	; 96
     ca4:	f0 e0       	ldi	r31, 0x00	; 0
     ca6:	44 e8       	ldi	r20, 0x84	; 132
     ca8:	50 e0       	ldi	r21, 0x00	; 0
					case PORT_A:
					     CLR_BIT(DDRA , PIN);
					break;
					
					case PORT_B:
					     CLR_BIT(DDRB , PIN);
     caa:	61 e0       	ldi	r22, 0x01	; 1
     cac:	70 e0       	ldi	r23, 0x00	; 0
void PORT_Init(void)
{
	uint8 cntr=0 , PORT=0 , PIN =0 , DIR= 0;
	for(cntr = 0 ; cntr < DEFINED_PINS ; cntr++ )
	{
		PORT = PORT_Initialization[cntr].PIN_NUM/NUMBER_OF_PORT_PINS;
     cae:	80 81       	ld	r24, Z
     cb0:	98 2f       	mov	r25, r24
     cb2:	96 95       	lsr	r25
     cb4:	96 95       	lsr	r25
     cb6:	96 95       	lsr	r25
		PIN =  PORT_Initialization[cntr].PIN_NUM%NUMBER_OF_PORT_PINS;
     cb8:	87 70       	andi	r24, 0x07	; 7
		DIR =  PORT_Initialization[cntr].DIR;
		
		switch (DIR)
     cba:	21 81       	ldd	r18, Z+1	; 0x01
     cbc:	22 23       	and	r18, r18
     cbe:	19 f0       	breq	.+6      	; 0xcc6 <PORT_Init+0x24>
     cc0:	21 30       	cpi	r18, 0x01	; 1
     cc2:	c9 f1       	breq	.+114    	; 0xd36 <PORT_Init+0x94>
     cc4:	6b c0       	rjmp	.+214    	; 0xd9c <PORT_Init+0xfa>
		{
			case PIN_DIR_INPUT :
			    switch (PORT)
     cc6:	91 30       	cpi	r25, 0x01	; 1
     cc8:	91 f0       	breq	.+36     	; 0xcee <PORT_Init+0x4c>
     cca:	28 f0       	brcs	.+10     	; 0xcd6 <PORT_Init+0x34>
     ccc:	92 30       	cpi	r25, 0x02	; 2
     cce:	d9 f0       	breq	.+54     	; 0xd06 <PORT_Init+0x64>
     cd0:	93 30       	cpi	r25, 0x03	; 3
     cd2:	29 f1       	breq	.+74     	; 0xd1e <PORT_Init+0x7c>
     cd4:	63 c0       	rjmp	.+198    	; 0xd9c <PORT_Init+0xfa>
				{
					case PORT_A:
					     CLR_BIT(DDRA , PIN);
     cd6:	9a b3       	in	r25, 0x1a	; 26
     cd8:	9b 01       	movw	r18, r22
     cda:	02 c0       	rjmp	.+4      	; 0xce0 <PORT_Init+0x3e>
     cdc:	22 0f       	add	r18, r18
     cde:	33 1f       	adc	r19, r19
     ce0:	8a 95       	dec	r24
     ce2:	e2 f7       	brpl	.-8      	; 0xcdc <PORT_Init+0x3a>
     ce4:	82 2f       	mov	r24, r18
     ce6:	80 95       	com	r24
     ce8:	89 23       	and	r24, r25
     cea:	8a bb       	out	0x1a, r24	; 26
					break;
     cec:	57 c0       	rjmp	.+174    	; 0xd9c <PORT_Init+0xfa>
					
					case PORT_B:
					     CLR_BIT(DDRB , PIN);
     cee:	97 b3       	in	r25, 0x17	; 23
     cf0:	9b 01       	movw	r18, r22
     cf2:	02 c0       	rjmp	.+4      	; 0xcf8 <PORT_Init+0x56>
     cf4:	22 0f       	add	r18, r18
     cf6:	33 1f       	adc	r19, r19
     cf8:	8a 95       	dec	r24
     cfa:	e2 f7       	brpl	.-8      	; 0xcf4 <PORT_Init+0x52>
     cfc:	82 2f       	mov	r24, r18
     cfe:	80 95       	com	r24
     d00:	89 23       	and	r24, r25
     d02:	87 bb       	out	0x17, r24	; 23
					break;
     d04:	4b c0       	rjmp	.+150    	; 0xd9c <PORT_Init+0xfa>
					
					case PORT_C:
					     CLR_BIT(DDRC , PIN);
     d06:	94 b3       	in	r25, 0x14	; 20
     d08:	9b 01       	movw	r18, r22
     d0a:	02 c0       	rjmp	.+4      	; 0xd10 <PORT_Init+0x6e>
     d0c:	22 0f       	add	r18, r18
     d0e:	33 1f       	adc	r19, r19
     d10:	8a 95       	dec	r24
     d12:	e2 f7       	brpl	.-8      	; 0xd0c <PORT_Init+0x6a>
     d14:	82 2f       	mov	r24, r18
     d16:	80 95       	com	r24
     d18:	89 23       	and	r24, r25
     d1a:	84 bb       	out	0x14, r24	; 20
					break;
     d1c:	3f c0       	rjmp	.+126    	; 0xd9c <PORT_Init+0xfa>
					
					case PORT_D:
					     CLR_BIT(DDRD , PIN);
     d1e:	91 b3       	in	r25, 0x11	; 17
     d20:	9b 01       	movw	r18, r22
     d22:	02 c0       	rjmp	.+4      	; 0xd28 <PORT_Init+0x86>
     d24:	22 0f       	add	r18, r18
     d26:	33 1f       	adc	r19, r19
     d28:	8a 95       	dec	r24
     d2a:	e2 f7       	brpl	.-8      	; 0xd24 <PORT_Init+0x82>
     d2c:	82 2f       	mov	r24, r18
     d2e:	80 95       	com	r24
     d30:	89 23       	and	r24, r25
     d32:	81 bb       	out	0x11, r24	; 17
					break;
     d34:	33 c0       	rjmp	.+102    	; 0xd9c <PORT_Init+0xfa>
					break;
				}
			break;
			
			case PIN_DIR_OUTPUT :
			    switch (PORT)
     d36:	91 30       	cpi	r25, 0x01	; 1
     d38:	89 f0       	breq	.+34     	; 0xd5c <PORT_Init+0xba>
     d3a:	28 f0       	brcs	.+10     	; 0xd46 <PORT_Init+0xa4>
     d3c:	92 30       	cpi	r25, 0x02	; 2
     d3e:	c9 f0       	breq	.+50     	; 0xd72 <PORT_Init+0xd0>
     d40:	93 30       	cpi	r25, 0x03	; 3
     d42:	11 f1       	breq	.+68     	; 0xd88 <PORT_Init+0xe6>
     d44:	2b c0       	rjmp	.+86     	; 0xd9c <PORT_Init+0xfa>
			    {
				    case PORT_A:
				    SET_BIT(DDRA , PIN);
     d46:	2a b3       	in	r18, 0x1a	; 26
     d48:	db 01       	movw	r26, r22
     d4a:	02 c0       	rjmp	.+4      	; 0xd50 <PORT_Init+0xae>
     d4c:	aa 0f       	add	r26, r26
     d4e:	bb 1f       	adc	r27, r27
     d50:	8a 95       	dec	r24
     d52:	e2 f7       	brpl	.-8      	; 0xd4c <PORT_Init+0xaa>
     d54:	cd 01       	movw	r24, r26
     d56:	82 2b       	or	r24, r18
     d58:	8a bb       	out	0x1a, r24	; 26
				    break;
     d5a:	20 c0       	rjmp	.+64     	; 0xd9c <PORT_Init+0xfa>
				    
				    case PORT_B:
				    SET_BIT(DDRB , PIN);
     d5c:	27 b3       	in	r18, 0x17	; 23
     d5e:	db 01       	movw	r26, r22
     d60:	02 c0       	rjmp	.+4      	; 0xd66 <PORT_Init+0xc4>
     d62:	aa 0f       	add	r26, r26
     d64:	bb 1f       	adc	r27, r27
     d66:	8a 95       	dec	r24
     d68:	e2 f7       	brpl	.-8      	; 0xd62 <PORT_Init+0xc0>
     d6a:	cd 01       	movw	r24, r26
     d6c:	82 2b       	or	r24, r18
     d6e:	87 bb       	out	0x17, r24	; 23
				    break;
     d70:	15 c0       	rjmp	.+42     	; 0xd9c <PORT_Init+0xfa>
				    
				    case PORT_C:
				    SET_BIT(DDRC , PIN);
     d72:	24 b3       	in	r18, 0x14	; 20
     d74:	db 01       	movw	r26, r22
     d76:	02 c0       	rjmp	.+4      	; 0xd7c <PORT_Init+0xda>
     d78:	aa 0f       	add	r26, r26
     d7a:	bb 1f       	adc	r27, r27
     d7c:	8a 95       	dec	r24
     d7e:	e2 f7       	brpl	.-8      	; 0xd78 <PORT_Init+0xd6>
     d80:	cd 01       	movw	r24, r26
     d82:	82 2b       	or	r24, r18
     d84:	84 bb       	out	0x14, r24	; 20
				    break;
     d86:	0a c0       	rjmp	.+20     	; 0xd9c <PORT_Init+0xfa>
				    
				    case PORT_D:
				    SET_BIT(DDRD , PIN);
     d88:	21 b3       	in	r18, 0x11	; 17
     d8a:	db 01       	movw	r26, r22
     d8c:	02 c0       	rjmp	.+4      	; 0xd92 <PORT_Init+0xf0>
     d8e:	aa 0f       	add	r26, r26
     d90:	bb 1f       	adc	r27, r27
     d92:	8a 95       	dec	r24
     d94:	e2 f7       	brpl	.-8      	; 0xd8e <PORT_Init+0xec>
     d96:	cd 01       	movw	r24, r26
     d98:	82 2b       	or	r24, r18
     d9a:	81 bb       	out	0x11, r24	; 17
     d9c:	32 96       	adiw	r30, 0x02	; 2
#include "PORT_Core.h"

void PORT_Init(void)
{
	uint8 cntr=0 , PORT=0 , PIN =0 , DIR= 0;
	for(cntr = 0 ; cntr < DEFINED_PINS ; cntr++ )
     d9e:	e4 17       	cp	r30, r20
     da0:	f5 07       	cpc	r31, r21
     da2:	09 f0       	breq	.+2      	; 0xda6 <PORT_Init+0x104>
     da4:	84 cf       	rjmp	.-248    	; 0xcae <PORT_Init+0xc>
			
			default:
			break;
		}
	}
     da6:	08 95       	ret

00000da8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     da8:	cf 93       	push	r28
     daa:	df 93       	push	r29
     dac:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     dae:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     db2:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <pucAlignedHeap.2084>
     db6:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <pucAlignedHeap.2084+0x1>
     dba:	89 2b       	or	r24, r25
     dbc:	31 f4       	brne	.+12     	; 0xdca <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     dbe:	8f e3       	ldi	r24, 0x3F	; 63
     dc0:	91 e0       	ldi	r25, 0x01	; 1
     dc2:	90 93 3b 01 	sts	0x013B, r25	; 0x80013b <pucAlignedHeap.2084+0x1>
     dc6:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <pucAlignedHeap.2084>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     dca:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <xNextFreeByte>
     dce:	30 91 3d 01 	lds	r19, 0x013D	; 0x80013d <xNextFreeByte+0x1>
     dd2:	c9 01       	movw	r24, r18
     dd4:	8c 0f       	add	r24, r28
     dd6:	9d 1f       	adc	r25, r29
     dd8:	8b 3d       	cpi	r24, 0xDB	; 219
     dda:	45 e0       	ldi	r20, 0x05	; 5
     ddc:	94 07       	cpc	r25, r20
     dde:	70 f4       	brcc	.+28     	; 0xdfc <pvPortMalloc+0x54>
     de0:	28 17       	cp	r18, r24
     de2:	39 07       	cpc	r19, r25
     de4:	70 f4       	brcc	.+28     	; 0xe02 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     de6:	c0 91 3a 01 	lds	r28, 0x013A	; 0x80013a <pucAlignedHeap.2084>
     dea:	d0 91 3b 01 	lds	r29, 0x013B	; 0x80013b <pucAlignedHeap.2084+0x1>
     dee:	c2 0f       	add	r28, r18
     df0:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     df2:	90 93 3d 01 	sts	0x013D, r25	; 0x80013d <xNextFreeByte+0x1>
     df6:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <xNextFreeByte>
     dfa:	05 c0       	rjmp	.+10     	; 0xe06 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     dfc:	c0 e0       	ldi	r28, 0x00	; 0
     dfe:	d0 e0       	ldi	r29, 0x00	; 0
     e00:	02 c0       	rjmp	.+4      	; 0xe06 <pvPortMalloc+0x5e>
     e02:	c0 e0       	ldi	r28, 0x00	; 0
     e04:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     e06:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     e0a:	ce 01       	movw	r24, r28
     e0c:	df 91       	pop	r29
     e0e:	cf 91       	pop	r28
     e10:	08 95       	ret

00000e12 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     e12:	08 95       	ret

00000e14 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     e14:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e16:	03 96       	adiw	r24, 0x03	; 3
     e18:	92 83       	std	Z+2, r25	; 0x02
     e1a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     e1c:	2f ef       	ldi	r18, 0xFF	; 255
     e1e:	3f ef       	ldi	r19, 0xFF	; 255
     e20:	34 83       	std	Z+4, r19	; 0x04
     e22:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e24:	96 83       	std	Z+6, r25	; 0x06
     e26:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e28:	90 87       	std	Z+8, r25	; 0x08
     e2a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     e2c:	10 82       	st	Z, r1
     e2e:	08 95       	ret

00000e30 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     e30:	fc 01       	movw	r30, r24
     e32:	11 86       	std	Z+9, r1	; 0x09
     e34:	10 86       	std	Z+8, r1	; 0x08
     e36:	08 95       	ret

00000e38 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     e38:	cf 93       	push	r28
     e3a:	df 93       	push	r29
     e3c:	9c 01       	movw	r18, r24
     e3e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     e40:	dc 01       	movw	r26, r24
     e42:	11 96       	adiw	r26, 0x01	; 1
     e44:	cd 91       	ld	r28, X+
     e46:	dc 91       	ld	r29, X
     e48:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     e4a:	d3 83       	std	Z+3, r29	; 0x03
     e4c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     e4e:	8c 81       	ldd	r24, Y+4	; 0x04
     e50:	9d 81       	ldd	r25, Y+5	; 0x05
     e52:	95 83       	std	Z+5, r25	; 0x05
     e54:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     e56:	8c 81       	ldd	r24, Y+4	; 0x04
     e58:	9d 81       	ldd	r25, Y+5	; 0x05
     e5a:	dc 01       	movw	r26, r24
     e5c:	13 96       	adiw	r26, 0x03	; 3
     e5e:	7c 93       	st	X, r23
     e60:	6e 93       	st	-X, r22
     e62:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     e64:	7d 83       	std	Y+5, r23	; 0x05
     e66:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     e68:	31 87       	std	Z+9, r19	; 0x09
     e6a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     e6c:	f9 01       	movw	r30, r18
     e6e:	80 81       	ld	r24, Z
     e70:	8f 5f       	subi	r24, 0xFF	; 255
     e72:	80 83       	st	Z, r24
}
     e74:	df 91       	pop	r29
     e76:	cf 91       	pop	r28
     e78:	08 95       	ret

00000e7a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     e7a:	cf 93       	push	r28
     e7c:	df 93       	push	r29
     e7e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     e80:	48 81       	ld	r20, Y
     e82:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     e84:	4f 3f       	cpi	r20, 0xFF	; 255
     e86:	2f ef       	ldi	r18, 0xFF	; 255
     e88:	52 07       	cpc	r21, r18
     e8a:	21 f4       	brne	.+8      	; 0xe94 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     e8c:	fc 01       	movw	r30, r24
     e8e:	a7 81       	ldd	r26, Z+7	; 0x07
     e90:	b0 85       	ldd	r27, Z+8	; 0x08
     e92:	0d c0       	rjmp	.+26     	; 0xeae <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     e94:	dc 01       	movw	r26, r24
     e96:	13 96       	adiw	r26, 0x03	; 3
     e98:	01 c0       	rjmp	.+2      	; 0xe9c <vListInsert+0x22>
     e9a:	df 01       	movw	r26, r30
     e9c:	12 96       	adiw	r26, 0x02	; 2
     e9e:	ed 91       	ld	r30, X+
     ea0:	fc 91       	ld	r31, X
     ea2:	13 97       	sbiw	r26, 0x03	; 3
     ea4:	20 81       	ld	r18, Z
     ea6:	31 81       	ldd	r19, Z+1	; 0x01
     ea8:	42 17       	cp	r20, r18
     eaa:	53 07       	cpc	r21, r19
     eac:	b0 f7       	brcc	.-20     	; 0xe9a <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     eae:	12 96       	adiw	r26, 0x02	; 2
     eb0:	ed 91       	ld	r30, X+
     eb2:	fc 91       	ld	r31, X
     eb4:	13 97       	sbiw	r26, 0x03	; 3
     eb6:	fb 83       	std	Y+3, r31	; 0x03
     eb8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     eba:	d5 83       	std	Z+5, r29	; 0x05
     ebc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     ebe:	bd 83       	std	Y+5, r27	; 0x05
     ec0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     ec2:	13 96       	adiw	r26, 0x03	; 3
     ec4:	dc 93       	st	X, r29
     ec6:	ce 93       	st	-X, r28
     ec8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     eca:	99 87       	std	Y+9, r25	; 0x09
     ecc:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     ece:	fc 01       	movw	r30, r24
     ed0:	20 81       	ld	r18, Z
     ed2:	2f 5f       	subi	r18, 0xFF	; 255
     ed4:	20 83       	st	Z, r18
}
     ed6:	df 91       	pop	r29
     ed8:	cf 91       	pop	r28
     eda:	08 95       	ret

00000edc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     edc:	cf 93       	push	r28
     ede:	df 93       	push	r29
     ee0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     ee2:	a0 85       	ldd	r26, Z+8	; 0x08
     ee4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     ee6:	c2 81       	ldd	r28, Z+2	; 0x02
     ee8:	d3 81       	ldd	r29, Z+3	; 0x03
     eea:	84 81       	ldd	r24, Z+4	; 0x04
     eec:	95 81       	ldd	r25, Z+5	; 0x05
     eee:	9d 83       	std	Y+5, r25	; 0x05
     ef0:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     ef2:	c4 81       	ldd	r28, Z+4	; 0x04
     ef4:	d5 81       	ldd	r29, Z+5	; 0x05
     ef6:	82 81       	ldd	r24, Z+2	; 0x02
     ef8:	93 81       	ldd	r25, Z+3	; 0x03
     efa:	9b 83       	std	Y+3, r25	; 0x03
     efc:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     efe:	11 96       	adiw	r26, 0x01	; 1
     f00:	8d 91       	ld	r24, X+
     f02:	9c 91       	ld	r25, X
     f04:	12 97       	sbiw	r26, 0x02	; 2
     f06:	e8 17       	cp	r30, r24
     f08:	f9 07       	cpc	r31, r25
     f0a:	31 f4       	brne	.+12     	; 0xf18 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     f0c:	84 81       	ldd	r24, Z+4	; 0x04
     f0e:	95 81       	ldd	r25, Z+5	; 0x05
     f10:	12 96       	adiw	r26, 0x02	; 2
     f12:	9c 93       	st	X, r25
     f14:	8e 93       	st	-X, r24
     f16:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     f18:	11 86       	std	Z+9, r1	; 0x09
     f1a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     f1c:	8c 91       	ld	r24, X
     f1e:	81 50       	subi	r24, 0x01	; 1
     f20:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     f22:	8c 91       	ld	r24, X
}
     f24:	df 91       	pop	r29
     f26:	cf 91       	pop	r28
     f28:	08 95       	ret

00000f2a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     f2a:	31 e1       	ldi	r19, 0x11	; 17
     f2c:	fc 01       	movw	r30, r24
     f2e:	30 83       	st	Z, r19
     f30:	31 97       	sbiw	r30, 0x01	; 1
     f32:	22 e2       	ldi	r18, 0x22	; 34
     f34:	20 83       	st	Z, r18
     f36:	31 97       	sbiw	r30, 0x01	; 1
     f38:	a3 e3       	ldi	r26, 0x33	; 51
     f3a:	a0 83       	st	Z, r26
     f3c:	31 97       	sbiw	r30, 0x01	; 1
     f3e:	60 83       	st	Z, r22
     f40:	31 97       	sbiw	r30, 0x01	; 1
     f42:	70 83       	st	Z, r23
     f44:	31 97       	sbiw	r30, 0x01	; 1
     f46:	10 82       	st	Z, r1
     f48:	31 97       	sbiw	r30, 0x01	; 1
     f4a:	60 e8       	ldi	r22, 0x80	; 128
     f4c:	60 83       	st	Z, r22
     f4e:	31 97       	sbiw	r30, 0x01	; 1
     f50:	10 82       	st	Z, r1
     f52:	31 97       	sbiw	r30, 0x01	; 1
     f54:	62 e0       	ldi	r22, 0x02	; 2
     f56:	60 83       	st	Z, r22
     f58:	31 97       	sbiw	r30, 0x01	; 1
     f5a:	63 e0       	ldi	r22, 0x03	; 3
     f5c:	60 83       	st	Z, r22
     f5e:	31 97       	sbiw	r30, 0x01	; 1
     f60:	64 e0       	ldi	r22, 0x04	; 4
     f62:	60 83       	st	Z, r22
     f64:	31 97       	sbiw	r30, 0x01	; 1
     f66:	65 e0       	ldi	r22, 0x05	; 5
     f68:	60 83       	st	Z, r22
     f6a:	31 97       	sbiw	r30, 0x01	; 1
     f6c:	66 e0       	ldi	r22, 0x06	; 6
     f6e:	60 83       	st	Z, r22
     f70:	31 97       	sbiw	r30, 0x01	; 1
     f72:	67 e0       	ldi	r22, 0x07	; 7
     f74:	60 83       	st	Z, r22
     f76:	31 97       	sbiw	r30, 0x01	; 1
     f78:	68 e0       	ldi	r22, 0x08	; 8
     f7a:	60 83       	st	Z, r22
     f7c:	31 97       	sbiw	r30, 0x01	; 1
     f7e:	69 e0       	ldi	r22, 0x09	; 9
     f80:	60 83       	st	Z, r22
     f82:	31 97       	sbiw	r30, 0x01	; 1
     f84:	60 e1       	ldi	r22, 0x10	; 16
     f86:	60 83       	st	Z, r22
     f88:	31 97       	sbiw	r30, 0x01	; 1
     f8a:	30 83       	st	Z, r19
     f8c:	31 97       	sbiw	r30, 0x01	; 1
     f8e:	32 e1       	ldi	r19, 0x12	; 18
     f90:	30 83       	st	Z, r19
     f92:	31 97       	sbiw	r30, 0x01	; 1
     f94:	33 e1       	ldi	r19, 0x13	; 19
     f96:	30 83       	st	Z, r19
     f98:	31 97       	sbiw	r30, 0x01	; 1
     f9a:	34 e1       	ldi	r19, 0x14	; 20
     f9c:	30 83       	st	Z, r19
     f9e:	31 97       	sbiw	r30, 0x01	; 1
     fa0:	35 e1       	ldi	r19, 0x15	; 21
     fa2:	30 83       	st	Z, r19
     fa4:	31 97       	sbiw	r30, 0x01	; 1
     fa6:	36 e1       	ldi	r19, 0x16	; 22
     fa8:	30 83       	st	Z, r19
     faa:	31 97       	sbiw	r30, 0x01	; 1
     fac:	37 e1       	ldi	r19, 0x17	; 23
     fae:	30 83       	st	Z, r19
     fb0:	31 97       	sbiw	r30, 0x01	; 1
     fb2:	38 e1       	ldi	r19, 0x18	; 24
     fb4:	30 83       	st	Z, r19
     fb6:	31 97       	sbiw	r30, 0x01	; 1
     fb8:	39 e1       	ldi	r19, 0x19	; 25
     fba:	30 83       	st	Z, r19
     fbc:	31 97       	sbiw	r30, 0x01	; 1
     fbe:	30 e2       	ldi	r19, 0x20	; 32
     fc0:	30 83       	st	Z, r19
     fc2:	31 97       	sbiw	r30, 0x01	; 1
     fc4:	31 e2       	ldi	r19, 0x21	; 33
     fc6:	30 83       	st	Z, r19
     fc8:	31 97       	sbiw	r30, 0x01	; 1
     fca:	20 83       	st	Z, r18
     fcc:	31 97       	sbiw	r30, 0x01	; 1
     fce:	23 e2       	ldi	r18, 0x23	; 35
     fd0:	20 83       	st	Z, r18
     fd2:	31 97       	sbiw	r30, 0x01	; 1
     fd4:	40 83       	st	Z, r20
     fd6:	31 97       	sbiw	r30, 0x01	; 1
     fd8:	50 83       	st	Z, r21
     fda:	31 97       	sbiw	r30, 0x01	; 1
     fdc:	26 e2       	ldi	r18, 0x26	; 38
     fde:	20 83       	st	Z, r18
     fe0:	31 97       	sbiw	r30, 0x01	; 1
     fe2:	27 e2       	ldi	r18, 0x27	; 39
     fe4:	20 83       	st	Z, r18
     fe6:	31 97       	sbiw	r30, 0x01	; 1
     fe8:	28 e2       	ldi	r18, 0x28	; 40
     fea:	20 83       	st	Z, r18
     fec:	31 97       	sbiw	r30, 0x01	; 1
     fee:	29 e2       	ldi	r18, 0x29	; 41
     ff0:	20 83       	st	Z, r18
     ff2:	31 97       	sbiw	r30, 0x01	; 1
     ff4:	20 e3       	ldi	r18, 0x30	; 48
     ff6:	20 83       	st	Z, r18
     ff8:	31 97       	sbiw	r30, 0x01	; 1
     ffa:	21 e3       	ldi	r18, 0x31	; 49
     ffc:	20 83       	st	Z, r18
     ffe:	86 97       	sbiw	r24, 0x26	; 38
    1000:	08 95       	ret

00001002 <xPortStartScheduler>:
    1002:	1b bc       	out	0x2b, r1	; 43
    1004:	89 ef       	ldi	r24, 0xF9	; 249
    1006:	8a bd       	out	0x2a, r24	; 42
    1008:	8b e0       	ldi	r24, 0x0B	; 11
    100a:	8e bd       	out	0x2e, r24	; 46
    100c:	89 b7       	in	r24, 0x39	; 57
    100e:	80 61       	ori	r24, 0x10	; 16
    1010:	89 bf       	out	0x39, r24	; 57
    1012:	a0 91 7e 07 	lds	r26, 0x077E	; 0x80077e <pxCurrentTCB>
    1016:	b0 91 7f 07 	lds	r27, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    101a:	cd 91       	ld	r28, X+
    101c:	cd bf       	out	0x3d, r28	; 61
    101e:	dd 91       	ld	r29, X+
    1020:	de bf       	out	0x3e, r29	; 62
    1022:	ff 91       	pop	r31
    1024:	ef 91       	pop	r30
    1026:	df 91       	pop	r29
    1028:	cf 91       	pop	r28
    102a:	bf 91       	pop	r27
    102c:	af 91       	pop	r26
    102e:	9f 91       	pop	r25
    1030:	8f 91       	pop	r24
    1032:	7f 91       	pop	r23
    1034:	6f 91       	pop	r22
    1036:	5f 91       	pop	r21
    1038:	4f 91       	pop	r20
    103a:	3f 91       	pop	r19
    103c:	2f 91       	pop	r18
    103e:	1f 91       	pop	r17
    1040:	0f 91       	pop	r16
    1042:	ff 90       	pop	r15
    1044:	ef 90       	pop	r14
    1046:	df 90       	pop	r13
    1048:	cf 90       	pop	r12
    104a:	bf 90       	pop	r11
    104c:	af 90       	pop	r10
    104e:	9f 90       	pop	r9
    1050:	8f 90       	pop	r8
    1052:	7f 90       	pop	r7
    1054:	6f 90       	pop	r6
    1056:	5f 90       	pop	r5
    1058:	4f 90       	pop	r4
    105a:	3f 90       	pop	r3
    105c:	2f 90       	pop	r2
    105e:	1f 90       	pop	r1
    1060:	0f 90       	pop	r0
    1062:	0f be       	out	0x3f, r0	; 63
    1064:	0f 90       	pop	r0
    1066:	08 95       	ret
    1068:	81 e0       	ldi	r24, 0x01	; 1
    106a:	08 95       	ret

0000106c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    106c:	0f 92       	push	r0
    106e:	0f b6       	in	r0, 0x3f	; 63
    1070:	f8 94       	cli
    1072:	0f 92       	push	r0
    1074:	1f 92       	push	r1
    1076:	11 24       	eor	r1, r1
    1078:	2f 92       	push	r2
    107a:	3f 92       	push	r3
    107c:	4f 92       	push	r4
    107e:	5f 92       	push	r5
    1080:	6f 92       	push	r6
    1082:	7f 92       	push	r7
    1084:	8f 92       	push	r8
    1086:	9f 92       	push	r9
    1088:	af 92       	push	r10
    108a:	bf 92       	push	r11
    108c:	cf 92       	push	r12
    108e:	df 92       	push	r13
    1090:	ef 92       	push	r14
    1092:	ff 92       	push	r15
    1094:	0f 93       	push	r16
    1096:	1f 93       	push	r17
    1098:	2f 93       	push	r18
    109a:	3f 93       	push	r19
    109c:	4f 93       	push	r20
    109e:	5f 93       	push	r21
    10a0:	6f 93       	push	r22
    10a2:	7f 93       	push	r23
    10a4:	8f 93       	push	r24
    10a6:	9f 93       	push	r25
    10a8:	af 93       	push	r26
    10aa:	bf 93       	push	r27
    10ac:	cf 93       	push	r28
    10ae:	df 93       	push	r29
    10b0:	ef 93       	push	r30
    10b2:	ff 93       	push	r31
    10b4:	a0 91 7e 07 	lds	r26, 0x077E	; 0x80077e <pxCurrentTCB>
    10b8:	b0 91 7f 07 	lds	r27, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    10bc:	0d b6       	in	r0, 0x3d	; 61
    10be:	0d 92       	st	X+, r0
    10c0:	0e b6       	in	r0, 0x3e	; 62
    10c2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    10c4:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    10c8:	a0 91 7e 07 	lds	r26, 0x077E	; 0x80077e <pxCurrentTCB>
    10cc:	b0 91 7f 07 	lds	r27, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    10d0:	cd 91       	ld	r28, X+
    10d2:	cd bf       	out	0x3d, r28	; 61
    10d4:	dd 91       	ld	r29, X+
    10d6:	de bf       	out	0x3e, r29	; 62
    10d8:	ff 91       	pop	r31
    10da:	ef 91       	pop	r30
    10dc:	df 91       	pop	r29
    10de:	cf 91       	pop	r28
    10e0:	bf 91       	pop	r27
    10e2:	af 91       	pop	r26
    10e4:	9f 91       	pop	r25
    10e6:	8f 91       	pop	r24
    10e8:	7f 91       	pop	r23
    10ea:	6f 91       	pop	r22
    10ec:	5f 91       	pop	r21
    10ee:	4f 91       	pop	r20
    10f0:	3f 91       	pop	r19
    10f2:	2f 91       	pop	r18
    10f4:	1f 91       	pop	r17
    10f6:	0f 91       	pop	r16
    10f8:	ff 90       	pop	r15
    10fa:	ef 90       	pop	r14
    10fc:	df 90       	pop	r13
    10fe:	cf 90       	pop	r12
    1100:	bf 90       	pop	r11
    1102:	af 90       	pop	r10
    1104:	9f 90       	pop	r9
    1106:	8f 90       	pop	r8
    1108:	7f 90       	pop	r7
    110a:	6f 90       	pop	r6
    110c:	5f 90       	pop	r5
    110e:	4f 90       	pop	r4
    1110:	3f 90       	pop	r3
    1112:	2f 90       	pop	r2
    1114:	1f 90       	pop	r1
    1116:	0f 90       	pop	r0
    1118:	0f be       	out	0x3f, r0	; 63
    111a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    111c:	08 95       	ret

0000111e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    111e:	0f 92       	push	r0
    1120:	0f b6       	in	r0, 0x3f	; 63
    1122:	f8 94       	cli
    1124:	0f 92       	push	r0
    1126:	1f 92       	push	r1
    1128:	11 24       	eor	r1, r1
    112a:	2f 92       	push	r2
    112c:	3f 92       	push	r3
    112e:	4f 92       	push	r4
    1130:	5f 92       	push	r5
    1132:	6f 92       	push	r6
    1134:	7f 92       	push	r7
    1136:	8f 92       	push	r8
    1138:	9f 92       	push	r9
    113a:	af 92       	push	r10
    113c:	bf 92       	push	r11
    113e:	cf 92       	push	r12
    1140:	df 92       	push	r13
    1142:	ef 92       	push	r14
    1144:	ff 92       	push	r15
    1146:	0f 93       	push	r16
    1148:	1f 93       	push	r17
    114a:	2f 93       	push	r18
    114c:	3f 93       	push	r19
    114e:	4f 93       	push	r20
    1150:	5f 93       	push	r21
    1152:	6f 93       	push	r22
    1154:	7f 93       	push	r23
    1156:	8f 93       	push	r24
    1158:	9f 93       	push	r25
    115a:	af 93       	push	r26
    115c:	bf 93       	push	r27
    115e:	cf 93       	push	r28
    1160:	df 93       	push	r29
    1162:	ef 93       	push	r30
    1164:	ff 93       	push	r31
    1166:	a0 91 7e 07 	lds	r26, 0x077E	; 0x80077e <pxCurrentTCB>
    116a:	b0 91 7f 07 	lds	r27, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    116e:	0d b6       	in	r0, 0x3d	; 61
    1170:	0d 92       	st	X+, r0
    1172:	0e b6       	in	r0, 0x3e	; 62
    1174:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1176:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <xTaskIncrementTick>
    117a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    117c:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1180:	a0 91 7e 07 	lds	r26, 0x077E	; 0x80077e <pxCurrentTCB>
    1184:	b0 91 7f 07 	lds	r27, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    1188:	cd 91       	ld	r28, X+
    118a:	cd bf       	out	0x3d, r28	; 61
    118c:	dd 91       	ld	r29, X+
    118e:	de bf       	out	0x3e, r29	; 62
    1190:	ff 91       	pop	r31
    1192:	ef 91       	pop	r30
    1194:	df 91       	pop	r29
    1196:	cf 91       	pop	r28
    1198:	bf 91       	pop	r27
    119a:	af 91       	pop	r26
    119c:	9f 91       	pop	r25
    119e:	8f 91       	pop	r24
    11a0:	7f 91       	pop	r23
    11a2:	6f 91       	pop	r22
    11a4:	5f 91       	pop	r21
    11a6:	4f 91       	pop	r20
    11a8:	3f 91       	pop	r19
    11aa:	2f 91       	pop	r18
    11ac:	1f 91       	pop	r17
    11ae:	0f 91       	pop	r16
    11b0:	ff 90       	pop	r15
    11b2:	ef 90       	pop	r14
    11b4:	df 90       	pop	r13
    11b6:	cf 90       	pop	r12
    11b8:	bf 90       	pop	r11
    11ba:	af 90       	pop	r10
    11bc:	9f 90       	pop	r9
    11be:	8f 90       	pop	r8
    11c0:	7f 90       	pop	r7
    11c2:	6f 90       	pop	r6
    11c4:	5f 90       	pop	r5
    11c6:	4f 90       	pop	r4
    11c8:	3f 90       	pop	r3
    11ca:	2f 90       	pop	r2
    11cc:	1f 90       	pop	r1
    11ce:	0f 90       	pop	r0
    11d0:	0f be       	out	0x3f, r0	; 63
    11d2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    11d4:	08 95       	ret

000011d6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    11d6:	0e 94 8f 08 	call	0x111e	; 0x111e <vPortYieldFromTick>
		asm volatile ( "reti" );
    11da:	18 95       	reti

000011dc <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    11dc:	0f b6       	in	r0, 0x3f	; 63
    11de:	f8 94       	cli
    11e0:	0f 92       	push	r0
    11e2:	fc 01       	movw	r30, r24
    11e4:	92 8d       	ldd	r25, Z+26	; 0x1a
    11e6:	0f 90       	pop	r0
    11e8:	0f be       	out	0x3f, r0	; 63
    11ea:	81 e0       	ldi	r24, 0x01	; 1
    11ec:	91 11       	cpse	r25, r1
    11ee:	80 e0       	ldi	r24, 0x00	; 0
    11f0:	08 95       	ret

000011f2 <prvCopyDataToQueue>:
    11f2:	0f 93       	push	r16
    11f4:	1f 93       	push	r17
    11f6:	cf 93       	push	r28
    11f8:	df 93       	push	r29
    11fa:	ec 01       	movw	r28, r24
    11fc:	04 2f       	mov	r16, r20
    11fe:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1200:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1202:	44 23       	and	r20, r20
    1204:	b9 f1       	breq	.+110    	; 0x1274 <prvCopyDataToQueue+0x82>
    1206:	01 11       	cpse	r16, r1
    1208:	16 c0       	rjmp	.+44     	; 0x1236 <prvCopyDataToQueue+0x44>
    120a:	50 e0       	ldi	r21, 0x00	; 0
    120c:	8a 81       	ldd	r24, Y+2	; 0x02
    120e:	9b 81       	ldd	r25, Y+3	; 0x03
    1210:	0e 94 4b 10 	call	0x2096	; 0x2096 <memcpy>
    1214:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1216:	8a 81       	ldd	r24, Y+2	; 0x02
    1218:	9b 81       	ldd	r25, Y+3	; 0x03
    121a:	82 0f       	add	r24, r18
    121c:	91 1d       	adc	r25, r1
    121e:	9b 83       	std	Y+3, r25	; 0x03
    1220:	8a 83       	std	Y+2, r24	; 0x02
    1222:	2c 81       	ldd	r18, Y+4	; 0x04
    1224:	3d 81       	ldd	r19, Y+5	; 0x05
    1226:	82 17       	cp	r24, r18
    1228:	93 07       	cpc	r25, r19
    122a:	20 f1       	brcs	.+72     	; 0x1274 <prvCopyDataToQueue+0x82>
    122c:	88 81       	ld	r24, Y
    122e:	99 81       	ldd	r25, Y+1	; 0x01
    1230:	9b 83       	std	Y+3, r25	; 0x03
    1232:	8a 83       	std	Y+2, r24	; 0x02
    1234:	1f c0       	rjmp	.+62     	; 0x1274 <prvCopyDataToQueue+0x82>
    1236:	50 e0       	ldi	r21, 0x00	; 0
    1238:	8e 81       	ldd	r24, Y+6	; 0x06
    123a:	9f 81       	ldd	r25, Y+7	; 0x07
    123c:	0e 94 4b 10 	call	0x2096	; 0x2096 <memcpy>
    1240:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1242:	90 e0       	ldi	r25, 0x00	; 0
    1244:	91 95       	neg	r25
    1246:	81 95       	neg	r24
    1248:	91 09       	sbc	r25, r1
    124a:	2e 81       	ldd	r18, Y+6	; 0x06
    124c:	3f 81       	ldd	r19, Y+7	; 0x07
    124e:	28 0f       	add	r18, r24
    1250:	39 1f       	adc	r19, r25
    1252:	3f 83       	std	Y+7, r19	; 0x07
    1254:	2e 83       	std	Y+6, r18	; 0x06
    1256:	48 81       	ld	r20, Y
    1258:	59 81       	ldd	r21, Y+1	; 0x01
    125a:	24 17       	cp	r18, r20
    125c:	35 07       	cpc	r19, r21
    125e:	30 f4       	brcc	.+12     	; 0x126c <prvCopyDataToQueue+0x7a>
    1260:	2c 81       	ldd	r18, Y+4	; 0x04
    1262:	3d 81       	ldd	r19, Y+5	; 0x05
    1264:	82 0f       	add	r24, r18
    1266:	93 1f       	adc	r25, r19
    1268:	9f 83       	std	Y+7, r25	; 0x07
    126a:	8e 83       	std	Y+6, r24	; 0x06
    126c:	02 30       	cpi	r16, 0x02	; 2
    126e:	11 f4       	brne	.+4      	; 0x1274 <prvCopyDataToQueue+0x82>
    1270:	11 11       	cpse	r17, r1
    1272:	11 50       	subi	r17, 0x01	; 1
    1274:	1f 5f       	subi	r17, 0xFF	; 255
    1276:	1a 8f       	std	Y+26, r17	; 0x1a
    1278:	80 e0       	ldi	r24, 0x00	; 0
    127a:	df 91       	pop	r29
    127c:	cf 91       	pop	r28
    127e:	1f 91       	pop	r17
    1280:	0f 91       	pop	r16
    1282:	08 95       	ret

00001284 <prvCopyDataFromQueue>:
    1284:	fc 01       	movw	r30, r24
    1286:	44 8d       	ldd	r20, Z+28	; 0x1c
    1288:	44 23       	and	r20, r20
    128a:	a9 f0       	breq	.+42     	; 0x12b6 <prvCopyDataFromQueue+0x32>
    128c:	50 e0       	ldi	r21, 0x00	; 0
    128e:	26 81       	ldd	r18, Z+6	; 0x06
    1290:	37 81       	ldd	r19, Z+7	; 0x07
    1292:	24 0f       	add	r18, r20
    1294:	35 1f       	adc	r19, r21
    1296:	37 83       	std	Z+7, r19	; 0x07
    1298:	26 83       	std	Z+6, r18	; 0x06
    129a:	84 81       	ldd	r24, Z+4	; 0x04
    129c:	95 81       	ldd	r25, Z+5	; 0x05
    129e:	28 17       	cp	r18, r24
    12a0:	39 07       	cpc	r19, r25
    12a2:	20 f0       	brcs	.+8      	; 0x12ac <prvCopyDataFromQueue+0x28>
    12a4:	80 81       	ld	r24, Z
    12a6:	91 81       	ldd	r25, Z+1	; 0x01
    12a8:	97 83       	std	Z+7, r25	; 0x07
    12aa:	86 83       	std	Z+6, r24	; 0x06
    12ac:	cb 01       	movw	r24, r22
    12ae:	66 81       	ldd	r22, Z+6	; 0x06
    12b0:	77 81       	ldd	r23, Z+7	; 0x07
    12b2:	0e 94 4b 10 	call	0x2096	; 0x2096 <memcpy>
    12b6:	08 95       	ret

000012b8 <prvUnlockQueue>:
    12b8:	ef 92       	push	r14
    12ba:	ff 92       	push	r15
    12bc:	0f 93       	push	r16
    12be:	1f 93       	push	r17
    12c0:	cf 93       	push	r28
    12c2:	8c 01       	movw	r16, r24
    12c4:	0f b6       	in	r0, 0x3f	; 63
    12c6:	f8 94       	cli
    12c8:	0f 92       	push	r0
    12ca:	fc 01       	movw	r30, r24
    12cc:	c6 8d       	ldd	r28, Z+30	; 0x1e
    12ce:	1c 16       	cp	r1, r28
    12d0:	ac f4       	brge	.+42     	; 0x12fc <prvUnlockQueue+0x44>
    12d2:	81 89       	ldd	r24, Z+17	; 0x11
    12d4:	81 11       	cpse	r24, r1
    12d6:	06 c0       	rjmp	.+12     	; 0x12e4 <prvUnlockQueue+0x2c>
    12d8:	11 c0       	rjmp	.+34     	; 0x12fc <prvUnlockQueue+0x44>
    12da:	f8 01       	movw	r30, r16
    12dc:	81 89       	ldd	r24, Z+17	; 0x11
    12de:	81 11       	cpse	r24, r1
    12e0:	05 c0       	rjmp	.+10     	; 0x12ec <prvUnlockQueue+0x34>
    12e2:	0c c0       	rjmp	.+24     	; 0x12fc <prvUnlockQueue+0x44>
    12e4:	78 01       	movw	r14, r16
    12e6:	f1 e1       	ldi	r31, 0x11	; 17
    12e8:	ef 0e       	add	r14, r31
    12ea:	f1 1c       	adc	r15, r1
    12ec:	c7 01       	movw	r24, r14
    12ee:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskRemoveFromEventList>
    12f2:	81 11       	cpse	r24, r1
    12f4:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vTaskMissedYield>
    12f8:	c1 50       	subi	r28, 0x01	; 1
    12fa:	79 f7       	brne	.-34     	; 0x12da <prvUnlockQueue+0x22>
    12fc:	8f ef       	ldi	r24, 0xFF	; 255
    12fe:	f8 01       	movw	r30, r16
    1300:	86 8f       	std	Z+30, r24	; 0x1e
    1302:	0f 90       	pop	r0
    1304:	0f be       	out	0x3f, r0	; 63
    1306:	0f b6       	in	r0, 0x3f	; 63
    1308:	f8 94       	cli
    130a:	0f 92       	push	r0
    130c:	c5 8d       	ldd	r28, Z+29	; 0x1d
    130e:	1c 16       	cp	r1, r28
    1310:	ac f4       	brge	.+42     	; 0x133c <prvUnlockQueue+0x84>
    1312:	80 85       	ldd	r24, Z+8	; 0x08
    1314:	81 11       	cpse	r24, r1
    1316:	06 c0       	rjmp	.+12     	; 0x1324 <prvUnlockQueue+0x6c>
    1318:	11 c0       	rjmp	.+34     	; 0x133c <prvUnlockQueue+0x84>
    131a:	f8 01       	movw	r30, r16
    131c:	80 85       	ldd	r24, Z+8	; 0x08
    131e:	81 11       	cpse	r24, r1
    1320:	05 c0       	rjmp	.+10     	; 0x132c <prvUnlockQueue+0x74>
    1322:	0c c0       	rjmp	.+24     	; 0x133c <prvUnlockQueue+0x84>
    1324:	78 01       	movw	r14, r16
    1326:	f8 e0       	ldi	r31, 0x08	; 8
    1328:	ef 0e       	add	r14, r31
    132a:	f1 1c       	adc	r15, r1
    132c:	c7 01       	movw	r24, r14
    132e:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskRemoveFromEventList>
    1332:	81 11       	cpse	r24, r1
    1334:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vTaskMissedYield>
    1338:	c1 50       	subi	r28, 0x01	; 1
    133a:	79 f7       	brne	.-34     	; 0x131a <prvUnlockQueue+0x62>
    133c:	8f ef       	ldi	r24, 0xFF	; 255
    133e:	f8 01       	movw	r30, r16
    1340:	85 8f       	std	Z+29, r24	; 0x1d
    1342:	0f 90       	pop	r0
    1344:	0f be       	out	0x3f, r0	; 63
    1346:	cf 91       	pop	r28
    1348:	1f 91       	pop	r17
    134a:	0f 91       	pop	r16
    134c:	ff 90       	pop	r15
    134e:	ef 90       	pop	r14
    1350:	08 95       	ret

00001352 <xQueueGenericReset>:
    1352:	cf 93       	push	r28
    1354:	df 93       	push	r29
    1356:	ec 01       	movw	r28, r24
    1358:	0f b6       	in	r0, 0x3f	; 63
    135a:	f8 94       	cli
    135c:	0f 92       	push	r0
    135e:	e8 81       	ld	r30, Y
    1360:	f9 81       	ldd	r31, Y+1	; 0x01
    1362:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1364:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	30 e0       	ldi	r19, 0x00	; 0
    136a:	82 9f       	mul	r24, r18
    136c:	a0 01       	movw	r20, r0
    136e:	83 9f       	mul	r24, r19
    1370:	50 0d       	add	r21, r0
    1372:	92 9f       	mul	r25, r18
    1374:	50 0d       	add	r21, r0
    1376:	11 24       	eor	r1, r1
    1378:	4e 0f       	add	r20, r30
    137a:	5f 1f       	adc	r21, r31
    137c:	5d 83       	std	Y+5, r21	; 0x05
    137e:	4c 83       	std	Y+4, r20	; 0x04
    1380:	1a 8e       	std	Y+26, r1	; 0x1a
    1382:	fb 83       	std	Y+3, r31	; 0x03
    1384:	ea 83       	std	Y+2, r30	; 0x02
    1386:	01 97       	sbiw	r24, 0x01	; 1
    1388:	82 9f       	mul	r24, r18
    138a:	a0 01       	movw	r20, r0
    138c:	83 9f       	mul	r24, r19
    138e:	50 0d       	add	r21, r0
    1390:	92 9f       	mul	r25, r18
    1392:	50 0d       	add	r21, r0
    1394:	11 24       	eor	r1, r1
    1396:	cf 01       	movw	r24, r30
    1398:	84 0f       	add	r24, r20
    139a:	95 1f       	adc	r25, r21
    139c:	9f 83       	std	Y+7, r25	; 0x07
    139e:	8e 83       	std	Y+6, r24	; 0x06
    13a0:	8f ef       	ldi	r24, 0xFF	; 255
    13a2:	8d 8f       	std	Y+29, r24	; 0x1d
    13a4:	8e 8f       	std	Y+30, r24	; 0x1e
    13a6:	61 11       	cpse	r22, r1
    13a8:	0c c0       	rjmp	.+24     	; 0x13c2 <xQueueGenericReset+0x70>
    13aa:	88 85       	ldd	r24, Y+8	; 0x08
    13ac:	88 23       	and	r24, r24
    13ae:	89 f0       	breq	.+34     	; 0x13d2 <xQueueGenericReset+0x80>
    13b0:	ce 01       	movw	r24, r28
    13b2:	08 96       	adiw	r24, 0x08	; 8
    13b4:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskRemoveFromEventList>
    13b8:	88 23       	and	r24, r24
    13ba:	59 f0       	breq	.+22     	; 0x13d2 <xQueueGenericReset+0x80>
    13bc:	0e 94 36 08 	call	0x106c	; 0x106c <vPortYield>
    13c0:	08 c0       	rjmp	.+16     	; 0x13d2 <xQueueGenericReset+0x80>
    13c2:	ce 01       	movw	r24, r28
    13c4:	08 96       	adiw	r24, 0x08	; 8
    13c6:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
    13ca:	ce 01       	movw	r24, r28
    13cc:	41 96       	adiw	r24, 0x11	; 17
    13ce:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
    13d2:	0f 90       	pop	r0
    13d4:	0f be       	out	0x3f, r0	; 63
    13d6:	81 e0       	ldi	r24, 0x01	; 1
    13d8:	df 91       	pop	r29
    13da:	cf 91       	pop	r28
    13dc:	08 95       	ret

000013de <xQueueGenericCreate>:
    13de:	0f 93       	push	r16
    13e0:	1f 93       	push	r17
    13e2:	cf 93       	push	r28
    13e4:	df 93       	push	r29
    13e6:	08 2f       	mov	r16, r24
    13e8:	16 2f       	mov	r17, r22
    13ea:	66 23       	and	r22, r22
    13ec:	c1 f0       	breq	.+48     	; 0x141e <xQueueGenericCreate+0x40>
    13ee:	86 9f       	mul	r24, r22
    13f0:	c0 01       	movw	r24, r0
    13f2:	11 24       	eor	r1, r1
    13f4:	4f 96       	adiw	r24, 0x1f	; 31
    13f6:	0e 94 d4 06 	call	0xda8	; 0xda8 <pvPortMalloc>
    13fa:	ec 01       	movw	r28, r24
    13fc:	00 97       	sbiw	r24, 0x00	; 0
    13fe:	41 f4       	brne	.+16     	; 0x1410 <xQueueGenericCreate+0x32>
    1400:	15 c0       	rjmp	.+42     	; 0x142c <xQueueGenericCreate+0x4e>
    1402:	0b 8f       	std	Y+27, r16	; 0x1b
    1404:	1c 8f       	std	Y+28, r17	; 0x1c
    1406:	61 e0       	ldi	r22, 0x01	; 1
    1408:	ce 01       	movw	r24, r28
    140a:	0e 94 a9 09 	call	0x1352	; 0x1352 <xQueueGenericReset>
    140e:	0e c0       	rjmp	.+28     	; 0x142c <xQueueGenericCreate+0x4e>
    1410:	4f 96       	adiw	r24, 0x1f	; 31
    1412:	99 83       	std	Y+1, r25	; 0x01
    1414:	88 83       	st	Y, r24
    1416:	f5 cf       	rjmp	.-22     	; 0x1402 <xQueueGenericCreate+0x24>
    1418:	d9 83       	std	Y+1, r29	; 0x01
    141a:	c8 83       	st	Y, r28
    141c:	f2 cf       	rjmp	.-28     	; 0x1402 <xQueueGenericCreate+0x24>
    141e:	8f e1       	ldi	r24, 0x1F	; 31
    1420:	90 e0       	ldi	r25, 0x00	; 0
    1422:	0e 94 d4 06 	call	0xda8	; 0xda8 <pvPortMalloc>
    1426:	ec 01       	movw	r28, r24
    1428:	89 2b       	or	r24, r25
    142a:	b1 f7       	brne	.-20     	; 0x1418 <xQueueGenericCreate+0x3a>
    142c:	ce 01       	movw	r24, r28
    142e:	df 91       	pop	r29
    1430:	cf 91       	pop	r28
    1432:	1f 91       	pop	r17
    1434:	0f 91       	pop	r16
    1436:	08 95       	ret

00001438 <xQueueGenericSend>:
    1438:	9f 92       	push	r9
    143a:	af 92       	push	r10
    143c:	bf 92       	push	r11
    143e:	cf 92       	push	r12
    1440:	df 92       	push	r13
    1442:	ef 92       	push	r14
    1444:	ff 92       	push	r15
    1446:	0f 93       	push	r16
    1448:	1f 93       	push	r17
    144a:	cf 93       	push	r28
    144c:	df 93       	push	r29
    144e:	00 d0       	rcall	.+0      	; 0x1450 <xQueueGenericSend+0x18>
    1450:	00 d0       	rcall	.+0      	; 0x1452 <xQueueGenericSend+0x1a>
    1452:	1f 92       	push	r1
    1454:	cd b7       	in	r28, 0x3d	; 61
    1456:	de b7       	in	r29, 0x3e	; 62
    1458:	8c 01       	movw	r16, r24
    145a:	6b 01       	movw	r12, r22
    145c:	5d 83       	std	Y+5, r21	; 0x05
    145e:	4c 83       	std	Y+4, r20	; 0x04
    1460:	a2 2e       	mov	r10, r18
    1462:	b1 2c       	mov	r11, r1
    1464:	99 24       	eor	r9, r9
    1466:	93 94       	inc	r9
    1468:	7c 01       	movw	r14, r24
    146a:	88 e0       	ldi	r24, 0x08	; 8
    146c:	e8 0e       	add	r14, r24
    146e:	f1 1c       	adc	r15, r1
    1470:	0f b6       	in	r0, 0x3f	; 63
    1472:	f8 94       	cli
    1474:	0f 92       	push	r0
    1476:	f8 01       	movw	r30, r16
    1478:	92 8d       	ldd	r25, Z+26	; 0x1a
    147a:	83 8d       	ldd	r24, Z+27	; 0x1b
    147c:	98 17       	cp	r25, r24
    147e:	18 f0       	brcs	.+6      	; 0x1486 <xQueueGenericSend+0x4e>
    1480:	f2 e0       	ldi	r31, 0x02	; 2
    1482:	af 12       	cpse	r10, r31
    1484:	19 c0       	rjmp	.+50     	; 0x14b8 <xQueueGenericSend+0x80>
    1486:	4a 2d       	mov	r20, r10
    1488:	b6 01       	movw	r22, r12
    148a:	c8 01       	movw	r24, r16
    148c:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <prvCopyDataToQueue>
    1490:	f8 01       	movw	r30, r16
    1492:	91 89       	ldd	r25, Z+17	; 0x11
    1494:	99 23       	and	r25, r25
    1496:	49 f0       	breq	.+18     	; 0x14aa <xQueueGenericSend+0x72>
    1498:	c8 01       	movw	r24, r16
    149a:	41 96       	adiw	r24, 0x11	; 17
    149c:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskRemoveFromEventList>
    14a0:	88 23       	and	r24, r24
    14a2:	31 f0       	breq	.+12     	; 0x14b0 <xQueueGenericSend+0x78>
    14a4:	0e 94 36 08 	call	0x106c	; 0x106c <vPortYield>
    14a8:	03 c0       	rjmp	.+6      	; 0x14b0 <xQueueGenericSend+0x78>
    14aa:	81 11       	cpse	r24, r1
    14ac:	0e 94 36 08 	call	0x106c	; 0x106c <vPortYield>
    14b0:	0f 90       	pop	r0
    14b2:	0f be       	out	0x3f, r0	; 63
    14b4:	81 e0       	ldi	r24, 0x01	; 1
    14b6:	50 c0       	rjmp	.+160    	; 0x1558 <xQueueGenericSend+0x120>
    14b8:	8c 81       	ldd	r24, Y+4	; 0x04
    14ba:	9d 81       	ldd	r25, Y+5	; 0x05
    14bc:	89 2b       	or	r24, r25
    14be:	21 f4       	brne	.+8      	; 0x14c8 <xQueueGenericSend+0x90>
    14c0:	0f 90       	pop	r0
    14c2:	0f be       	out	0x3f, r0	; 63
    14c4:	80 e0       	ldi	r24, 0x00	; 0
    14c6:	48 c0       	rjmp	.+144    	; 0x1558 <xQueueGenericSend+0x120>
    14c8:	b1 10       	cpse	r11, r1
    14ca:	05 c0       	rjmp	.+10     	; 0x14d6 <xQueueGenericSend+0x9e>
    14cc:	ce 01       	movw	r24, r28
    14ce:	01 96       	adiw	r24, 0x01	; 1
    14d0:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <vTaskInternalSetTimeOutState>
    14d4:	b9 2c       	mov	r11, r9
    14d6:	0f 90       	pop	r0
    14d8:	0f be       	out	0x3f, r0	; 63
    14da:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <vTaskSuspendAll>
    14de:	0f b6       	in	r0, 0x3f	; 63
    14e0:	f8 94       	cli
    14e2:	0f 92       	push	r0
    14e4:	f8 01       	movw	r30, r16
    14e6:	85 8d       	ldd	r24, Z+29	; 0x1d
    14e8:	8f 3f       	cpi	r24, 0xFF	; 255
    14ea:	09 f4       	brne	.+2      	; 0x14ee <xQueueGenericSend+0xb6>
    14ec:	15 8e       	std	Z+29, r1	; 0x1d
    14ee:	f8 01       	movw	r30, r16
    14f0:	86 8d       	ldd	r24, Z+30	; 0x1e
    14f2:	8f 3f       	cpi	r24, 0xFF	; 255
    14f4:	09 f4       	brne	.+2      	; 0x14f8 <xQueueGenericSend+0xc0>
    14f6:	16 8e       	std	Z+30, r1	; 0x1e
    14f8:	0f 90       	pop	r0
    14fa:	0f be       	out	0x3f, r0	; 63
    14fc:	be 01       	movw	r22, r28
    14fe:	6c 5f       	subi	r22, 0xFC	; 252
    1500:	7f 4f       	sbci	r23, 0xFF	; 255
    1502:	ce 01       	movw	r24, r28
    1504:	01 96       	adiw	r24, 0x01	; 1
    1506:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <xTaskCheckForTimeOut>
    150a:	81 11       	cpse	r24, r1
    150c:	1f c0       	rjmp	.+62     	; 0x154c <xQueueGenericSend+0x114>
    150e:	0f b6       	in	r0, 0x3f	; 63
    1510:	f8 94       	cli
    1512:	0f 92       	push	r0
    1514:	f8 01       	movw	r30, r16
    1516:	92 8d       	ldd	r25, Z+26	; 0x1a
    1518:	0f 90       	pop	r0
    151a:	0f be       	out	0x3f, r0	; 63
    151c:	83 8d       	ldd	r24, Z+27	; 0x1b
    151e:	98 13       	cpse	r25, r24
    1520:	0f c0       	rjmp	.+30     	; 0x1540 <xQueueGenericSend+0x108>
    1522:	6c 81       	ldd	r22, Y+4	; 0x04
    1524:	7d 81       	ldd	r23, Y+5	; 0x05
    1526:	c7 01       	movw	r24, r14
    1528:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vTaskPlaceOnEventList>
    152c:	c8 01       	movw	r24, r16
    152e:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <prvUnlockQueue>
    1532:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <xTaskResumeAll>
    1536:	81 11       	cpse	r24, r1
    1538:	9b cf       	rjmp	.-202    	; 0x1470 <xQueueGenericSend+0x38>
    153a:	0e 94 36 08 	call	0x106c	; 0x106c <vPortYield>
    153e:	98 cf       	rjmp	.-208    	; 0x1470 <xQueueGenericSend+0x38>
    1540:	c8 01       	movw	r24, r16
    1542:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <prvUnlockQueue>
    1546:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <xTaskResumeAll>
    154a:	92 cf       	rjmp	.-220    	; 0x1470 <xQueueGenericSend+0x38>
    154c:	c8 01       	movw	r24, r16
    154e:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <prvUnlockQueue>
    1552:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <xTaskResumeAll>
    1556:	80 e0       	ldi	r24, 0x00	; 0
    1558:	0f 90       	pop	r0
    155a:	0f 90       	pop	r0
    155c:	0f 90       	pop	r0
    155e:	0f 90       	pop	r0
    1560:	0f 90       	pop	r0
    1562:	df 91       	pop	r29
    1564:	cf 91       	pop	r28
    1566:	1f 91       	pop	r17
    1568:	0f 91       	pop	r16
    156a:	ff 90       	pop	r15
    156c:	ef 90       	pop	r14
    156e:	df 90       	pop	r13
    1570:	cf 90       	pop	r12
    1572:	bf 90       	pop	r11
    1574:	af 90       	pop	r10
    1576:	9f 90       	pop	r9
    1578:	08 95       	ret

0000157a <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    157a:	9f 92       	push	r9
    157c:	af 92       	push	r10
    157e:	bf 92       	push	r11
    1580:	cf 92       	push	r12
    1582:	df 92       	push	r13
    1584:	ef 92       	push	r14
    1586:	ff 92       	push	r15
    1588:	0f 93       	push	r16
    158a:	1f 93       	push	r17
    158c:	cf 93       	push	r28
    158e:	df 93       	push	r29
    1590:	00 d0       	rcall	.+0      	; 0x1592 <xQueueReceive+0x18>
    1592:	00 d0       	rcall	.+0      	; 0x1594 <xQueueReceive+0x1a>
    1594:	1f 92       	push	r1
    1596:	cd b7       	in	r28, 0x3d	; 61
    1598:	de b7       	in	r29, 0x3e	; 62
    159a:	8c 01       	movw	r16, r24
    159c:	5b 01       	movw	r10, r22
    159e:	5d 83       	std	Y+5, r21	; 0x05
    15a0:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    15a2:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    15a4:	99 24       	eor	r9, r9
    15a6:	93 94       	inc	r9
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15a8:	6c 01       	movw	r12, r24
    15aa:	81 e1       	ldi	r24, 0x11	; 17
    15ac:	c8 0e       	add	r12, r24
    15ae:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    15b0:	0f b6       	in	r0, 0x3f	; 63
    15b2:	f8 94       	cli
    15b4:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    15b6:	f8 01       	movw	r30, r16
    15b8:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    15ba:	ff 20       	and	r15, r15
    15bc:	a9 f0       	breq	.+42     	; 0x15e8 <xQueueReceive+0x6e>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    15be:	b5 01       	movw	r22, r10
    15c0:	c8 01       	movw	r24, r16
    15c2:	0e 94 42 09 	call	0x1284	; 0x1284 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    15c6:	fa 94       	dec	r15
    15c8:	f8 01       	movw	r30, r16
    15ca:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15cc:	80 85       	ldd	r24, Z+8	; 0x08
    15ce:	88 23       	and	r24, r24
    15d0:	39 f0       	breq	.+14     	; 0x15e0 <xQueueReceive+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15d2:	c8 01       	movw	r24, r16
    15d4:	08 96       	adiw	r24, 0x08	; 8
    15d6:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <xTaskRemoveFromEventList>
    15da:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    15dc:	0e 94 36 08 	call	0x106c	; 0x106c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    15e0:	0f 90       	pop	r0
    15e2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    15e4:	81 e0       	ldi	r24, 0x01	; 1
    15e6:	51 c0       	rjmp	.+162    	; 0x168a <xQueueReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    15e8:	8c 81       	ldd	r24, Y+4	; 0x04
    15ea:	9d 81       	ldd	r25, Y+5	; 0x05
    15ec:	89 2b       	or	r24, r25
    15ee:	21 f4       	brne	.+8      	; 0x15f8 <xQueueReceive+0x7e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    15f0:	0f 90       	pop	r0
    15f2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    15f4:	80 e0       	ldi	r24, 0x00	; 0
    15f6:	49 c0       	rjmp	.+146    	; 0x168a <xQueueReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
    15f8:	e1 10       	cpse	r14, r1
    15fa:	05 c0       	rjmp	.+10     	; 0x1606 <xQueueReceive+0x8c>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    15fc:	ce 01       	movw	r24, r28
    15fe:	01 96       	adiw	r24, 0x01	; 1
    1600:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1604:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1606:	0f 90       	pop	r0
    1608:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    160a:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    160e:	0f b6       	in	r0, 0x3f	; 63
    1610:	f8 94       	cli
    1612:	0f 92       	push	r0
    1614:	f8 01       	movw	r30, r16
    1616:	85 8d       	ldd	r24, Z+29	; 0x1d
    1618:	8f 3f       	cpi	r24, 0xFF	; 255
    161a:	09 f4       	brne	.+2      	; 0x161e <xQueueReceive+0xa4>
    161c:	15 8e       	std	Z+29, r1	; 0x1d
    161e:	f8 01       	movw	r30, r16
    1620:	86 8d       	ldd	r24, Z+30	; 0x1e
    1622:	8f 3f       	cpi	r24, 0xFF	; 255
    1624:	09 f4       	brne	.+2      	; 0x1628 <xQueueReceive+0xae>
    1626:	16 8e       	std	Z+30, r1	; 0x1e
    1628:	0f 90       	pop	r0
    162a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    162c:	be 01       	movw	r22, r28
    162e:	6c 5f       	subi	r22, 0xFC	; 252
    1630:	7f 4f       	sbci	r23, 0xFF	; 255
    1632:	ce 01       	movw	r24, r28
    1634:	01 96       	adiw	r24, 0x01	; 1
    1636:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <xTaskCheckForTimeOut>
    163a:	81 11       	cpse	r24, r1
    163c:	1a c0       	rjmp	.+52     	; 0x1672 <xQueueReceive+0xf8>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    163e:	c8 01       	movw	r24, r16
    1640:	0e 94 ee 08 	call	0x11dc	; 0x11dc <prvIsQueueEmpty>
    1644:	88 23       	and	r24, r24
    1646:	79 f0       	breq	.+30     	; 0x1666 <xQueueReceive+0xec>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1648:	6c 81       	ldd	r22, Y+4	; 0x04
    164a:	7d 81       	ldd	r23, Y+5	; 0x05
    164c:	c6 01       	movw	r24, r12
    164e:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1652:	c8 01       	movw	r24, r16
    1654:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1658:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <xTaskResumeAll>
    165c:	81 11       	cpse	r24, r1
    165e:	a8 cf       	rjmp	.-176    	; 0x15b0 <xQueueReceive+0x36>
				{
					portYIELD_WITHIN_API();
    1660:	0e 94 36 08 	call	0x106c	; 0x106c <vPortYield>
    1664:	a5 cf       	rjmp	.-182    	; 0x15b0 <xQueueReceive+0x36>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1666:	c8 01       	movw	r24, r16
    1668:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    166c:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <xTaskResumeAll>
    1670:	9f cf       	rjmp	.-194    	; 0x15b0 <xQueueReceive+0x36>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1672:	c8 01       	movw	r24, r16
    1674:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1678:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    167c:	c8 01       	movw	r24, r16
    167e:	0e 94 ee 08 	call	0x11dc	; 0x11dc <prvIsQueueEmpty>
    1682:	88 23       	and	r24, r24
    1684:	09 f4       	brne	.+2      	; 0x1688 <xQueueReceive+0x10e>
    1686:	94 cf       	rjmp	.-216    	; 0x15b0 <xQueueReceive+0x36>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1688:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    168a:	0f 90       	pop	r0
    168c:	0f 90       	pop	r0
    168e:	0f 90       	pop	r0
    1690:	0f 90       	pop	r0
    1692:	0f 90       	pop	r0
    1694:	df 91       	pop	r29
    1696:	cf 91       	pop	r28
    1698:	1f 91       	pop	r17
    169a:	0f 91       	pop	r16
    169c:	ff 90       	pop	r15
    169e:	ef 90       	pop	r14
    16a0:	df 90       	pop	r13
    16a2:	cf 90       	pop	r12
    16a4:	bf 90       	pop	r11
    16a6:	af 90       	pop	r10
    16a8:	9f 90       	pop	r9
    16aa:	08 95       	ret

000016ac <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    16ac:	e0 91 46 07 	lds	r30, 0x0746	; 0x800746 <pxDelayedTaskList>
    16b0:	f0 91 47 07 	lds	r31, 0x0747	; 0x800747 <pxDelayedTaskList+0x1>
    16b4:	80 81       	ld	r24, Z
    16b6:	81 11       	cpse	r24, r1
    16b8:	07 c0       	rjmp	.+14     	; 0x16c8 <prvResetNextTaskUnblockTime+0x1c>
    16ba:	8f ef       	ldi	r24, 0xFF	; 255
    16bc:	9f ef       	ldi	r25, 0xFF	; 255
    16be:	90 93 1e 07 	sts	0x071E, r25	; 0x80071e <xNextTaskUnblockTime+0x1>
    16c2:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <xNextTaskUnblockTime>
    16c6:	08 95       	ret
    16c8:	e0 91 46 07 	lds	r30, 0x0746	; 0x800746 <pxDelayedTaskList>
    16cc:	f0 91 47 07 	lds	r31, 0x0747	; 0x800747 <pxDelayedTaskList+0x1>
    16d0:	05 80       	ldd	r0, Z+5	; 0x05
    16d2:	f6 81       	ldd	r31, Z+6	; 0x06
    16d4:	e0 2d       	mov	r30, r0
    16d6:	06 80       	ldd	r0, Z+6	; 0x06
    16d8:	f7 81       	ldd	r31, Z+7	; 0x07
    16da:	e0 2d       	mov	r30, r0
    16dc:	82 81       	ldd	r24, Z+2	; 0x02
    16de:	93 81       	ldd	r25, Z+3	; 0x03
    16e0:	90 93 1e 07 	sts	0x071E, r25	; 0x80071e <xNextTaskUnblockTime+0x1>
    16e4:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <xNextTaskUnblockTime>
    16e8:	08 95       	ret

000016ea <prvIdleTask>:
    16ea:	02 e3       	ldi	r16, 0x32	; 50
    16ec:	17 e0       	ldi	r17, 0x07	; 7
    16ee:	80 91 31 07 	lds	r24, 0x0731	; 0x800731 <uxDeletedTasksWaitingCleanUp>
    16f2:	88 23       	and	r24, r24
    16f4:	e1 f3       	breq	.-8      	; 0x16ee <prvIdleTask+0x4>
    16f6:	0f b6       	in	r0, 0x3f	; 63
    16f8:	f8 94       	cli
    16fa:	0f 92       	push	r0
    16fc:	d8 01       	movw	r26, r16
    16fe:	15 96       	adiw	r26, 0x05	; 5
    1700:	ed 91       	ld	r30, X+
    1702:	fc 91       	ld	r31, X
    1704:	16 97       	sbiw	r26, 0x06	; 6
    1706:	c6 81       	ldd	r28, Z+6	; 0x06
    1708:	d7 81       	ldd	r29, Z+7	; 0x07
    170a:	ce 01       	movw	r24, r28
    170c:	02 96       	adiw	r24, 0x02	; 2
    170e:	0e 94 6e 07 	call	0xedc	; 0xedc <uxListRemove>
    1712:	80 91 27 07 	lds	r24, 0x0727	; 0x800727 <uxCurrentNumberOfTasks>
    1716:	81 50       	subi	r24, 0x01	; 1
    1718:	80 93 27 07 	sts	0x0727, r24	; 0x800727 <uxCurrentNumberOfTasks>
    171c:	80 91 31 07 	lds	r24, 0x0731	; 0x800731 <uxDeletedTasksWaitingCleanUp>
    1720:	81 50       	subi	r24, 0x01	; 1
    1722:	80 93 31 07 	sts	0x0731, r24	; 0x800731 <uxDeletedTasksWaitingCleanUp>
    1726:	0f 90       	pop	r0
    1728:	0f be       	out	0x3f, r0	; 63
    172a:	8f 89       	ldd	r24, Y+23	; 0x17
    172c:	98 8d       	ldd	r25, Y+24	; 0x18
    172e:	0e 94 09 07 	call	0xe12	; 0xe12 <vPortFree>
    1732:	ce 01       	movw	r24, r28
    1734:	0e 94 09 07 	call	0xe12	; 0xe12 <vPortFree>
    1738:	80 91 31 07 	lds	r24, 0x0731	; 0x800731 <uxDeletedTasksWaitingCleanUp>
    173c:	81 11       	cpse	r24, r1
    173e:	db cf       	rjmp	.-74     	; 0x16f6 <prvIdleTask+0xc>
    1740:	d6 cf       	rjmp	.-84     	; 0x16ee <prvIdleTask+0x4>

00001742 <prvAddCurrentTaskToDelayedList>:
    1742:	ff 92       	push	r15
    1744:	0f 93       	push	r16
    1746:	1f 93       	push	r17
    1748:	cf 93       	push	r28
    174a:	df 93       	push	r29
    174c:	ec 01       	movw	r28, r24
    174e:	f6 2e       	mov	r15, r22
    1750:	00 91 25 07 	lds	r16, 0x0725	; 0x800725 <xTickCount>
    1754:	10 91 26 07 	lds	r17, 0x0726	; 0x800726 <xTickCount+0x1>
    1758:	80 91 7e 07 	lds	r24, 0x077E	; 0x80077e <pxCurrentTCB>
    175c:	90 91 7f 07 	lds	r25, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    1760:	02 96       	adiw	r24, 0x02	; 2
    1762:	0e 94 6e 07 	call	0xedc	; 0xedc <uxListRemove>
    1766:	cf 3f       	cpi	r28, 0xFF	; 255
    1768:	8f ef       	ldi	r24, 0xFF	; 255
    176a:	d8 07       	cpc	r29, r24
    176c:	69 f4       	brne	.+26     	; 0x1788 <prvAddCurrentTaskToDelayedList+0x46>
    176e:	ff 20       	and	r15, r15
    1770:	59 f0       	breq	.+22     	; 0x1788 <prvAddCurrentTaskToDelayedList+0x46>
    1772:	60 91 7e 07 	lds	r22, 0x077E	; 0x80077e <pxCurrentTCB>
    1776:	70 91 7f 07 	lds	r23, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    177a:	6e 5f       	subi	r22, 0xFE	; 254
    177c:	7f 4f       	sbci	r23, 0xFF	; 255
    177e:	88 e2       	ldi	r24, 0x28	; 40
    1780:	97 e0       	ldi	r25, 0x07	; 7
    1782:	0e 94 1c 07 	call	0xe38	; 0xe38 <vListInsertEnd>
    1786:	2f c0       	rjmp	.+94     	; 0x17e6 <prvAddCurrentTaskToDelayedList+0xa4>
    1788:	c0 0f       	add	r28, r16
    178a:	d1 1f       	adc	r29, r17
    178c:	e0 91 7e 07 	lds	r30, 0x077E	; 0x80077e <pxCurrentTCB>
    1790:	f0 91 7f 07 	lds	r31, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    1794:	d3 83       	std	Z+3, r29	; 0x03
    1796:	c2 83       	std	Z+2, r28	; 0x02
    1798:	c0 17       	cp	r28, r16
    179a:	d1 07       	cpc	r29, r17
    179c:	68 f4       	brcc	.+26     	; 0x17b8 <prvAddCurrentTaskToDelayedList+0x76>
    179e:	60 91 7e 07 	lds	r22, 0x077E	; 0x80077e <pxCurrentTCB>
    17a2:	70 91 7f 07 	lds	r23, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    17a6:	80 91 44 07 	lds	r24, 0x0744	; 0x800744 <pxOverflowDelayedTaskList>
    17aa:	90 91 45 07 	lds	r25, 0x0745	; 0x800745 <pxOverflowDelayedTaskList+0x1>
    17ae:	6e 5f       	subi	r22, 0xFE	; 254
    17b0:	7f 4f       	sbci	r23, 0xFF	; 255
    17b2:	0e 94 3d 07 	call	0xe7a	; 0xe7a <vListInsert>
    17b6:	17 c0       	rjmp	.+46     	; 0x17e6 <prvAddCurrentTaskToDelayedList+0xa4>
    17b8:	60 91 7e 07 	lds	r22, 0x077E	; 0x80077e <pxCurrentTCB>
    17bc:	70 91 7f 07 	lds	r23, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    17c0:	80 91 46 07 	lds	r24, 0x0746	; 0x800746 <pxDelayedTaskList>
    17c4:	90 91 47 07 	lds	r25, 0x0747	; 0x800747 <pxDelayedTaskList+0x1>
    17c8:	6e 5f       	subi	r22, 0xFE	; 254
    17ca:	7f 4f       	sbci	r23, 0xFF	; 255
    17cc:	0e 94 3d 07 	call	0xe7a	; 0xe7a <vListInsert>
    17d0:	80 91 1d 07 	lds	r24, 0x071D	; 0x80071d <xNextTaskUnblockTime>
    17d4:	90 91 1e 07 	lds	r25, 0x071E	; 0x80071e <xNextTaskUnblockTime+0x1>
    17d8:	c8 17       	cp	r28, r24
    17da:	d9 07       	cpc	r29, r25
    17dc:	20 f4       	brcc	.+8      	; 0x17e6 <prvAddCurrentTaskToDelayedList+0xa4>
    17de:	d0 93 1e 07 	sts	0x071E, r29	; 0x80071e <xNextTaskUnblockTime+0x1>
    17e2:	c0 93 1d 07 	sts	0x071D, r28	; 0x80071d <xNextTaskUnblockTime>
    17e6:	df 91       	pop	r29
    17e8:	cf 91       	pop	r28
    17ea:	1f 91       	pop	r17
    17ec:	0f 91       	pop	r16
    17ee:	ff 90       	pop	r15
    17f0:	08 95       	ret

000017f2 <xTaskCreate>:
    17f2:	4f 92       	push	r4
    17f4:	5f 92       	push	r5
    17f6:	6f 92       	push	r6
    17f8:	7f 92       	push	r7
    17fa:	8f 92       	push	r8
    17fc:	9f 92       	push	r9
    17fe:	af 92       	push	r10
    1800:	bf 92       	push	r11
    1802:	cf 92       	push	r12
    1804:	df 92       	push	r13
    1806:	ef 92       	push	r14
    1808:	ff 92       	push	r15
    180a:	0f 93       	push	r16
    180c:	cf 93       	push	r28
    180e:	df 93       	push	r29
    1810:	4c 01       	movw	r8, r24
    1812:	6b 01       	movw	r12, r22
    1814:	5a 01       	movw	r10, r20
    1816:	29 01       	movw	r4, r18
    1818:	ca 01       	movw	r24, r20
    181a:	0e 94 d4 06 	call	0xda8	; 0xda8 <pvPortMalloc>
    181e:	3c 01       	movw	r6, r24
    1820:	89 2b       	or	r24, r25
    1822:	09 f4       	brne	.+2      	; 0x1826 <xTaskCreate+0x34>
    1824:	e7 c0       	rjmp	.+462    	; 0x19f4 <xTaskCreate+0x202>
    1826:	86 e2       	ldi	r24, 0x26	; 38
    1828:	90 e0       	ldi	r25, 0x00	; 0
    182a:	0e 94 d4 06 	call	0xda8	; 0xda8 <pvPortMalloc>
    182e:	ec 01       	movw	r28, r24
    1830:	89 2b       	or	r24, r25
    1832:	59 f0       	breq	.+22     	; 0x184a <xTaskCreate+0x58>
    1834:	78 8e       	std	Y+24, r7	; 0x18
    1836:	6f 8a       	std	Y+23, r6	; 0x17
    1838:	81 e0       	ldi	r24, 0x01	; 1
    183a:	a8 1a       	sub	r10, r24
    183c:	b1 08       	sbc	r11, r1
    183e:	a6 0c       	add	r10, r6
    1840:	b7 1c       	adc	r11, r7
    1842:	c1 14       	cp	r12, r1
    1844:	d1 04       	cpc	r13, r1
    1846:	29 f4       	brne	.+10     	; 0x1852 <xTaskCreate+0x60>
    1848:	20 c0       	rjmp	.+64     	; 0x188a <xTaskCreate+0x98>
    184a:	c3 01       	movw	r24, r6
    184c:	0e 94 09 07 	call	0xe12	; 0xe12 <vPortFree>
    1850:	d1 c0       	rjmp	.+418    	; 0x19f4 <xTaskCreate+0x202>
    1852:	d6 01       	movw	r26, r12
    1854:	8c 91       	ld	r24, X
    1856:	89 8f       	std	Y+25, r24	; 0x19
    1858:	8c 91       	ld	r24, X
    185a:	88 23       	and	r24, r24
    185c:	a1 f0       	breq	.+40     	; 0x1886 <xTaskCreate+0x94>
    185e:	ae 01       	movw	r20, r28
    1860:	46 5e       	subi	r20, 0xE6	; 230
    1862:	5f 4f       	sbci	r21, 0xFF	; 255
    1864:	f6 01       	movw	r30, r12
    1866:	31 96       	adiw	r30, 0x01	; 1
    1868:	b8 e0       	ldi	r27, 0x08	; 8
    186a:	cb 0e       	add	r12, r27
    186c:	d1 1c       	adc	r13, r1
    186e:	cf 01       	movw	r24, r30
    1870:	21 91       	ld	r18, Z+
    1872:	da 01       	movw	r26, r20
    1874:	2d 93       	st	X+, r18
    1876:	ad 01       	movw	r20, r26
    1878:	dc 01       	movw	r26, r24
    187a:	8c 91       	ld	r24, X
    187c:	88 23       	and	r24, r24
    187e:	19 f0       	breq	.+6      	; 0x1886 <xTaskCreate+0x94>
    1880:	ec 15       	cp	r30, r12
    1882:	fd 05       	cpc	r31, r13
    1884:	a1 f7       	brne	.-24     	; 0x186e <xTaskCreate+0x7c>
    1886:	18 a2       	std	Y+32, r1	; 0x20
    1888:	01 c0       	rjmp	.+2      	; 0x188c <xTaskCreate+0x9a>
    188a:	19 8e       	std	Y+25, r1	; 0x19
    188c:	04 30       	cpi	r16, 0x04	; 4
    188e:	08 f0       	brcs	.+2      	; 0x1892 <xTaskCreate+0xa0>
    1890:	03 e0       	ldi	r16, 0x03	; 3
    1892:	0e 8b       	std	Y+22, r16	; 0x16
    1894:	6e 01       	movw	r12, r28
    1896:	b2 e0       	ldi	r27, 0x02	; 2
    1898:	cb 0e       	add	r12, r27
    189a:	d1 1c       	adc	r13, r1
    189c:	c6 01       	movw	r24, r12
    189e:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInitialiseItem>
    18a2:	ce 01       	movw	r24, r28
    18a4:	0c 96       	adiw	r24, 0x0c	; 12
    18a6:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInitialiseItem>
    18aa:	d9 87       	std	Y+9, r29	; 0x09
    18ac:	c8 87       	std	Y+8, r28	; 0x08
    18ae:	84 e0       	ldi	r24, 0x04	; 4
    18b0:	90 e0       	ldi	r25, 0x00	; 0
    18b2:	80 1b       	sub	r24, r16
    18b4:	91 09       	sbc	r25, r1
    18b6:	9d 87       	std	Y+13, r25	; 0x0d
    18b8:	8c 87       	std	Y+12, r24	; 0x0c
    18ba:	db 8b       	std	Y+19, r29	; 0x13
    18bc:	ca 8b       	std	Y+18, r28	; 0x12
    18be:	19 a2       	std	Y+33, r1	; 0x21
    18c0:	1a a2       	std	Y+34, r1	; 0x22
    18c2:	1b a2       	std	Y+35, r1	; 0x23
    18c4:	1c a2       	std	Y+36, r1	; 0x24
    18c6:	1d a2       	std	Y+37, r1	; 0x25
    18c8:	a2 01       	movw	r20, r4
    18ca:	b4 01       	movw	r22, r8
    18cc:	c5 01       	movw	r24, r10
    18ce:	0e 94 95 07 	call	0xf2a	; 0xf2a <pxPortInitialiseStack>
    18d2:	99 83       	std	Y+1, r25	; 0x01
    18d4:	88 83       	st	Y, r24
    18d6:	e1 14       	cp	r14, r1
    18d8:	f1 04       	cpc	r15, r1
    18da:	19 f0       	breq	.+6      	; 0x18e2 <xTaskCreate+0xf0>
    18dc:	f7 01       	movw	r30, r14
    18de:	d1 83       	std	Z+1, r29	; 0x01
    18e0:	c0 83       	st	Z, r28
    18e2:	0f b6       	in	r0, 0x3f	; 63
    18e4:	f8 94       	cli
    18e6:	0f 92       	push	r0
    18e8:	80 91 27 07 	lds	r24, 0x0727	; 0x800727 <uxCurrentNumberOfTasks>
    18ec:	8f 5f       	subi	r24, 0xFF	; 255
    18ee:	80 93 27 07 	sts	0x0727, r24	; 0x800727 <uxCurrentNumberOfTasks>
    18f2:	80 91 7e 07 	lds	r24, 0x077E	; 0x80077e <pxCurrentTCB>
    18f6:	90 91 7f 07 	lds	r25, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    18fa:	89 2b       	or	r24, r25
    18fc:	d1 f5       	brne	.+116    	; 0x1972 <xTaskCreate+0x180>
    18fe:	d0 93 7f 07 	sts	0x077F, r29	; 0x80077f <pxCurrentTCB+0x1>
    1902:	c0 93 7e 07 	sts	0x077E, r28	; 0x80077e <pxCurrentTCB>
    1906:	80 91 27 07 	lds	r24, 0x0727	; 0x800727 <uxCurrentNumberOfTasks>
    190a:	81 30       	cpi	r24, 0x01	; 1
    190c:	09 f0       	breq	.+2      	; 0x1910 <xTaskCreate+0x11e>
    190e:	41 c0       	rjmp	.+130    	; 0x1992 <xTaskCreate+0x1a0>
    1910:	8a e5       	ldi	r24, 0x5A	; 90
    1912:	97 e0       	ldi	r25, 0x07	; 7
    1914:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
    1918:	83 e6       	ldi	r24, 0x63	; 99
    191a:	97 e0       	ldi	r25, 0x07	; 7
    191c:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
    1920:	8c e6       	ldi	r24, 0x6C	; 108
    1922:	97 e0       	ldi	r25, 0x07	; 7
    1924:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
    1928:	85 e7       	ldi	r24, 0x75	; 117
    192a:	97 e0       	ldi	r25, 0x07	; 7
    192c:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
    1930:	81 e5       	ldi	r24, 0x51	; 81
    1932:	97 e0       	ldi	r25, 0x07	; 7
    1934:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
    1938:	88 e4       	ldi	r24, 0x48	; 72
    193a:	97 e0       	ldi	r25, 0x07	; 7
    193c:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
    1940:	8b e3       	ldi	r24, 0x3B	; 59
    1942:	97 e0       	ldi	r25, 0x07	; 7
    1944:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
    1948:	82 e3       	ldi	r24, 0x32	; 50
    194a:	97 e0       	ldi	r25, 0x07	; 7
    194c:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
    1950:	88 e2       	ldi	r24, 0x28	; 40
    1952:	97 e0       	ldi	r25, 0x07	; 7
    1954:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialise>
    1958:	81 e5       	ldi	r24, 0x51	; 81
    195a:	97 e0       	ldi	r25, 0x07	; 7
    195c:	90 93 47 07 	sts	0x0747, r25	; 0x800747 <pxDelayedTaskList+0x1>
    1960:	80 93 46 07 	sts	0x0746, r24	; 0x800746 <pxDelayedTaskList>
    1964:	88 e4       	ldi	r24, 0x48	; 72
    1966:	97 e0       	ldi	r25, 0x07	; 7
    1968:	90 93 45 07 	sts	0x0745, r25	; 0x800745 <pxOverflowDelayedTaskList+0x1>
    196c:	80 93 44 07 	sts	0x0744, r24	; 0x800744 <pxOverflowDelayedTaskList>
    1970:	10 c0       	rjmp	.+32     	; 0x1992 <xTaskCreate+0x1a0>
    1972:	80 91 23 07 	lds	r24, 0x0723	; 0x800723 <xSchedulerRunning>
    1976:	81 11       	cpse	r24, r1
    1978:	0c c0       	rjmp	.+24     	; 0x1992 <xTaskCreate+0x1a0>
    197a:	e0 91 7e 07 	lds	r30, 0x077E	; 0x80077e <pxCurrentTCB>
    197e:	f0 91 7f 07 	lds	r31, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    1982:	96 89       	ldd	r25, Z+22	; 0x16
    1984:	8e 89       	ldd	r24, Y+22	; 0x16
    1986:	89 17       	cp	r24, r25
    1988:	20 f0       	brcs	.+8      	; 0x1992 <xTaskCreate+0x1a0>
    198a:	d0 93 7f 07 	sts	0x077F, r29	; 0x80077f <pxCurrentTCB+0x1>
    198e:	c0 93 7e 07 	sts	0x077E, r28	; 0x80077e <pxCurrentTCB>
    1992:	80 91 1f 07 	lds	r24, 0x071F	; 0x80071f <uxTaskNumber>
    1996:	8f 5f       	subi	r24, 0xFF	; 255
    1998:	80 93 1f 07 	sts	0x071F, r24	; 0x80071f <uxTaskNumber>
    199c:	8e 89       	ldd	r24, Y+22	; 0x16
    199e:	90 91 24 07 	lds	r25, 0x0724	; 0x800724 <uxTopReadyPriority>
    19a2:	98 17       	cp	r25, r24
    19a4:	10 f4       	brcc	.+4      	; 0x19aa <xTaskCreate+0x1b8>
    19a6:	80 93 24 07 	sts	0x0724, r24	; 0x800724 <uxTopReadyPriority>
    19aa:	90 e0       	ldi	r25, 0x00	; 0
    19ac:	9c 01       	movw	r18, r24
    19ae:	22 0f       	add	r18, r18
    19b0:	33 1f       	adc	r19, r19
    19b2:	22 0f       	add	r18, r18
    19b4:	33 1f       	adc	r19, r19
    19b6:	22 0f       	add	r18, r18
    19b8:	33 1f       	adc	r19, r19
    19ba:	82 0f       	add	r24, r18
    19bc:	93 1f       	adc	r25, r19
    19be:	b6 01       	movw	r22, r12
    19c0:	86 5a       	subi	r24, 0xA6	; 166
    19c2:	98 4f       	sbci	r25, 0xF8	; 248
    19c4:	0e 94 1c 07 	call	0xe38	; 0xe38 <vListInsertEnd>
    19c8:	0f 90       	pop	r0
    19ca:	0f be       	out	0x3f, r0	; 63
    19cc:	80 91 23 07 	lds	r24, 0x0723	; 0x800723 <xSchedulerRunning>
    19d0:	88 23       	and	r24, r24
    19d2:	61 f0       	breq	.+24     	; 0x19ec <xTaskCreate+0x1fa>
    19d4:	e0 91 7e 07 	lds	r30, 0x077E	; 0x80077e <pxCurrentTCB>
    19d8:	f0 91 7f 07 	lds	r31, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    19dc:	96 89       	ldd	r25, Z+22	; 0x16
    19de:	8e 89       	ldd	r24, Y+22	; 0x16
    19e0:	98 17       	cp	r25, r24
    19e2:	30 f4       	brcc	.+12     	; 0x19f0 <xTaskCreate+0x1fe>
    19e4:	0e 94 36 08 	call	0x106c	; 0x106c <vPortYield>
    19e8:	81 e0       	ldi	r24, 0x01	; 1
    19ea:	05 c0       	rjmp	.+10     	; 0x19f6 <xTaskCreate+0x204>
    19ec:	81 e0       	ldi	r24, 0x01	; 1
    19ee:	03 c0       	rjmp	.+6      	; 0x19f6 <xTaskCreate+0x204>
    19f0:	81 e0       	ldi	r24, 0x01	; 1
    19f2:	01 c0       	rjmp	.+2      	; 0x19f6 <xTaskCreate+0x204>
    19f4:	8f ef       	ldi	r24, 0xFF	; 255
    19f6:	df 91       	pop	r29
    19f8:	cf 91       	pop	r28
    19fa:	0f 91       	pop	r16
    19fc:	ff 90       	pop	r15
    19fe:	ef 90       	pop	r14
    1a00:	df 90       	pop	r13
    1a02:	cf 90       	pop	r12
    1a04:	bf 90       	pop	r11
    1a06:	af 90       	pop	r10
    1a08:	9f 90       	pop	r9
    1a0a:	8f 90       	pop	r8
    1a0c:	7f 90       	pop	r7
    1a0e:	6f 90       	pop	r6
    1a10:	5f 90       	pop	r5
    1a12:	4f 90       	pop	r4
    1a14:	08 95       	ret

00001a16 <vTaskStartScheduler>:
    1a16:	ef 92       	push	r14
    1a18:	ff 92       	push	r15
    1a1a:	0f 93       	push	r16
    1a1c:	0f 2e       	mov	r0, r31
    1a1e:	fb e1       	ldi	r31, 0x1B	; 27
    1a20:	ef 2e       	mov	r14, r31
    1a22:	f7 e0       	ldi	r31, 0x07	; 7
    1a24:	ff 2e       	mov	r15, r31
    1a26:	f0 2d       	mov	r31, r0
    1a28:	00 e0       	ldi	r16, 0x00	; 0
    1a2a:	20 e0       	ldi	r18, 0x00	; 0
    1a2c:	30 e0       	ldi	r19, 0x00	; 0
    1a2e:	45 e5       	ldi	r20, 0x55	; 85
    1a30:	50 e0       	ldi	r21, 0x00	; 0
    1a32:	6c ed       	ldi	r22, 0xDC	; 220
    1a34:	70 e0       	ldi	r23, 0x00	; 0
    1a36:	85 e7       	ldi	r24, 0x75	; 117
    1a38:	9b e0       	ldi	r25, 0x0B	; 11
    1a3a:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <xTaskCreate>
    1a3e:	81 30       	cpi	r24, 0x01	; 1
    1a40:	81 f4       	brne	.+32     	; 0x1a62 <vTaskStartScheduler+0x4c>
    1a42:	f8 94       	cli
    1a44:	8f ef       	ldi	r24, 0xFF	; 255
    1a46:	9f ef       	ldi	r25, 0xFF	; 255
    1a48:	90 93 1e 07 	sts	0x071E, r25	; 0x80071e <xNextTaskUnblockTime+0x1>
    1a4c:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <xNextTaskUnblockTime>
    1a50:	81 e0       	ldi	r24, 0x01	; 1
    1a52:	80 93 23 07 	sts	0x0723, r24	; 0x800723 <xSchedulerRunning>
    1a56:	10 92 26 07 	sts	0x0726, r1	; 0x800726 <xTickCount+0x1>
    1a5a:	10 92 25 07 	sts	0x0725, r1	; 0x800725 <xTickCount>
    1a5e:	0e 94 01 08 	call	0x1002	; 0x1002 <xPortStartScheduler>
    1a62:	0f 91       	pop	r16
    1a64:	ff 90       	pop	r15
    1a66:	ef 90       	pop	r14
    1a68:	08 95       	ret

00001a6a <vTaskSuspendAll>:
    1a6a:	80 91 1a 07 	lds	r24, 0x071A	; 0x80071a <uxSchedulerSuspended>
    1a6e:	8f 5f       	subi	r24, 0xFF	; 255
    1a70:	80 93 1a 07 	sts	0x071A, r24	; 0x80071a <uxSchedulerSuspended>
    1a74:	08 95       	ret

00001a76 <xTaskIncrementTick>:
    1a76:	cf 92       	push	r12
    1a78:	df 92       	push	r13
    1a7a:	ef 92       	push	r14
    1a7c:	ff 92       	push	r15
    1a7e:	0f 93       	push	r16
    1a80:	1f 93       	push	r17
    1a82:	cf 93       	push	r28
    1a84:	df 93       	push	r29
    1a86:	80 91 1a 07 	lds	r24, 0x071A	; 0x80071a <uxSchedulerSuspended>
    1a8a:	81 11       	cpse	r24, r1
    1a8c:	99 c0       	rjmp	.+306    	; 0x1bc0 <xTaskIncrementTick+0x14a>
    1a8e:	e0 90 25 07 	lds	r14, 0x0725	; 0x800725 <xTickCount>
    1a92:	f0 90 26 07 	lds	r15, 0x0726	; 0x800726 <xTickCount+0x1>
    1a96:	8f ef       	ldi	r24, 0xFF	; 255
    1a98:	e8 1a       	sub	r14, r24
    1a9a:	f8 0a       	sbc	r15, r24
    1a9c:	f0 92 26 07 	sts	0x0726, r15	; 0x800726 <xTickCount+0x1>
    1aa0:	e0 92 25 07 	sts	0x0725, r14	; 0x800725 <xTickCount>
    1aa4:	e1 14       	cp	r14, r1
    1aa6:	f1 04       	cpc	r15, r1
    1aa8:	b9 f4       	brne	.+46     	; 0x1ad8 <xTaskIncrementTick+0x62>
    1aaa:	80 91 46 07 	lds	r24, 0x0746	; 0x800746 <pxDelayedTaskList>
    1aae:	90 91 47 07 	lds	r25, 0x0747	; 0x800747 <pxDelayedTaskList+0x1>
    1ab2:	20 91 44 07 	lds	r18, 0x0744	; 0x800744 <pxOverflowDelayedTaskList>
    1ab6:	30 91 45 07 	lds	r19, 0x0745	; 0x800745 <pxOverflowDelayedTaskList+0x1>
    1aba:	30 93 47 07 	sts	0x0747, r19	; 0x800747 <pxDelayedTaskList+0x1>
    1abe:	20 93 46 07 	sts	0x0746, r18	; 0x800746 <pxDelayedTaskList>
    1ac2:	90 93 45 07 	sts	0x0745, r25	; 0x800745 <pxOverflowDelayedTaskList+0x1>
    1ac6:	80 93 44 07 	sts	0x0744, r24	; 0x800744 <pxOverflowDelayedTaskList>
    1aca:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <xNumOfOverflows>
    1ace:	8f 5f       	subi	r24, 0xFF	; 255
    1ad0:	80 93 20 07 	sts	0x0720, r24	; 0x800720 <xNumOfOverflows>
    1ad4:	0e 94 56 0b 	call	0x16ac	; 0x16ac <prvResetNextTaskUnblockTime>
    1ad8:	80 91 1d 07 	lds	r24, 0x071D	; 0x80071d <xNextTaskUnblockTime>
    1adc:	90 91 1e 07 	lds	r25, 0x071E	; 0x80071e <xNextTaskUnblockTime+0x1>
    1ae0:	e8 16       	cp	r14, r24
    1ae2:	f9 06       	cpc	r15, r25
    1ae4:	10 f4       	brcc	.+4      	; 0x1aea <xTaskIncrementTick+0x74>
    1ae6:	d1 2c       	mov	r13, r1
    1ae8:	53 c0       	rjmp	.+166    	; 0x1b90 <xTaskIncrementTick+0x11a>
    1aea:	d1 2c       	mov	r13, r1
    1aec:	cc 24       	eor	r12, r12
    1aee:	c3 94       	inc	r12
    1af0:	e0 91 46 07 	lds	r30, 0x0746	; 0x800746 <pxDelayedTaskList>
    1af4:	f0 91 47 07 	lds	r31, 0x0747	; 0x800747 <pxDelayedTaskList+0x1>
    1af8:	80 81       	ld	r24, Z
    1afa:	81 11       	cpse	r24, r1
    1afc:	07 c0       	rjmp	.+14     	; 0x1b0c <xTaskIncrementTick+0x96>
    1afe:	8f ef       	ldi	r24, 0xFF	; 255
    1b00:	9f ef       	ldi	r25, 0xFF	; 255
    1b02:	90 93 1e 07 	sts	0x071E, r25	; 0x80071e <xNextTaskUnblockTime+0x1>
    1b06:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <xNextTaskUnblockTime>
    1b0a:	42 c0       	rjmp	.+132    	; 0x1b90 <xTaskIncrementTick+0x11a>
    1b0c:	e0 91 46 07 	lds	r30, 0x0746	; 0x800746 <pxDelayedTaskList>
    1b10:	f0 91 47 07 	lds	r31, 0x0747	; 0x800747 <pxDelayedTaskList+0x1>
    1b14:	05 80       	ldd	r0, Z+5	; 0x05
    1b16:	f6 81       	ldd	r31, Z+6	; 0x06
    1b18:	e0 2d       	mov	r30, r0
    1b1a:	c6 81       	ldd	r28, Z+6	; 0x06
    1b1c:	d7 81       	ldd	r29, Z+7	; 0x07
    1b1e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b20:	9b 81       	ldd	r25, Y+3	; 0x03
    1b22:	e8 16       	cp	r14, r24
    1b24:	f9 06       	cpc	r15, r25
    1b26:	28 f4       	brcc	.+10     	; 0x1b32 <xTaskIncrementTick+0xbc>
    1b28:	90 93 1e 07 	sts	0x071E, r25	; 0x80071e <xNextTaskUnblockTime+0x1>
    1b2c:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <xNextTaskUnblockTime>
    1b30:	2f c0       	rjmp	.+94     	; 0x1b90 <xTaskIncrementTick+0x11a>
    1b32:	8e 01       	movw	r16, r28
    1b34:	0e 5f       	subi	r16, 0xFE	; 254
    1b36:	1f 4f       	sbci	r17, 0xFF	; 255
    1b38:	c8 01       	movw	r24, r16
    1b3a:	0e 94 6e 07 	call	0xedc	; 0xedc <uxListRemove>
    1b3e:	8c 89       	ldd	r24, Y+20	; 0x14
    1b40:	9d 89       	ldd	r25, Y+21	; 0x15
    1b42:	89 2b       	or	r24, r25
    1b44:	21 f0       	breq	.+8      	; 0x1b4e <xTaskIncrementTick+0xd8>
    1b46:	ce 01       	movw	r24, r28
    1b48:	0c 96       	adiw	r24, 0x0c	; 12
    1b4a:	0e 94 6e 07 	call	0xedc	; 0xedc <uxListRemove>
    1b4e:	8e 89       	ldd	r24, Y+22	; 0x16
    1b50:	90 91 24 07 	lds	r25, 0x0724	; 0x800724 <uxTopReadyPriority>
    1b54:	98 17       	cp	r25, r24
    1b56:	10 f4       	brcc	.+4      	; 0x1b5c <xTaskIncrementTick+0xe6>
    1b58:	80 93 24 07 	sts	0x0724, r24	; 0x800724 <uxTopReadyPriority>
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	9c 01       	movw	r18, r24
    1b60:	22 0f       	add	r18, r18
    1b62:	33 1f       	adc	r19, r19
    1b64:	22 0f       	add	r18, r18
    1b66:	33 1f       	adc	r19, r19
    1b68:	22 0f       	add	r18, r18
    1b6a:	33 1f       	adc	r19, r19
    1b6c:	82 0f       	add	r24, r18
    1b6e:	93 1f       	adc	r25, r19
    1b70:	b8 01       	movw	r22, r16
    1b72:	86 5a       	subi	r24, 0xA6	; 166
    1b74:	98 4f       	sbci	r25, 0xF8	; 248
    1b76:	0e 94 1c 07 	call	0xe38	; 0xe38 <vListInsertEnd>
    1b7a:	e0 91 7e 07 	lds	r30, 0x077E	; 0x80077e <pxCurrentTCB>
    1b7e:	f0 91 7f 07 	lds	r31, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    1b82:	9e 89       	ldd	r25, Y+22	; 0x16
    1b84:	86 89       	ldd	r24, Z+22	; 0x16
    1b86:	98 17       	cp	r25, r24
    1b88:	08 f4       	brcc	.+2      	; 0x1b8c <xTaskIncrementTick+0x116>
    1b8a:	b2 cf       	rjmp	.-156    	; 0x1af0 <xTaskIncrementTick+0x7a>
    1b8c:	dc 2c       	mov	r13, r12
    1b8e:	b0 cf       	rjmp	.-160    	; 0x1af0 <xTaskIncrementTick+0x7a>
    1b90:	e0 91 7e 07 	lds	r30, 0x077E	; 0x80077e <pxCurrentTCB>
    1b94:	f0 91 7f 07 	lds	r31, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    1b98:	86 89       	ldd	r24, Z+22	; 0x16
    1b9a:	90 e0       	ldi	r25, 0x00	; 0
    1b9c:	fc 01       	movw	r30, r24
    1b9e:	ee 0f       	add	r30, r30
    1ba0:	ff 1f       	adc	r31, r31
    1ba2:	ee 0f       	add	r30, r30
    1ba4:	ff 1f       	adc	r31, r31
    1ba6:	ee 0f       	add	r30, r30
    1ba8:	ff 1f       	adc	r31, r31
    1baa:	8e 0f       	add	r24, r30
    1bac:	9f 1f       	adc	r25, r31
    1bae:	fc 01       	movw	r30, r24
    1bb0:	e6 5a       	subi	r30, 0xA6	; 166
    1bb2:	f8 4f       	sbci	r31, 0xF8	; 248
    1bb4:	80 81       	ld	r24, Z
    1bb6:	82 30       	cpi	r24, 0x02	; 2
    1bb8:	48 f0       	brcs	.+18     	; 0x1bcc <xTaskIncrementTick+0x156>
    1bba:	dd 24       	eor	r13, r13
    1bbc:	d3 94       	inc	r13
    1bbe:	06 c0       	rjmp	.+12     	; 0x1bcc <xTaskIncrementTick+0x156>
    1bc0:	80 91 22 07 	lds	r24, 0x0722	; 0x800722 <uxPendedTicks>
    1bc4:	8f 5f       	subi	r24, 0xFF	; 255
    1bc6:	80 93 22 07 	sts	0x0722, r24	; 0x800722 <uxPendedTicks>
    1bca:	d1 2c       	mov	r13, r1
    1bcc:	80 91 21 07 	lds	r24, 0x0721	; 0x800721 <xYieldPending>
    1bd0:	88 23       	and	r24, r24
    1bd2:	11 f0       	breq	.+4      	; 0x1bd8 <xTaskIncrementTick+0x162>
    1bd4:	dd 24       	eor	r13, r13
    1bd6:	d3 94       	inc	r13
    1bd8:	8d 2d       	mov	r24, r13
    1bda:	df 91       	pop	r29
    1bdc:	cf 91       	pop	r28
    1bde:	1f 91       	pop	r17
    1be0:	0f 91       	pop	r16
    1be2:	ff 90       	pop	r15
    1be4:	ef 90       	pop	r14
    1be6:	df 90       	pop	r13
    1be8:	cf 90       	pop	r12
    1bea:	08 95       	ret

00001bec <xTaskResumeAll>:
    1bec:	df 92       	push	r13
    1bee:	ef 92       	push	r14
    1bf0:	ff 92       	push	r15
    1bf2:	0f 93       	push	r16
    1bf4:	1f 93       	push	r17
    1bf6:	cf 93       	push	r28
    1bf8:	df 93       	push	r29
    1bfa:	0f b6       	in	r0, 0x3f	; 63
    1bfc:	f8 94       	cli
    1bfe:	0f 92       	push	r0
    1c00:	80 91 1a 07 	lds	r24, 0x071A	; 0x80071a <uxSchedulerSuspended>
    1c04:	81 50       	subi	r24, 0x01	; 1
    1c06:	80 93 1a 07 	sts	0x071A, r24	; 0x80071a <uxSchedulerSuspended>
    1c0a:	80 91 1a 07 	lds	r24, 0x071A	; 0x80071a <uxSchedulerSuspended>
    1c0e:	81 11       	cpse	r24, r1
    1c10:	5f c0       	rjmp	.+190    	; 0x1cd0 <xTaskResumeAll+0xe4>
    1c12:	80 91 27 07 	lds	r24, 0x0727	; 0x800727 <uxCurrentNumberOfTasks>
    1c16:	81 11       	cpse	r24, r1
    1c18:	33 c0       	rjmp	.+102    	; 0x1c80 <xTaskResumeAll+0x94>
    1c1a:	5d c0       	rjmp	.+186    	; 0x1cd6 <xTaskResumeAll+0xea>
    1c1c:	d7 01       	movw	r26, r14
    1c1e:	15 96       	adiw	r26, 0x05	; 5
    1c20:	ed 91       	ld	r30, X+
    1c22:	fc 91       	ld	r31, X
    1c24:	16 97       	sbiw	r26, 0x06	; 6
    1c26:	c6 81       	ldd	r28, Z+6	; 0x06
    1c28:	d7 81       	ldd	r29, Z+7	; 0x07
    1c2a:	ce 01       	movw	r24, r28
    1c2c:	0c 96       	adiw	r24, 0x0c	; 12
    1c2e:	0e 94 6e 07 	call	0xedc	; 0xedc <uxListRemove>
    1c32:	8e 01       	movw	r16, r28
    1c34:	0e 5f       	subi	r16, 0xFE	; 254
    1c36:	1f 4f       	sbci	r17, 0xFF	; 255
    1c38:	c8 01       	movw	r24, r16
    1c3a:	0e 94 6e 07 	call	0xedc	; 0xedc <uxListRemove>
    1c3e:	8e 89       	ldd	r24, Y+22	; 0x16
    1c40:	90 91 24 07 	lds	r25, 0x0724	; 0x800724 <uxTopReadyPriority>
    1c44:	98 17       	cp	r25, r24
    1c46:	10 f4       	brcc	.+4      	; 0x1c4c <xTaskResumeAll+0x60>
    1c48:	80 93 24 07 	sts	0x0724, r24	; 0x800724 <uxTopReadyPriority>
    1c4c:	90 e0       	ldi	r25, 0x00	; 0
    1c4e:	9c 01       	movw	r18, r24
    1c50:	22 0f       	add	r18, r18
    1c52:	33 1f       	adc	r19, r19
    1c54:	22 0f       	add	r18, r18
    1c56:	33 1f       	adc	r19, r19
    1c58:	22 0f       	add	r18, r18
    1c5a:	33 1f       	adc	r19, r19
    1c5c:	82 0f       	add	r24, r18
    1c5e:	93 1f       	adc	r25, r19
    1c60:	b8 01       	movw	r22, r16
    1c62:	86 5a       	subi	r24, 0xA6	; 166
    1c64:	98 4f       	sbci	r25, 0xF8	; 248
    1c66:	0e 94 1c 07 	call	0xe38	; 0xe38 <vListInsertEnd>
    1c6a:	e0 91 7e 07 	lds	r30, 0x077E	; 0x80077e <pxCurrentTCB>
    1c6e:	f0 91 7f 07 	lds	r31, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    1c72:	9e 89       	ldd	r25, Y+22	; 0x16
    1c74:	86 89       	ldd	r24, Z+22	; 0x16
    1c76:	98 17       	cp	r25, r24
    1c78:	68 f0       	brcs	.+26     	; 0x1c94 <xTaskResumeAll+0xa8>
    1c7a:	d0 92 21 07 	sts	0x0721, r13	; 0x800721 <xYieldPending>
    1c7e:	0a c0       	rjmp	.+20     	; 0x1c94 <xTaskResumeAll+0xa8>
    1c80:	c0 e0       	ldi	r28, 0x00	; 0
    1c82:	d0 e0       	ldi	r29, 0x00	; 0
    1c84:	0f 2e       	mov	r0, r31
    1c86:	fb e3       	ldi	r31, 0x3B	; 59
    1c88:	ef 2e       	mov	r14, r31
    1c8a:	f7 e0       	ldi	r31, 0x07	; 7
    1c8c:	ff 2e       	mov	r15, r31
    1c8e:	f0 2d       	mov	r31, r0
    1c90:	dd 24       	eor	r13, r13
    1c92:	d3 94       	inc	r13
    1c94:	f7 01       	movw	r30, r14
    1c96:	80 81       	ld	r24, Z
    1c98:	81 11       	cpse	r24, r1
    1c9a:	c0 cf       	rjmp	.-128    	; 0x1c1c <xTaskResumeAll+0x30>
    1c9c:	cd 2b       	or	r28, r29
    1c9e:	11 f0       	breq	.+4      	; 0x1ca4 <xTaskResumeAll+0xb8>
    1ca0:	0e 94 56 0b 	call	0x16ac	; 0x16ac <prvResetNextTaskUnblockTime>
    1ca4:	c0 91 22 07 	lds	r28, 0x0722	; 0x800722 <uxPendedTicks>
    1ca8:	cc 23       	and	r28, r28
    1caa:	51 f0       	breq	.+20     	; 0x1cc0 <xTaskResumeAll+0xd4>
    1cac:	d1 e0       	ldi	r29, 0x01	; 1
    1cae:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <xTaskIncrementTick>
    1cb2:	81 11       	cpse	r24, r1
    1cb4:	d0 93 21 07 	sts	0x0721, r29	; 0x800721 <xYieldPending>
    1cb8:	c1 50       	subi	r28, 0x01	; 1
    1cba:	c9 f7       	brne	.-14     	; 0x1cae <xTaskResumeAll+0xc2>
    1cbc:	10 92 22 07 	sts	0x0722, r1	; 0x800722 <uxPendedTicks>
    1cc0:	80 91 21 07 	lds	r24, 0x0721	; 0x800721 <xYieldPending>
    1cc4:	88 23       	and	r24, r24
    1cc6:	31 f0       	breq	.+12     	; 0x1cd4 <xTaskResumeAll+0xe8>
    1cc8:	0e 94 36 08 	call	0x106c	; 0x106c <vPortYield>
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	03 c0       	rjmp	.+6      	; 0x1cd6 <xTaskResumeAll+0xea>
    1cd0:	80 e0       	ldi	r24, 0x00	; 0
    1cd2:	01 c0       	rjmp	.+2      	; 0x1cd6 <xTaskResumeAll+0xea>
    1cd4:	80 e0       	ldi	r24, 0x00	; 0
    1cd6:	0f 90       	pop	r0
    1cd8:	0f be       	out	0x3f, r0	; 63
    1cda:	df 91       	pop	r29
    1cdc:	cf 91       	pop	r28
    1cde:	1f 91       	pop	r17
    1ce0:	0f 91       	pop	r16
    1ce2:	ff 90       	pop	r15
    1ce4:	ef 90       	pop	r14
    1ce6:	df 90       	pop	r13
    1ce8:	08 95       	ret

00001cea <vTaskDelay>:
    1cea:	cf 93       	push	r28
    1cec:	df 93       	push	r29
    1cee:	ec 01       	movw	r28, r24
    1cf0:	89 2b       	or	r24, r25
    1cf2:	51 f0       	breq	.+20     	; 0x1d08 <vTaskDelay+0x1e>
    1cf4:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <vTaskSuspendAll>
    1cf8:	60 e0       	ldi	r22, 0x00	; 0
    1cfa:	ce 01       	movw	r24, r28
    1cfc:	0e 94 a1 0b 	call	0x1742	; 0x1742 <prvAddCurrentTaskToDelayedList>
    1d00:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <xTaskResumeAll>
    1d04:	81 11       	cpse	r24, r1
    1d06:	02 c0       	rjmp	.+4      	; 0x1d0c <vTaskDelay+0x22>
    1d08:	0e 94 36 08 	call	0x106c	; 0x106c <vPortYield>
    1d0c:	df 91       	pop	r29
    1d0e:	cf 91       	pop	r28
    1d10:	08 95       	ret

00001d12 <vTaskSwitchContext>:
    1d12:	80 91 1a 07 	lds	r24, 0x071A	; 0x80071a <uxSchedulerSuspended>
    1d16:	88 23       	and	r24, r24
    1d18:	21 f0       	breq	.+8      	; 0x1d22 <vTaskSwitchContext+0x10>
    1d1a:	81 e0       	ldi	r24, 0x01	; 1
    1d1c:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <xYieldPending>
    1d20:	08 95       	ret
    1d22:	10 92 21 07 	sts	0x0721, r1	; 0x800721 <xYieldPending>
    1d26:	20 91 24 07 	lds	r18, 0x0724	; 0x800724 <uxTopReadyPriority>
    1d2a:	82 2f       	mov	r24, r18
    1d2c:	90 e0       	ldi	r25, 0x00	; 0
    1d2e:	fc 01       	movw	r30, r24
    1d30:	ee 0f       	add	r30, r30
    1d32:	ff 1f       	adc	r31, r31
    1d34:	ee 0f       	add	r30, r30
    1d36:	ff 1f       	adc	r31, r31
    1d38:	ee 0f       	add	r30, r30
    1d3a:	ff 1f       	adc	r31, r31
    1d3c:	e8 0f       	add	r30, r24
    1d3e:	f9 1f       	adc	r31, r25
    1d40:	e6 5a       	subi	r30, 0xA6	; 166
    1d42:	f8 4f       	sbci	r31, 0xF8	; 248
    1d44:	30 81       	ld	r19, Z
    1d46:	31 11       	cpse	r19, r1
    1d48:	11 c0       	rjmp	.+34     	; 0x1d6c <vTaskSwitchContext+0x5a>
    1d4a:	21 50       	subi	r18, 0x01	; 1
    1d4c:	82 2f       	mov	r24, r18
    1d4e:	90 e0       	ldi	r25, 0x00	; 0
    1d50:	fc 01       	movw	r30, r24
    1d52:	ee 0f       	add	r30, r30
    1d54:	ff 1f       	adc	r31, r31
    1d56:	ee 0f       	add	r30, r30
    1d58:	ff 1f       	adc	r31, r31
    1d5a:	ee 0f       	add	r30, r30
    1d5c:	ff 1f       	adc	r31, r31
    1d5e:	e8 0f       	add	r30, r24
    1d60:	f9 1f       	adc	r31, r25
    1d62:	e6 5a       	subi	r30, 0xA6	; 166
    1d64:	f8 4f       	sbci	r31, 0xF8	; 248
    1d66:	30 81       	ld	r19, Z
    1d68:	33 23       	and	r19, r19
    1d6a:	79 f3       	breq	.-34     	; 0x1d4a <vTaskSwitchContext+0x38>
    1d6c:	ac 01       	movw	r20, r24
    1d6e:	44 0f       	add	r20, r20
    1d70:	55 1f       	adc	r21, r21
    1d72:	44 0f       	add	r20, r20
    1d74:	55 1f       	adc	r21, r21
    1d76:	44 0f       	add	r20, r20
    1d78:	55 1f       	adc	r21, r21
    1d7a:	48 0f       	add	r20, r24
    1d7c:	59 1f       	adc	r21, r25
    1d7e:	da 01       	movw	r26, r20
    1d80:	a6 5a       	subi	r26, 0xA6	; 166
    1d82:	b8 4f       	sbci	r27, 0xF8	; 248
    1d84:	11 96       	adiw	r26, 0x01	; 1
    1d86:	ed 91       	ld	r30, X+
    1d88:	fc 91       	ld	r31, X
    1d8a:	12 97       	sbiw	r26, 0x02	; 2
    1d8c:	02 80       	ldd	r0, Z+2	; 0x02
    1d8e:	f3 81       	ldd	r31, Z+3	; 0x03
    1d90:	e0 2d       	mov	r30, r0
    1d92:	12 96       	adiw	r26, 0x02	; 2
    1d94:	fc 93       	st	X, r31
    1d96:	ee 93       	st	-X, r30
    1d98:	11 97       	sbiw	r26, 0x01	; 1
    1d9a:	43 5a       	subi	r20, 0xA3	; 163
    1d9c:	58 4f       	sbci	r21, 0xF8	; 248
    1d9e:	e4 17       	cp	r30, r20
    1da0:	f5 07       	cpc	r31, r21
    1da2:	29 f4       	brne	.+10     	; 0x1dae <vTaskSwitchContext+0x9c>
    1da4:	42 81       	ldd	r20, Z+2	; 0x02
    1da6:	53 81       	ldd	r21, Z+3	; 0x03
    1da8:	fd 01       	movw	r30, r26
    1daa:	52 83       	std	Z+2, r21	; 0x02
    1dac:	41 83       	std	Z+1, r20	; 0x01
    1dae:	fc 01       	movw	r30, r24
    1db0:	ee 0f       	add	r30, r30
    1db2:	ff 1f       	adc	r31, r31
    1db4:	ee 0f       	add	r30, r30
    1db6:	ff 1f       	adc	r31, r31
    1db8:	ee 0f       	add	r30, r30
    1dba:	ff 1f       	adc	r31, r31
    1dbc:	8e 0f       	add	r24, r30
    1dbe:	9f 1f       	adc	r25, r31
    1dc0:	fc 01       	movw	r30, r24
    1dc2:	e6 5a       	subi	r30, 0xA6	; 166
    1dc4:	f8 4f       	sbci	r31, 0xF8	; 248
    1dc6:	01 80       	ldd	r0, Z+1	; 0x01
    1dc8:	f2 81       	ldd	r31, Z+2	; 0x02
    1dca:	e0 2d       	mov	r30, r0
    1dcc:	86 81       	ldd	r24, Z+6	; 0x06
    1dce:	97 81       	ldd	r25, Z+7	; 0x07
    1dd0:	90 93 7f 07 	sts	0x077F, r25	; 0x80077f <pxCurrentTCB+0x1>
    1dd4:	80 93 7e 07 	sts	0x077E, r24	; 0x80077e <pxCurrentTCB>
    1dd8:	20 93 24 07 	sts	0x0724, r18	; 0x800724 <uxTopReadyPriority>
    1ddc:	08 95       	ret

00001dde <vTaskSuspend>:
    1dde:	0f 93       	push	r16
    1de0:	1f 93       	push	r17
    1de2:	cf 93       	push	r28
    1de4:	df 93       	push	r29
    1de6:	ec 01       	movw	r28, r24
    1de8:	0f b6       	in	r0, 0x3f	; 63
    1dea:	f8 94       	cli
    1dec:	0f 92       	push	r0
    1dee:	89 2b       	or	r24, r25
    1df0:	21 f4       	brne	.+8      	; 0x1dfa <vTaskSuspend+0x1c>
    1df2:	c0 91 7e 07 	lds	r28, 0x077E	; 0x80077e <pxCurrentTCB>
    1df6:	d0 91 7f 07 	lds	r29, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    1dfa:	8e 01       	movw	r16, r28
    1dfc:	0e 5f       	subi	r16, 0xFE	; 254
    1dfe:	1f 4f       	sbci	r17, 0xFF	; 255
    1e00:	c8 01       	movw	r24, r16
    1e02:	0e 94 6e 07 	call	0xedc	; 0xedc <uxListRemove>
    1e06:	8c 89       	ldd	r24, Y+20	; 0x14
    1e08:	9d 89       	ldd	r25, Y+21	; 0x15
    1e0a:	89 2b       	or	r24, r25
    1e0c:	21 f0       	breq	.+8      	; 0x1e16 <vTaskSuspend+0x38>
    1e0e:	ce 01       	movw	r24, r28
    1e10:	0c 96       	adiw	r24, 0x0c	; 12
    1e12:	0e 94 6e 07 	call	0xedc	; 0xedc <uxListRemove>
    1e16:	b8 01       	movw	r22, r16
    1e18:	88 e2       	ldi	r24, 0x28	; 40
    1e1a:	97 e0       	ldi	r25, 0x07	; 7
    1e1c:	0e 94 1c 07 	call	0xe38	; 0xe38 <vListInsertEnd>
    1e20:	8d a1       	ldd	r24, Y+37	; 0x25
    1e22:	81 30       	cpi	r24, 0x01	; 1
    1e24:	09 f4       	brne	.+2      	; 0x1e28 <vTaskSuspend+0x4a>
    1e26:	1d a2       	std	Y+37, r1	; 0x25
    1e28:	0f 90       	pop	r0
    1e2a:	0f be       	out	0x3f, r0	; 63
    1e2c:	80 91 23 07 	lds	r24, 0x0723	; 0x800723 <xSchedulerRunning>
    1e30:	88 23       	and	r24, r24
    1e32:	39 f0       	breq	.+14     	; 0x1e42 <vTaskSuspend+0x64>
    1e34:	0f b6       	in	r0, 0x3f	; 63
    1e36:	f8 94       	cli
    1e38:	0f 92       	push	r0
    1e3a:	0e 94 56 0b 	call	0x16ac	; 0x16ac <prvResetNextTaskUnblockTime>
    1e3e:	0f 90       	pop	r0
    1e40:	0f be       	out	0x3f, r0	; 63
    1e42:	80 91 7e 07 	lds	r24, 0x077E	; 0x80077e <pxCurrentTCB>
    1e46:	90 91 7f 07 	lds	r25, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    1e4a:	c8 17       	cp	r28, r24
    1e4c:	d9 07       	cpc	r29, r25
    1e4e:	a1 f4       	brne	.+40     	; 0x1e78 <vTaskSuspend+0x9a>
    1e50:	80 91 23 07 	lds	r24, 0x0723	; 0x800723 <xSchedulerRunning>
    1e54:	88 23       	and	r24, r24
    1e56:	19 f0       	breq	.+6      	; 0x1e5e <vTaskSuspend+0x80>
    1e58:	0e 94 36 08 	call	0x106c	; 0x106c <vPortYield>
    1e5c:	0d c0       	rjmp	.+26     	; 0x1e78 <vTaskSuspend+0x9a>
    1e5e:	90 91 28 07 	lds	r25, 0x0728	; 0x800728 <xSuspendedTaskList>
    1e62:	80 91 27 07 	lds	r24, 0x0727	; 0x800727 <uxCurrentNumberOfTasks>
    1e66:	98 13       	cpse	r25, r24
    1e68:	05 c0       	rjmp	.+10     	; 0x1e74 <vTaskSuspend+0x96>
    1e6a:	10 92 7f 07 	sts	0x077F, r1	; 0x80077f <pxCurrentTCB+0x1>
    1e6e:	10 92 7e 07 	sts	0x077E, r1	; 0x80077e <pxCurrentTCB>
    1e72:	02 c0       	rjmp	.+4      	; 0x1e78 <vTaskSuspend+0x9a>
    1e74:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <vTaskSwitchContext>
    1e78:	df 91       	pop	r29
    1e7a:	cf 91       	pop	r28
    1e7c:	1f 91       	pop	r17
    1e7e:	0f 91       	pop	r16
    1e80:	08 95       	ret

00001e82 <vTaskPlaceOnEventList>:
    1e82:	cf 93       	push	r28
    1e84:	df 93       	push	r29
    1e86:	eb 01       	movw	r28, r22
    1e88:	60 91 7e 07 	lds	r22, 0x077E	; 0x80077e <pxCurrentTCB>
    1e8c:	70 91 7f 07 	lds	r23, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    1e90:	64 5f       	subi	r22, 0xF4	; 244
    1e92:	7f 4f       	sbci	r23, 0xFF	; 255
    1e94:	0e 94 3d 07 	call	0xe7a	; 0xe7a <vListInsert>
    1e98:	61 e0       	ldi	r22, 0x01	; 1
    1e9a:	ce 01       	movw	r24, r28
    1e9c:	0e 94 a1 0b 	call	0x1742	; 0x1742 <prvAddCurrentTaskToDelayedList>
    1ea0:	df 91       	pop	r29
    1ea2:	cf 91       	pop	r28
    1ea4:	08 95       	ret

00001ea6 <xTaskRemoveFromEventList>:
    1ea6:	0f 93       	push	r16
    1ea8:	1f 93       	push	r17
    1eaa:	cf 93       	push	r28
    1eac:	df 93       	push	r29
    1eae:	dc 01       	movw	r26, r24
    1eb0:	15 96       	adiw	r26, 0x05	; 5
    1eb2:	ed 91       	ld	r30, X+
    1eb4:	fc 91       	ld	r31, X
    1eb6:	16 97       	sbiw	r26, 0x06	; 6
    1eb8:	c6 81       	ldd	r28, Z+6	; 0x06
    1eba:	d7 81       	ldd	r29, Z+7	; 0x07
    1ebc:	8e 01       	movw	r16, r28
    1ebe:	04 5f       	subi	r16, 0xF4	; 244
    1ec0:	1f 4f       	sbci	r17, 0xFF	; 255
    1ec2:	c8 01       	movw	r24, r16
    1ec4:	0e 94 6e 07 	call	0xedc	; 0xedc <uxListRemove>
    1ec8:	80 91 1a 07 	lds	r24, 0x071A	; 0x80071a <uxSchedulerSuspended>
    1ecc:	81 11       	cpse	r24, r1
    1ece:	1c c0       	rjmp	.+56     	; 0x1f08 <xTaskRemoveFromEventList+0x62>
    1ed0:	0a 50       	subi	r16, 0x0A	; 10
    1ed2:	11 09       	sbc	r17, r1
    1ed4:	c8 01       	movw	r24, r16
    1ed6:	0e 94 6e 07 	call	0xedc	; 0xedc <uxListRemove>
    1eda:	8e 89       	ldd	r24, Y+22	; 0x16
    1edc:	90 91 24 07 	lds	r25, 0x0724	; 0x800724 <uxTopReadyPriority>
    1ee0:	98 17       	cp	r25, r24
    1ee2:	10 f4       	brcc	.+4      	; 0x1ee8 <xTaskRemoveFromEventList+0x42>
    1ee4:	80 93 24 07 	sts	0x0724, r24	; 0x800724 <uxTopReadyPriority>
    1ee8:	90 e0       	ldi	r25, 0x00	; 0
    1eea:	9c 01       	movw	r18, r24
    1eec:	22 0f       	add	r18, r18
    1eee:	33 1f       	adc	r19, r19
    1ef0:	22 0f       	add	r18, r18
    1ef2:	33 1f       	adc	r19, r19
    1ef4:	22 0f       	add	r18, r18
    1ef6:	33 1f       	adc	r19, r19
    1ef8:	82 0f       	add	r24, r18
    1efa:	93 1f       	adc	r25, r19
    1efc:	b8 01       	movw	r22, r16
    1efe:	86 5a       	subi	r24, 0xA6	; 166
    1f00:	98 4f       	sbci	r25, 0xF8	; 248
    1f02:	0e 94 1c 07 	call	0xe38	; 0xe38 <vListInsertEnd>
    1f06:	05 c0       	rjmp	.+10     	; 0x1f12 <xTaskRemoveFromEventList+0x6c>
    1f08:	b8 01       	movw	r22, r16
    1f0a:	8b e3       	ldi	r24, 0x3B	; 59
    1f0c:	97 e0       	ldi	r25, 0x07	; 7
    1f0e:	0e 94 1c 07 	call	0xe38	; 0xe38 <vListInsertEnd>
    1f12:	e0 91 7e 07 	lds	r30, 0x077E	; 0x80077e <pxCurrentTCB>
    1f16:	f0 91 7f 07 	lds	r31, 0x077F	; 0x80077f <pxCurrentTCB+0x1>
    1f1a:	9e 89       	ldd	r25, Y+22	; 0x16
    1f1c:	86 89       	ldd	r24, Z+22	; 0x16
    1f1e:	89 17       	cp	r24, r25
    1f20:	20 f4       	brcc	.+8      	; 0x1f2a <xTaskRemoveFromEventList+0x84>
    1f22:	81 e0       	ldi	r24, 0x01	; 1
    1f24:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <xYieldPending>
    1f28:	01 c0       	rjmp	.+2      	; 0x1f2c <xTaskRemoveFromEventList+0x86>
    1f2a:	80 e0       	ldi	r24, 0x00	; 0
    1f2c:	df 91       	pop	r29
    1f2e:	cf 91       	pop	r28
    1f30:	1f 91       	pop	r17
    1f32:	0f 91       	pop	r16
    1f34:	08 95       	ret

00001f36 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1f36:	20 91 20 07 	lds	r18, 0x0720	; 0x800720 <xNumOfOverflows>
    1f3a:	fc 01       	movw	r30, r24
    1f3c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1f3e:	20 91 25 07 	lds	r18, 0x0725	; 0x800725 <xTickCount>
    1f42:	30 91 26 07 	lds	r19, 0x0726	; 0x800726 <xTickCount+0x1>
    1f46:	32 83       	std	Z+2, r19	; 0x02
    1f48:	21 83       	std	Z+1, r18	; 0x01
    1f4a:	08 95       	ret

00001f4c <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1f4c:	cf 93       	push	r28
    1f4e:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1f50:	0f b6       	in	r0, 0x3f	; 63
    1f52:	f8 94       	cli
    1f54:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1f56:	20 91 25 07 	lds	r18, 0x0725	; 0x800725 <xTickCount>
    1f5a:	30 91 26 07 	lds	r19, 0x0726	; 0x800726 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    1f5e:	db 01       	movw	r26, r22
    1f60:	4d 91       	ld	r20, X+
    1f62:	5c 91       	ld	r21, X
    1f64:	4f 3f       	cpi	r20, 0xFF	; 255
    1f66:	bf ef       	ldi	r27, 0xFF	; 255
    1f68:	5b 07       	cpc	r21, r27
    1f6a:	f1 f0       	breq	.+60     	; 0x1fa8 <xTaskCheckForTimeOut+0x5c>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1f6c:	ec 01       	movw	r28, r24
    1f6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1f70:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1f72:	a0 91 20 07 	lds	r26, 0x0720	; 0x800720 <xNumOfOverflows>
    1f76:	b8 81       	ld	r27, Y
    1f78:	ba 17       	cp	r27, r26
    1f7a:	19 f0       	breq	.+6      	; 0x1f82 <xTaskCheckForTimeOut+0x36>
    1f7c:	2e 17       	cp	r18, r30
    1f7e:	3f 07       	cpc	r19, r31
    1f80:	a8 f4       	brcc	.+42     	; 0x1fac <xTaskCheckForTimeOut+0x60>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1f82:	2e 1b       	sub	r18, r30
    1f84:	3f 0b       	sbc	r19, r31
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1f86:	24 17       	cp	r18, r20
    1f88:	35 07       	cpc	r19, r21
    1f8a:	48 f4       	brcc	.+18     	; 0x1f9e <xTaskCheckForTimeOut+0x52>
    1f8c:	fb 01       	movw	r30, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    1f8e:	42 1b       	sub	r20, r18
    1f90:	53 0b       	sbc	r21, r19
    1f92:	51 83       	std	Z+1, r21	; 0x01
    1f94:	40 83       	st	Z, r20
			vTaskInternalSetTimeOutState( pxTimeOut );
    1f96:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    1f9a:	80 e0       	ldi	r24, 0x00	; 0
    1f9c:	08 c0       	rjmp	.+16     	; 0x1fae <xTaskCheckForTimeOut+0x62>
		}
		else
		{
			*pxTicksToWait = 0;
    1f9e:	fb 01       	movw	r30, r22
    1fa0:	11 82       	std	Z+1, r1	; 0x01
    1fa2:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    1fa4:	81 e0       	ldi	r24, 0x01	; 1
    1fa6:	03 c0       	rjmp	.+6      	; 0x1fae <xTaskCheckForTimeOut+0x62>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    1fa8:	80 e0       	ldi	r24, 0x00	; 0
    1faa:	01 c0       	rjmp	.+2      	; 0x1fae <xTaskCheckForTimeOut+0x62>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1fac:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    1fae:	0f 90       	pop	r0
    1fb0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1fb2:	df 91       	pop	r29
    1fb4:	cf 91       	pop	r28
    1fb6:	08 95       	ret

00001fb8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1fb8:	81 e0       	ldi	r24, 0x01	; 1
    1fba:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <xYieldPending>
    1fbe:	08 95       	ret

00001fc0 <__mulsi3>:
    1fc0:	db 01       	movw	r26, r22
    1fc2:	8f 93       	push	r24
    1fc4:	9f 93       	push	r25
    1fc6:	0e 94 0f 10 	call	0x201e	; 0x201e <__muluhisi3>
    1fca:	bf 91       	pop	r27
    1fcc:	af 91       	pop	r26
    1fce:	a2 9f       	mul	r26, r18
    1fd0:	80 0d       	add	r24, r0
    1fd2:	91 1d       	adc	r25, r1
    1fd4:	a3 9f       	mul	r26, r19
    1fd6:	90 0d       	add	r25, r0
    1fd8:	b2 9f       	mul	r27, r18
    1fda:	90 0d       	add	r25, r0
    1fdc:	11 24       	eor	r1, r1
    1fde:	08 95       	ret

00001fe0 <__divmodsi4>:
    1fe0:	05 2e       	mov	r0, r21
    1fe2:	97 fb       	bst	r25, 7
    1fe4:	1e f4       	brtc	.+6      	; 0x1fec <__divmodsi4+0xc>
    1fe6:	00 94       	com	r0
    1fe8:	0e 94 07 10 	call	0x200e	; 0x200e <__negsi2>
    1fec:	57 fd       	sbrc	r21, 7
    1fee:	07 d0       	rcall	.+14     	; 0x1ffe <__divmodsi4_neg2>
    1ff0:	0e 94 1a 10 	call	0x2034	; 0x2034 <__udivmodsi4>
    1ff4:	07 fc       	sbrc	r0, 7
    1ff6:	03 d0       	rcall	.+6      	; 0x1ffe <__divmodsi4_neg2>
    1ff8:	4e f4       	brtc	.+18     	; 0x200c <__divmodsi4_exit>
    1ffa:	0c 94 07 10 	jmp	0x200e	; 0x200e <__negsi2>

00001ffe <__divmodsi4_neg2>:
    1ffe:	50 95       	com	r21
    2000:	40 95       	com	r20
    2002:	30 95       	com	r19
    2004:	21 95       	neg	r18
    2006:	3f 4f       	sbci	r19, 0xFF	; 255
    2008:	4f 4f       	sbci	r20, 0xFF	; 255
    200a:	5f 4f       	sbci	r21, 0xFF	; 255

0000200c <__divmodsi4_exit>:
    200c:	08 95       	ret

0000200e <__negsi2>:
    200e:	90 95       	com	r25
    2010:	80 95       	com	r24
    2012:	70 95       	com	r23
    2014:	61 95       	neg	r22
    2016:	7f 4f       	sbci	r23, 0xFF	; 255
    2018:	8f 4f       	sbci	r24, 0xFF	; 255
    201a:	9f 4f       	sbci	r25, 0xFF	; 255
    201c:	08 95       	ret

0000201e <__muluhisi3>:
    201e:	0e 94 3c 10 	call	0x2078	; 0x2078 <__umulhisi3>
    2022:	a5 9f       	mul	r26, r21
    2024:	90 0d       	add	r25, r0
    2026:	b4 9f       	mul	r27, r20
    2028:	90 0d       	add	r25, r0
    202a:	a4 9f       	mul	r26, r20
    202c:	80 0d       	add	r24, r0
    202e:	91 1d       	adc	r25, r1
    2030:	11 24       	eor	r1, r1
    2032:	08 95       	ret

00002034 <__udivmodsi4>:
    2034:	a1 e2       	ldi	r26, 0x21	; 33
    2036:	1a 2e       	mov	r1, r26
    2038:	aa 1b       	sub	r26, r26
    203a:	bb 1b       	sub	r27, r27
    203c:	fd 01       	movw	r30, r26
    203e:	0d c0       	rjmp	.+26     	; 0x205a <__udivmodsi4_ep>

00002040 <__udivmodsi4_loop>:
    2040:	aa 1f       	adc	r26, r26
    2042:	bb 1f       	adc	r27, r27
    2044:	ee 1f       	adc	r30, r30
    2046:	ff 1f       	adc	r31, r31
    2048:	a2 17       	cp	r26, r18
    204a:	b3 07       	cpc	r27, r19
    204c:	e4 07       	cpc	r30, r20
    204e:	f5 07       	cpc	r31, r21
    2050:	20 f0       	brcs	.+8      	; 0x205a <__udivmodsi4_ep>
    2052:	a2 1b       	sub	r26, r18
    2054:	b3 0b       	sbc	r27, r19
    2056:	e4 0b       	sbc	r30, r20
    2058:	f5 0b       	sbc	r31, r21

0000205a <__udivmodsi4_ep>:
    205a:	66 1f       	adc	r22, r22
    205c:	77 1f       	adc	r23, r23
    205e:	88 1f       	adc	r24, r24
    2060:	99 1f       	adc	r25, r25
    2062:	1a 94       	dec	r1
    2064:	69 f7       	brne	.-38     	; 0x2040 <__udivmodsi4_loop>
    2066:	60 95       	com	r22
    2068:	70 95       	com	r23
    206a:	80 95       	com	r24
    206c:	90 95       	com	r25
    206e:	9b 01       	movw	r18, r22
    2070:	ac 01       	movw	r20, r24
    2072:	bd 01       	movw	r22, r26
    2074:	cf 01       	movw	r24, r30
    2076:	08 95       	ret

00002078 <__umulhisi3>:
    2078:	a2 9f       	mul	r26, r18
    207a:	b0 01       	movw	r22, r0
    207c:	b3 9f       	mul	r27, r19
    207e:	c0 01       	movw	r24, r0
    2080:	a3 9f       	mul	r26, r19
    2082:	70 0d       	add	r23, r0
    2084:	81 1d       	adc	r24, r1
    2086:	11 24       	eor	r1, r1
    2088:	91 1d       	adc	r25, r1
    208a:	b2 9f       	mul	r27, r18
    208c:	70 0d       	add	r23, r0
    208e:	81 1d       	adc	r24, r1
    2090:	11 24       	eor	r1, r1
    2092:	91 1d       	adc	r25, r1
    2094:	08 95       	ret

00002096 <memcpy>:
    2096:	fb 01       	movw	r30, r22
    2098:	dc 01       	movw	r26, r24
    209a:	02 c0       	rjmp	.+4      	; 0x20a0 <memcpy+0xa>
    209c:	01 90       	ld	r0, Z+
    209e:	0d 92       	st	X+, r0
    20a0:	41 50       	subi	r20, 0x01	; 1
    20a2:	50 40       	sbci	r21, 0x00	; 0
    20a4:	d8 f7       	brcc	.-10     	; 0x209c <memcpy+0x6>
    20a6:	08 95       	ret

000020a8 <_exit>:
    20a8:	f8 94       	cli

000020aa <__stop_program>:
    20aa:	ff cf       	rjmp	.-2      	; 0x20aa <__stop_program>
