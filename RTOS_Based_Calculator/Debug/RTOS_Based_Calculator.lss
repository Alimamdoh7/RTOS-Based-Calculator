
RTOS_Based_Calculator.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002516  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000082  00800060  00002516  000025aa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006de  008000e2  008000e2  0000262c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000262c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000265c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000460  00000000  00000000  00002698  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005642  00000000  00000000  00002af8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000160c  00000000  00000000  0000813a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002fd7  00000000  00000000  00009746  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000cd0  00000000  00000000  0000c720  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000168d  00000000  00000000  0000d3f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004ea7  00000000  00000000  0000ea7d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000458  00000000  00000000  00013924  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 d4 09 	jmp	0x13a8	; 0x13a8 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e1       	ldi	r30, 0x16	; 22
      68:	f5 e2       	ldi	r31, 0x25	; 37
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 3e       	cpi	r26, 0xE2	; 226
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	a2 ee       	ldi	r26, 0xE2	; 226
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a0 3c       	cpi	r26, 0xC0	; 192
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 83 04 	call	0x906	; 0x906 <main>
      8a:	0c 94 89 12 	jmp	0x2512	; 0x2512 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Tasks_Init>:
	LCD_GoTo(0,0);
	LCD_WriteString("Made By:");
	LCD_GoTo(1,0);
	LCD_WriteString("Ali Mamdoh");
	_delay_ms(2000);
	LCD_Clear();
      92:	0e 94 3a 07 	call	0xe74	; 0xe74 <PORT_Init>
      96:	0e 94 34 05 	call	0xa68	; 0xa68 <LCD_Init>
      9a:	0e 94 86 04 	call	0x90c	; 0x90c <KeyPad_Init>
      9e:	60 e0       	ldi	r22, 0x00	; 0
      a0:	80 e0       	ldi	r24, 0x00	; 0
      a2:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <LCD_GoTo>
      a6:	84 e8       	ldi	r24, 0x84	; 132
      a8:	90 e0       	ldi	r25, 0x00	; 0
      aa:	0e 94 ae 05 	call	0xb5c	; 0xb5c <LCD_WriteString>
      ae:	2f ef       	ldi	r18, 0xFF	; 255
      b0:	87 ea       	ldi	r24, 0xA7	; 167
      b2:	91 e6       	ldi	r25, 0x61	; 97
      b4:	21 50       	subi	r18, 0x01	; 1
      b6:	80 40       	sbci	r24, 0x00	; 0
      b8:	90 40       	sbci	r25, 0x00	; 0
      ba:	e1 f7       	brne	.-8      	; 0xb4 <Tasks_Init+0x22>
      bc:	00 c0       	rjmp	.+0      	; 0xbe <Tasks_Init+0x2c>
      be:	00 00       	nop
      c0:	0e 94 76 06 	call	0xcec	; 0xcec <LCD_Clear>
      c4:	60 e0       	ldi	r22, 0x00	; 0
      c6:	80 e0       	ldi	r24, 0x00	; 0
      c8:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <LCD_GoTo>
      cc:	8f e8       	ldi	r24, 0x8F	; 143
      ce:	90 e0       	ldi	r25, 0x00	; 0
      d0:	0e 94 ae 05 	call	0xb5c	; 0xb5c <LCD_WriteString>
      d4:	60 e0       	ldi	r22, 0x00	; 0
      d6:	81 e0       	ldi	r24, 0x01	; 1
      d8:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <LCD_GoTo>
      dc:	88 e9       	ldi	r24, 0x98	; 152
      de:	90 e0       	ldi	r25, 0x00	; 0
      e0:	0e 94 ae 05 	call	0xb5c	; 0xb5c <LCD_WriteString>
      e4:	2f ef       	ldi	r18, 0xFF	; 255
      e6:	87 ea       	ldi	r24, 0xA7	; 167
      e8:	91 e6       	ldi	r25, 0x61	; 97
      ea:	21 50       	subi	r18, 0x01	; 1
      ec:	80 40       	sbci	r24, 0x00	; 0
      ee:	90 40       	sbci	r25, 0x00	; 0
      f0:	e1 f7       	brne	.-8      	; 0xea <Tasks_Init+0x58>
      f2:	00 c0       	rjmp	.+0      	; 0xf4 <Tasks_Init+0x62>
      f4:	00 00       	nop
      f6:	0e 94 76 06 	call	0xcec	; 0xcec <LCD_Clear>
      fa:	40 e0       	ldi	r20, 0x00	; 0
      fc:	61 e0       	ldi	r22, 0x01	; 1
      fe:	83 e2       	ldi	r24, 0x23	; 35
     100:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <xQueueGenericCreate>
     104:	90 93 73 01 	sts	0x0173, r25	; 0x800173 <Queue1_Handle+0x1>
     108:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <Queue1_Handle>
     10c:	80 91 78 01 	lds	r24, 0x0178	; 0x800178 <Init_Task_Handle>
     110:	90 91 79 01 	lds	r25, 0x0179	; 0x800179 <Init_Task_Handle+0x1>
     114:	0e 94 d8 0f 	call	0x1fb0	; 0x1fb0 <vTaskSuspend>
     118:	bc cf       	rjmp	.-136    	; 0x92 <Tasks_Init>

0000011a <Task2_LCDDisplay>:
     11a:	cf 93       	push	r28
     11c:	df 93       	push	r29
     11e:	1f 92       	push	r1
     120:	cd b7       	in	r28, 0x3d	; 61
     122:	de b7       	in	r29, 0x3e	; 62
     124:	19 82       	std	Y+1, r1	; 0x01
     126:	07 ee       	ldi	r16, 0xE7	; 231
     128:	10 e0       	ldi	r17, 0x00	; 0
     12a:	4f ef       	ldi	r20, 0xFF	; 255
     12c:	5f ef       	ldi	r21, 0xFF	; 255
     12e:	be 01       	movw	r22, r28
     130:	6f 5f       	subi	r22, 0xFF	; 255
     132:	7f 4f       	sbci	r23, 0xFF	; 255
     134:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <Queue1_Handle>
     138:	90 91 73 01 	lds	r25, 0x0173	; 0x800173 <Queue1_Handle+0x1>
     13c:	0e 94 a6 0b 	call	0x174c	; 0x174c <xQueueReceive>
     140:	89 81       	ldd	r24, Y+1	; 0x01
     142:	88 37       	cpi	r24, 0x78	; 120
     144:	41 f0       	breq	.+16     	; 0x156 <Task2_LCDDisplay+0x3c>
     146:	91 ed       	ldi	r25, 0xD1	; 209
     148:	98 0f       	add	r25, r24
     14a:	9b 30       	cpi	r25, 0x0B	; 11
     14c:	20 f0       	brcs	.+8      	; 0x156 <Task2_LCDDisplay+0x3c>
     14e:	8b 32       	cpi	r24, 0x2B	; 43
     150:	11 f0       	breq	.+4      	; 0x156 <Task2_LCDDisplay+0x3c>
     152:	8d 32       	cpi	r24, 0x2D	; 45
     154:	19 f4       	brne	.+6      	; 0x15c <Task2_LCDDisplay+0x42>
     156:	0e 94 50 05 	call	0xaa0	; 0xaa0 <LCD_WriteChar>
     15a:	34 c0       	rjmp	.+104    	; 0x1c4 <Task2_LCDDisplay+0xaa>
     15c:	8d 33       	cpi	r24, 0x3D	; 61
     15e:	71 f5       	brne	.+92     	; 0x1bc <Task2_LCDDisplay+0xa2>
     160:	80 91 e6 00 	lds	r24, 0x00E6	; 0x8000e6 <Division_By_Zero_Flag>
     164:	81 11       	cpse	r24, r1
     166:	0f c0       	rjmp	.+30     	; 0x186 <Task2_LCDDisplay+0x6c>
     168:	8d e3       	ldi	r24, 0x3D	; 61
     16a:	0e 94 50 05 	call	0xaa0	; 0xaa0 <LCD_WriteChar>
     16e:	60 e0       	ldi	r22, 0x00	; 0
     170:	81 e0       	ldi	r24, 0x01	; 1
     172:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <LCD_GoTo>
     176:	f8 01       	movw	r30, r16
     178:	60 81       	ld	r22, Z
     17a:	71 81       	ldd	r23, Z+1	; 0x01
     17c:	82 81       	ldd	r24, Z+2	; 0x02
     17e:	93 81       	ldd	r25, Z+3	; 0x03
     180:	0e 94 ca 05 	call	0xb94	; 0xb94 <LCD_WriteInteger>
     184:	1f c0       	rjmp	.+62     	; 0x1c4 <Task2_LCDDisplay+0xaa>
     186:	81 30       	cpi	r24, 0x01	; 1
     188:	e9 f4       	brne	.+58     	; 0x1c4 <Task2_LCDDisplay+0xaa>
     18a:	8d e3       	ldi	r24, 0x3D	; 61
     18c:	0e 94 50 05 	call	0xaa0	; 0xaa0 <LCD_WriteChar>
     190:	60 e0       	ldi	r22, 0x00	; 0
     192:	81 e0       	ldi	r24, 0x01	; 1
     194:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <LCD_GoTo>
     198:	83 ea       	ldi	r24, 0xA3	; 163
     19a:	90 e0       	ldi	r25, 0x00	; 0
     19c:	0e 94 ae 05 	call	0xb5c	; 0xb5c <LCD_WriteString>
     1a0:	ff ef       	ldi	r31, 0xFF	; 255
     1a2:	27 ea       	ldi	r18, 0xA7	; 167
     1a4:	81 e6       	ldi	r24, 0x61	; 97
     1a6:	f1 50       	subi	r31, 0x01	; 1
     1a8:	20 40       	sbci	r18, 0x00	; 0
     1aa:	80 40       	sbci	r24, 0x00	; 0
     1ac:	e1 f7       	brne	.-8      	; 0x1a6 <Task2_LCDDisplay+0x8c>
     1ae:	00 c0       	rjmp	.+0      	; 0x1b0 <Task2_LCDDisplay+0x96>
     1b0:	00 00       	nop
     1b2:	0e 94 76 06 	call	0xcec	; 0xcec <LCD_Clear>
     1b6:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <Division_By_Zero_Flag>
     1ba:	04 c0       	rjmp	.+8      	; 0x1c4 <Task2_LCDDisplay+0xaa>
     1bc:	83 36       	cpi	r24, 0x63	; 99
     1be:	11 f4       	brne	.+4      	; 0x1c4 <Task2_LCDDisplay+0xaa>
     1c0:	0e 94 76 06 	call	0xcec	; 0xcec <LCD_Clear>
     1c4:	82 e3       	ldi	r24, 0x32	; 50
     1c6:	90 e0       	ldi	r25, 0x00	; 0
     1c8:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <vTaskDelay>
     1cc:	ae cf       	rjmp	.-164    	; 0x12a <Task2_LCDDisplay+0x10>

000001ce <Clear_Button>:
}

void Clear_Button (void)
{
	 Division_By_Zero_Flag=0;
     1ce:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <Division_By_Zero_Flag>
	 op_cntr=0;
     1d2:	10 92 e4 00 	sts	0x00E4, r1	; 0x8000e4 <op_cntr>
	 num_cntr=0;
     1d6:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <num_cntr>
	 result=0;
     1da:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <result>
     1de:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <result+0x1>
     1e2:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <result+0x2>
     1e6:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <result+0x3>
     1ea:	10 92 eb 00 	sts	0x00EB, r1	; 0x8000eb <result+0x4>
     1ee:	10 92 ec 00 	sts	0x00EC, r1	; 0x8000ec <result+0x5>
     1f2:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <result+0x6>
     1f6:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <result+0x7>
     1fa:	e0 ef       	ldi	r30, 0xF0	; 240
     1fc:	f0 e0       	ldi	r31, 0x00	; 0
     1fe:	8a ef       	ldi	r24, 0xFA	; 250
     200:	90 e0       	ldi	r25, 0x00	; 0
	 for (i=0; i<Number_Of_Operations ; i++)
	 {
		 Operations[i]=0;
     202:	11 92       	st	Z+, r1
{
	 Division_By_Zero_Flag=0;
	 op_cntr=0;
	 num_cntr=0;
	 result=0;
	 for (i=0; i<Number_Of_Operations ; i++)
     204:	e8 17       	cp	r30, r24
     206:	f9 07       	cpc	r31, r25
     208:	e1 f7       	brne	.-8      	; 0x202 <Clear_Button+0x34>
     20a:	8a e0       	ldi	r24, 0x0A	; 10
     20c:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <i>
     210:	ea ef       	ldi	r30, 0xFA	; 250
     212:	f0 e0       	ldi	r31, 0x00	; 0
     214:	82 e7       	ldi	r24, 0x72	; 114
     216:	91 e0       	ldi	r25, 0x01	; 1
	 {
		 Operations[i]=0;
	 }
	 for (j=0 ; j<Number_Of_Operands ; j++)
	 {
		 Numbers[j]=0;
     218:	10 82       	st	Z, r1
     21a:	11 82       	std	Z+1, r1	; 0x01
     21c:	12 82       	std	Z+2, r1	; 0x02
     21e:	13 82       	std	Z+3, r1	; 0x03
     220:	14 82       	std	Z+4, r1	; 0x04
     222:	15 82       	std	Z+5, r1	; 0x05
     224:	16 82       	std	Z+6, r1	; 0x06
     226:	17 82       	std	Z+7, r1	; 0x07
     228:	38 96       	adiw	r30, 0x08	; 8
	 result=0;
	 for (i=0; i<Number_Of_Operations ; i++)
	 {
		 Operations[i]=0;
	 }
	 for (j=0 ; j<Number_Of_Operands ; j++)
     22a:	e8 17       	cp	r30, r24
     22c:	f9 07       	cpc	r31, r25
     22e:	a1 f7       	brne	.-24     	; 0x218 <Clear_Button+0x4a>
     230:	8f e0       	ldi	r24, 0x0F	; 15
     232:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__data_end>
     236:	08 95       	ret

00000238 <Operations_Buttons>:
	 }
}

void Operations_Buttons (void)
{
	Operations[op_cntr] = Key_Value;
     238:	80 91 e4 00 	lds	r24, 0x00E4	; 0x8000e4 <op_cntr>
     23c:	e8 2f       	mov	r30, r24
     23e:	f0 e0       	ldi	r31, 0x00	; 0
     240:	e0 51       	subi	r30, 0x10	; 16
     242:	ff 4f       	sbci	r31, 0xFF	; 255
     244:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <Key_Value>
     248:	90 83       	st	Z, r25
	num_cntr++;
     24a:	90 91 e5 00 	lds	r25, 0x00E5	; 0x8000e5 <num_cntr>
     24e:	9f 5f       	subi	r25, 0xFF	; 255
     250:	90 93 e5 00 	sts	0x00E5, r25	; 0x8000e5 <num_cntr>
	op_cntr++;
     254:	8f 5f       	subi	r24, 0xFF	; 255
     256:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <op_cntr>
     25a:	08 95       	ret

0000025c <Numbers_Buttons>:
}

void Numbers_Buttons (void)
{
     25c:	6f 92       	push	r6
     25e:	7f 92       	push	r7
     260:	8f 92       	push	r8
     262:	9f 92       	push	r9
     264:	af 92       	push	r10
     266:	bf 92       	push	r11
     268:	cf 92       	push	r12
     26a:	df 92       	push	r13
     26c:	ef 92       	push	r14
     26e:	ff 92       	push	r15
     270:	0f 93       	push	r16
     272:	1f 93       	push	r17
     274:	cf 93       	push	r28
     276:	df 93       	push	r29
	Numbers[num_cntr] *=10;
     278:	e0 91 e5 00 	lds	r30, 0x00E5	; 0x8000e5 <num_cntr>
     27c:	f0 e0       	ldi	r31, 0x00	; 0
	Numbers[num_cntr] += (Key_Value -'0');
     27e:	ee 0f       	add	r30, r30
     280:	ff 1f       	adc	r31, r31
     282:	ee 0f       	add	r30, r30
     284:	ff 1f       	adc	r31, r31
     286:	ee 0f       	add	r30, r30
     288:	ff 1f       	adc	r31, r31
     28a:	e6 50       	subi	r30, 0x06	; 6
     28c:	ff 4f       	sbci	r31, 0xFF	; 255
     28e:	20 81       	ld	r18, Z
     290:	31 81       	ldd	r19, Z+1	; 0x01
     292:	42 81       	ldd	r20, Z+2	; 0x02
     294:	53 81       	ldd	r21, Z+3	; 0x03
     296:	64 81       	ldd	r22, Z+4	; 0x04
     298:	75 81       	ldd	r23, Z+5	; 0x05
     29a:	86 81       	ldd	r24, Z+6	; 0x06
     29c:	97 81       	ldd	r25, Z+7	; 0x07
     29e:	01 e0       	ldi	r16, 0x01	; 1
     2a0:	0e 94 18 12 	call	0x2430	; 0x2430 <__ashldi3>
     2a4:	62 2e       	mov	r6, r18
     2a6:	73 2e       	mov	r7, r19
     2a8:	84 2e       	mov	r8, r20
     2aa:	95 2e       	mov	r9, r21
     2ac:	d6 2f       	mov	r29, r22
     2ae:	c7 2f       	mov	r28, r23
     2b0:	b8 2f       	mov	r27, r24
     2b2:	a9 2f       	mov	r26, r25
     2b4:	02 e0       	ldi	r16, 0x02	; 2
     2b6:	0e 94 18 12 	call	0x2430	; 0x2430 <__ashldi3>
     2ba:	a2 2e       	mov	r10, r18
     2bc:	b3 2e       	mov	r11, r19
     2be:	c4 2e       	mov	r12, r20
     2c0:	d5 2e       	mov	r13, r21
     2c2:	e6 2e       	mov	r14, r22
     2c4:	f7 2e       	mov	r15, r23
     2c6:	08 2f       	mov	r16, r24
     2c8:	19 2f       	mov	r17, r25
     2ca:	26 2d       	mov	r18, r6
     2cc:	37 2d       	mov	r19, r7
     2ce:	48 2d       	mov	r20, r8
     2d0:	59 2d       	mov	r21, r9
     2d2:	6d 2f       	mov	r22, r29
     2d4:	7c 2f       	mov	r23, r28
     2d6:	8b 2f       	mov	r24, r27
     2d8:	9a 2f       	mov	r25, r26
     2da:	0e 94 31 12 	call	0x2462	; 0x2462 <__adddi3>
     2de:	a0 91 ef 00 	lds	r26, 0x00EF	; 0x8000ef <Key_Value>
     2e2:	b0 e0       	ldi	r27, 0x00	; 0
     2e4:	d0 97       	sbiw	r26, 0x30	; 48
     2e6:	1b 2f       	mov	r17, r27
     2e8:	11 0f       	add	r17, r17
     2ea:	11 0b       	sbc	r17, r17
     2ec:	aa 2e       	mov	r10, r26
     2ee:	bb 2e       	mov	r11, r27
     2f0:	c1 2e       	mov	r12, r17
     2f2:	d1 2e       	mov	r13, r17
     2f4:	e1 2e       	mov	r14, r17
     2f6:	f1 2e       	mov	r15, r17
     2f8:	01 2f       	mov	r16, r17
     2fa:	0e 94 31 12 	call	0x2462	; 0x2462 <__adddi3>
     2fe:	20 83       	st	Z, r18
     300:	31 83       	std	Z+1, r19	; 0x01
     302:	42 83       	std	Z+2, r20	; 0x02
     304:	53 83       	std	Z+3, r21	; 0x03
     306:	64 83       	std	Z+4, r22	; 0x04
     308:	75 83       	std	Z+5, r23	; 0x05
     30a:	86 83       	std	Z+6, r24	; 0x06
     30c:	97 83       	std	Z+7, r25	; 0x07
}
     30e:	df 91       	pop	r29
     310:	cf 91       	pop	r28
     312:	1f 91       	pop	r17
     314:	0f 91       	pop	r16
     316:	ff 90       	pop	r15
     318:	ef 90       	pop	r14
     31a:	df 90       	pop	r13
     31c:	cf 90       	pop	r12
     31e:	bf 90       	pop	r11
     320:	af 90       	pop	r10
     322:	9f 90       	pop	r9
     324:	8f 90       	pop	r8
     326:	7f 90       	pop	r7
     328:	6f 90       	pop	r6
     32a:	08 95       	ret

0000032c <Division_By_Zero>:
	}
}

void Division_By_Zero (void)
{
	op_cntr=0;
     32c:	10 92 e4 00 	sts	0x00E4, r1	; 0x8000e4 <op_cntr>
	num_cntr=0;
     330:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <num_cntr>
	result=0;
     334:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <result>
     338:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <result+0x1>
     33c:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <result+0x2>
     340:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <result+0x3>
     344:	10 92 eb 00 	sts	0x00EB, r1	; 0x8000eb <result+0x4>
     348:	10 92 ec 00 	sts	0x00EC, r1	; 0x8000ec <result+0x5>
     34c:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <result+0x6>
     350:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <result+0x7>
     354:	e0 ef       	ldi	r30, 0xF0	; 240
     356:	f0 e0       	ldi	r31, 0x00	; 0
     358:	8a ef       	ldi	r24, 0xFA	; 250
     35a:	90 e0       	ldi	r25, 0x00	; 0
	for (i=0; i<Number_Of_Operations ; i++)
	{
		Operations[i]=0;
     35c:	11 92       	st	Z+, r1
void Division_By_Zero (void)
{
	op_cntr=0;
	num_cntr=0;
	result=0;
	for (i=0; i<Number_Of_Operations ; i++)
     35e:	e8 17       	cp	r30, r24
     360:	f9 07       	cpc	r31, r25
     362:	e1 f7       	brne	.-8      	; 0x35c <Division_By_Zero+0x30>
     364:	8a e0       	ldi	r24, 0x0A	; 10
     366:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <i>
     36a:	ea ef       	ldi	r30, 0xFA	; 250
     36c:	f0 e0       	ldi	r31, 0x00	; 0
     36e:	82 e7       	ldi	r24, 0x72	; 114
     370:	91 e0       	ldi	r25, 0x01	; 1
	{
		Operations[i]=0;
	}
	for (j=0 ; j<Number_Of_Operands ; j++)
	{
		Numbers[j]=0;
     372:	10 82       	st	Z, r1
     374:	11 82       	std	Z+1, r1	; 0x01
     376:	12 82       	std	Z+2, r1	; 0x02
     378:	13 82       	std	Z+3, r1	; 0x03
     37a:	14 82       	std	Z+4, r1	; 0x04
     37c:	15 82       	std	Z+5, r1	; 0x05
     37e:	16 82       	std	Z+6, r1	; 0x06
     380:	17 82       	std	Z+7, r1	; 0x07
     382:	38 96       	adiw	r30, 0x08	; 8
	result=0;
	for (i=0; i<Number_Of_Operations ; i++)
	{
		Operations[i]=0;
	}
	for (j=0 ; j<Number_Of_Operands ; j++)
     384:	e8 17       	cp	r30, r24
     386:	f9 07       	cpc	r31, r25
     388:	a1 f7       	brne	.-24     	; 0x372 <Division_By_Zero+0x46>
     38a:	8f e0       	ldi	r24, 0x0F	; 15
     38c:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__data_end>
     390:	08 95       	ret

00000392 <Multiplication>:
	}
	result = Numbers[0];	
}

void Multiplication (void)
{
     392:	8f 92       	push	r8
     394:	9f 92       	push	r9
     396:	af 92       	push	r10
     398:	bf 92       	push	r11
     39a:	cf 92       	push	r12
     39c:	df 92       	push	r13
     39e:	ef 92       	push	r14
     3a0:	ff 92       	push	r15
     3a2:	0f 93       	push	r16
     3a4:	1f 93       	push	r17
     3a6:	cf 93       	push	r28
	Numbers[i] *=  Numbers[i+1] ;
     3a8:	c0 91 e3 00 	lds	r28, 0x00E3	; 0x8000e3 <i>
     3ac:	ec 2f       	mov	r30, r28
     3ae:	f0 e0       	ldi	r31, 0x00	; 0
     3b0:	cf 01       	movw	r24, r30
     3b2:	88 0f       	add	r24, r24
     3b4:	99 1f       	adc	r25, r25
     3b6:	88 0f       	add	r24, r24
     3b8:	99 1f       	adc	r25, r25
     3ba:	88 0f       	add	r24, r24
     3bc:	99 1f       	adc	r25, r25
     3be:	9c 01       	movw	r18, r24
     3c0:	26 50       	subi	r18, 0x06	; 6
     3c2:	3f 4f       	sbci	r19, 0xFF	; 255
     3c4:	49 01       	movw	r8, r18
     3c6:	fc 01       	movw	r30, r24
     3c8:	ee 5f       	subi	r30, 0xFE	; 254
     3ca:	fe 4f       	sbci	r31, 0xFE	; 254
     3cc:	d9 01       	movw	r26, r18
     3ce:	ac 90       	ld	r10, X
     3d0:	11 96       	adiw	r26, 0x01	; 1
     3d2:	bc 90       	ld	r11, X
     3d4:	11 97       	sbiw	r26, 0x01	; 1
     3d6:	12 96       	adiw	r26, 0x02	; 2
     3d8:	cc 90       	ld	r12, X
     3da:	12 97       	sbiw	r26, 0x02	; 2
     3dc:	13 96       	adiw	r26, 0x03	; 3
     3de:	dc 90       	ld	r13, X
     3e0:	13 97       	sbiw	r26, 0x03	; 3
     3e2:	14 96       	adiw	r26, 0x04	; 4
     3e4:	ec 90       	ld	r14, X
     3e6:	14 97       	sbiw	r26, 0x04	; 4
     3e8:	15 96       	adiw	r26, 0x05	; 5
     3ea:	fc 90       	ld	r15, X
     3ec:	15 97       	sbiw	r26, 0x05	; 5
     3ee:	16 96       	adiw	r26, 0x06	; 6
     3f0:	0c 91       	ld	r16, X
     3f2:	16 97       	sbiw	r26, 0x06	; 6
     3f4:	17 96       	adiw	r26, 0x07	; 7
     3f6:	1c 91       	ld	r17, X
     3f8:	20 81       	ld	r18, Z
     3fa:	31 81       	ldd	r19, Z+1	; 0x01
     3fc:	42 81       	ldd	r20, Z+2	; 0x02
     3fe:	53 81       	ldd	r21, Z+3	; 0x03
     400:	64 81       	ldd	r22, Z+4	; 0x04
     402:	75 81       	ldd	r23, Z+5	; 0x05
     404:	86 81       	ldd	r24, Z+6	; 0x06
     406:	97 81       	ldd	r25, Z+7	; 0x07
     408:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <__muldi3>
     40c:	f4 01       	movw	r30, r8
     40e:	20 83       	st	Z, r18
     410:	31 83       	std	Z+1, r19	; 0x01
     412:	42 83       	std	Z+2, r20	; 0x02
     414:	53 83       	std	Z+3, r21	; 0x03
     416:	64 83       	std	Z+4, r22	; 0x04
     418:	75 83       	std	Z+5, r23	; 0x05
     41a:	86 83       	std	Z+6, r24	; 0x06
     41c:	97 83       	std	Z+7, r25	; 0x07
	for (j=i; j < op_cntr ; j++)
     41e:	c0 93 e2 00 	sts	0x00E2, r28	; 0x8000e2 <__data_end>
     422:	90 90 e4 00 	lds	r9, 0x00E4	; 0x8000e4 <op_cntr>
     426:	c9 15       	cp	r28, r9
     428:	90 f5       	brcc	.+100    	; 0x48e <__LOCK_REGION_LENGTH__+0x8e>
	{
		Operations[j] = Operations[j+1];
     42a:	ec 2f       	mov	r30, r28
     42c:	f0 e0       	ldi	r31, 0x00	; 0
     42e:	cf 01       	movw	r24, r30
     430:	01 96       	adiw	r24, 0x01	; 1
     432:	dc 01       	movw	r26, r24
     434:	a0 51       	subi	r26, 0x10	; 16
     436:	bf 4f       	sbci	r27, 0xFF	; 255
     438:	2c 91       	ld	r18, X
     43a:	df 01       	movw	r26, r30
     43c:	a0 51       	subi	r26, 0x10	; 16
     43e:	bf 4f       	sbci	r27, 0xFF	; 255
     440:	2c 93       	st	X, r18
		Numbers[j+1] = Numbers [j+2];
     442:	ee 0f       	add	r30, r30
     444:	ff 1f       	adc	r31, r31
     446:	ee 0f       	add	r30, r30
     448:	ff 1f       	adc	r31, r31
     44a:	ee 0f       	add	r30, r30
     44c:	ff 1f       	adc	r31, r31
     44e:	e6 5f       	subi	r30, 0xF6	; 246
     450:	fe 4f       	sbci	r31, 0xFE	; 254
     452:	b0 81       	ld	r27, Z
     454:	a1 81       	ldd	r26, Z+1	; 0x01
     456:	72 81       	ldd	r23, Z+2	; 0x02
     458:	63 81       	ldd	r22, Z+3	; 0x03
     45a:	54 81       	ldd	r21, Z+4	; 0x04
     45c:	45 81       	ldd	r20, Z+5	; 0x05
     45e:	36 81       	ldd	r19, Z+6	; 0x06
     460:	27 81       	ldd	r18, Z+7	; 0x07
     462:	fc 01       	movw	r30, r24
     464:	ee 0f       	add	r30, r30
     466:	ff 1f       	adc	r31, r31
     468:	ee 0f       	add	r30, r30
     46a:	ff 1f       	adc	r31, r31
     46c:	ee 0f       	add	r30, r30
     46e:	ff 1f       	adc	r31, r31
     470:	e6 50       	subi	r30, 0x06	; 6
     472:	ff 4f       	sbci	r31, 0xFF	; 255
     474:	b0 83       	st	Z, r27
     476:	a1 83       	std	Z+1, r26	; 0x01
     478:	72 83       	std	Z+2, r23	; 0x02
     47a:	63 83       	std	Z+3, r22	; 0x03
     47c:	54 83       	std	Z+4, r21	; 0x04
     47e:	45 83       	std	Z+5, r20	; 0x05
     480:	36 83       	std	Z+6, r19	; 0x06
     482:	27 83       	std	Z+7, r18	; 0x07
     484:	cf 5f       	subi	r28, 0xFF	; 255
}

void Multiplication (void)
{
	Numbers[i] *=  Numbers[i+1] ;
	for (j=i; j < op_cntr ; j++)
     486:	c9 11       	cpse	r28, r9
     488:	d0 cf       	rjmp	.-96     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
     48a:	90 92 e2 00 	sts	0x00E2, r9	; 0x8000e2 <__data_end>
	{
		Operations[j] = Operations[j+1];
		Numbers[j+1] = Numbers [j+2];
	}
}
     48e:	cf 91       	pop	r28
     490:	1f 91       	pop	r17
     492:	0f 91       	pop	r16
     494:	ff 90       	pop	r15
     496:	ef 90       	pop	r14
     498:	df 90       	pop	r13
     49a:	cf 90       	pop	r12
     49c:	bf 90       	pop	r11
     49e:	af 90       	pop	r10
     4a0:	9f 90       	pop	r9
     4a2:	8f 90       	pop	r8
     4a4:	08 95       	ret

000004a6 <Division>:

void Division (void)
{
     4a6:	8f 92       	push	r8
     4a8:	9f 92       	push	r9
     4aa:	af 92       	push	r10
     4ac:	bf 92       	push	r11
     4ae:	cf 92       	push	r12
     4b0:	df 92       	push	r13
     4b2:	ef 92       	push	r14
     4b4:	ff 92       	push	r15
     4b6:	0f 93       	push	r16
     4b8:	1f 93       	push	r17
     4ba:	cf 93       	push	r28
     4bc:	df 93       	push	r29
	if (Numbers[i+1] == 0)
     4be:	c0 91 e3 00 	lds	r28, 0x00E3	; 0x8000e3 <i>
     4c2:	8c 2e       	mov	r8, r28
     4c4:	91 2c       	mov	r9, r1
     4c6:	f4 01       	movw	r30, r8
     4c8:	ee 0f       	add	r30, r30
     4ca:	ff 1f       	adc	r31, r31
     4cc:	ee 0f       	add	r30, r30
     4ce:	ff 1f       	adc	r31, r31
     4d0:	ee 0f       	add	r30, r30
     4d2:	ff 1f       	adc	r31, r31
     4d4:	ee 5f       	subi	r30, 0xFE	; 254
     4d6:	fe 4f       	sbci	r31, 0xFE	; 254
     4d8:	a0 80       	ld	r10, Z
     4da:	b1 80       	ldd	r11, Z+1	; 0x01
     4dc:	c2 80       	ldd	r12, Z+2	; 0x02
     4de:	d3 80       	ldd	r13, Z+3	; 0x03
     4e0:	e4 80       	ldd	r14, Z+4	; 0x04
     4e2:	f5 80       	ldd	r15, Z+5	; 0x05
     4e4:	06 81       	ldd	r16, Z+6	; 0x06
     4e6:	17 81       	ldd	r17, Z+7	; 0x07
     4e8:	2a 2d       	mov	r18, r10
     4ea:	3b 2d       	mov	r19, r11
     4ec:	4c 2d       	mov	r20, r12
     4ee:	5d 2d       	mov	r21, r13
     4f0:	6e 2d       	mov	r22, r14
     4f2:	7f 2d       	mov	r23, r15
     4f4:	80 2f       	mov	r24, r16
     4f6:	91 2f       	mov	r25, r17
     4f8:	a0 e0       	ldi	r26, 0x00	; 0
     4fa:	0e 94 43 12 	call	0x2486	; 0x2486 <__cmpdi2_s8>
     4fe:	21 f4       	brne	.+8      	; 0x508 <Division+0x62>
	{
		Division_By_Zero_Flag=1;
     500:	81 e0       	ldi	r24, 0x01	; 1
     502:	80 93 e6 00 	sts	0x00E6, r24	; 0x8000e6 <Division_By_Zero_Flag>
     506:	1f c0       	rjmp	.+62     	; 0x546 <Division+0xa0>
	}
	else if (Numbers[i+1] != 0)
	{
		Numbers[i] /=  Numbers[i+1] ;
     508:	c4 01       	movw	r24, r8
     50a:	88 0f       	add	r24, r24
     50c:	99 1f       	adc	r25, r25
     50e:	88 0f       	add	r24, r24
     510:	99 1f       	adc	r25, r25
     512:	88 0f       	add	r24, r24
     514:	99 1f       	adc	r25, r25
     516:	9c 01       	movw	r18, r24
     518:	26 50       	subi	r18, 0x06	; 6
     51a:	3f 4f       	sbci	r19, 0xFF	; 255
     51c:	49 01       	movw	r8, r18
     51e:	f9 01       	movw	r30, r18
     520:	20 81       	ld	r18, Z
     522:	31 81       	ldd	r19, Z+1	; 0x01
     524:	42 81       	ldd	r20, Z+2	; 0x02
     526:	53 81       	ldd	r21, Z+3	; 0x03
     528:	64 81       	ldd	r22, Z+4	; 0x04
     52a:	75 81       	ldd	r23, Z+5	; 0x05
     52c:	86 81       	ldd	r24, Z+6	; 0x06
     52e:	97 81       	ldd	r25, Z+7	; 0x07
     530:	0e 94 43 11 	call	0x2286	; 0x2286 <__divdi3>
     534:	f4 01       	movw	r30, r8
     536:	20 83       	st	Z, r18
     538:	31 83       	std	Z+1, r19	; 0x01
     53a:	42 83       	std	Z+2, r20	; 0x02
     53c:	53 83       	std	Z+3, r21	; 0x03
     53e:	64 83       	std	Z+4, r22	; 0x04
     540:	75 83       	std	Z+5, r23	; 0x05
     542:	86 83       	std	Z+6, r24	; 0x06
     544:	97 83       	std	Z+7, r25	; 0x07
	}
	for (j = i; j<op_cntr ; j++)
     546:	c0 93 e2 00 	sts	0x00E2, r28	; 0x8000e2 <__data_end>
     54a:	d0 91 e4 00 	lds	r29, 0x00E4	; 0x8000e4 <op_cntr>
     54e:	cd 17       	cp	r28, r29
     550:	90 f5       	brcc	.+100    	; 0x5b6 <Division+0x110>
	{
		Operations[j] = Operations[j+1];
     552:	ec 2f       	mov	r30, r28
     554:	f0 e0       	ldi	r31, 0x00	; 0
     556:	cf 01       	movw	r24, r30
     558:	01 96       	adiw	r24, 0x01	; 1
     55a:	dc 01       	movw	r26, r24
     55c:	a0 51       	subi	r26, 0x10	; 16
     55e:	bf 4f       	sbci	r27, 0xFF	; 255
     560:	2c 91       	ld	r18, X
     562:	df 01       	movw	r26, r30
     564:	a0 51       	subi	r26, 0x10	; 16
     566:	bf 4f       	sbci	r27, 0xFF	; 255
     568:	2c 93       	st	X, r18
		Numbers[j+1] = Numbers[j+2];
     56a:	ee 0f       	add	r30, r30
     56c:	ff 1f       	adc	r31, r31
     56e:	ee 0f       	add	r30, r30
     570:	ff 1f       	adc	r31, r31
     572:	ee 0f       	add	r30, r30
     574:	ff 1f       	adc	r31, r31
     576:	e6 5f       	subi	r30, 0xF6	; 246
     578:	fe 4f       	sbci	r31, 0xFE	; 254
     57a:	b0 81       	ld	r27, Z
     57c:	a1 81       	ldd	r26, Z+1	; 0x01
     57e:	72 81       	ldd	r23, Z+2	; 0x02
     580:	63 81       	ldd	r22, Z+3	; 0x03
     582:	54 81       	ldd	r21, Z+4	; 0x04
     584:	45 81       	ldd	r20, Z+5	; 0x05
     586:	36 81       	ldd	r19, Z+6	; 0x06
     588:	27 81       	ldd	r18, Z+7	; 0x07
     58a:	fc 01       	movw	r30, r24
     58c:	ee 0f       	add	r30, r30
     58e:	ff 1f       	adc	r31, r31
     590:	ee 0f       	add	r30, r30
     592:	ff 1f       	adc	r31, r31
     594:	ee 0f       	add	r30, r30
     596:	ff 1f       	adc	r31, r31
     598:	e6 50       	subi	r30, 0x06	; 6
     59a:	ff 4f       	sbci	r31, 0xFF	; 255
     59c:	b0 83       	st	Z, r27
     59e:	a1 83       	std	Z+1, r26	; 0x01
     5a0:	72 83       	std	Z+2, r23	; 0x02
     5a2:	63 83       	std	Z+3, r22	; 0x03
     5a4:	54 83       	std	Z+4, r21	; 0x04
     5a6:	45 83       	std	Z+5, r20	; 0x05
     5a8:	36 83       	std	Z+6, r19	; 0x06
     5aa:	27 83       	std	Z+7, r18	; 0x07
     5ac:	cf 5f       	subi	r28, 0xFF	; 255
	}
	else if (Numbers[i+1] != 0)
	{
		Numbers[i] /=  Numbers[i+1] ;
	}
	for (j = i; j<op_cntr ; j++)
     5ae:	cd 13       	cpse	r28, r29
     5b0:	d0 cf       	rjmp	.-96     	; 0x552 <Division+0xac>
     5b2:	d0 93 e2 00 	sts	0x00E2, r29	; 0x8000e2 <__data_end>
	{
		Operations[j] = Operations[j+1];
		Numbers[j+1] = Numbers[j+2];
	}
}
     5b6:	df 91       	pop	r29
     5b8:	cf 91       	pop	r28
     5ba:	1f 91       	pop	r17
     5bc:	0f 91       	pop	r16
     5be:	ff 90       	pop	r15
     5c0:	ef 90       	pop	r14
     5c2:	df 90       	pop	r13
     5c4:	cf 90       	pop	r12
     5c6:	bf 90       	pop	r11
     5c8:	af 90       	pop	r10
     5ca:	9f 90       	pop	r9
     5cc:	8f 90       	pop	r8
     5ce:	08 95       	ret

000005d0 <MulDiv_Sequence>:

}

void MulDiv_Sequence (void)
{
	for (i=0 ; i < op_cntr ; i++)
     5d0:	10 92 e3 00 	sts	0x00E3, r1	; 0x8000e3 <i>
     5d4:	80 91 e4 00 	lds	r24, 0x00E4	; 0x8000e4 <op_cntr>
     5d8:	88 23       	and	r24, r24
     5da:	09 f4       	brne	.+2      	; 0x5de <MulDiv_Sequence+0xe>
     5dc:	91 c0       	rjmp	.+290    	; 0x700 <MulDiv_Sequence+0x130>
     5de:	80 e0       	ldi	r24, 0x00	; 0
	{
		if (Operations[i] == 'x' && Operations[i+1]== '/')
     5e0:	90 e0       	ldi	r25, 0x00	; 0
     5e2:	fc 01       	movw	r30, r24
     5e4:	e0 51       	subi	r30, 0x10	; 16
     5e6:	ff 4f       	sbci	r31, 0xFF	; 255
     5e8:	20 81       	ld	r18, Z
     5ea:	28 37       	cpi	r18, 0x78	; 120
     5ec:	69 f5       	brne	.+90     	; 0x648 <MulDiv_Sequence+0x78>
     5ee:	fc 01       	movw	r30, r24
     5f0:	e0 51       	subi	r30, 0x10	; 16
     5f2:	ff 4f       	sbci	r31, 0xFF	; 255
     5f4:	81 81       	ldd	r24, Z+1	; 0x01
     5f6:	8f 32       	cpi	r24, 0x2F	; 47
     5f8:	09 f0       	breq	.+2      	; 0x5fc <MulDiv_Sequence+0x2c>
     5fa:	53 c0       	rjmp	.+166    	; 0x6a2 <MulDiv_Sequence+0xd2>
		{
			while (Operations[i] == 'x' && Operations[i+1] == '/')
     5fc:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <i>
     600:	90 e0       	ldi	r25, 0x00	; 0
     602:	fc 01       	movw	r30, r24
     604:	e0 51       	subi	r30, 0x10	; 16
     606:	ff 4f       	sbci	r31, 0xFF	; 255
     608:	20 81       	ld	r18, Z
     60a:	28 37       	cpi	r18, 0x78	; 120
     60c:	09 f0       	breq	.+2      	; 0x610 <MulDiv_Sequence+0x40>
     60e:	6e c0       	rjmp	.+220    	; 0x6ec <MulDiv_Sequence+0x11c>
     610:	fc 01       	movw	r30, r24
     612:	e0 51       	subi	r30, 0x10	; 16
     614:	ff 4f       	sbci	r31, 0xFF	; 255
     616:	81 81       	ldd	r24, Z+1	; 0x01
     618:	8f 32       	cpi	r24, 0x2F	; 47
     61a:	09 f0       	breq	.+2      	; 0x61e <MulDiv_Sequence+0x4e>
     61c:	67 c0       	rjmp	.+206    	; 0x6ec <MulDiv_Sequence+0x11c>
			{
				Multiplication();
     61e:	0e 94 c9 01 	call	0x392	; 0x392 <Multiplication>
				Division();
     622:	0e 94 53 02 	call	0x4a6	; 0x4a6 <Division>
{
	for (i=0 ; i < op_cntr ; i++)
	{
		if (Operations[i] == 'x' && Operations[i+1]== '/')
		{
			while (Operations[i] == 'x' && Operations[i+1] == '/')
     626:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <i>
     62a:	90 e0       	ldi	r25, 0x00	; 0
     62c:	fc 01       	movw	r30, r24
     62e:	e0 51       	subi	r30, 0x10	; 16
     630:	ff 4f       	sbci	r31, 0xFF	; 255
     632:	20 81       	ld	r18, Z
     634:	28 37       	cpi	r18, 0x78	; 120
     636:	09 f0       	breq	.+2      	; 0x63a <MulDiv_Sequence+0x6a>
     638:	59 c0       	rjmp	.+178    	; 0x6ec <MulDiv_Sequence+0x11c>
     63a:	fc 01       	movw	r30, r24
     63c:	e0 51       	subi	r30, 0x10	; 16
     63e:	ff 4f       	sbci	r31, 0xFF	; 255
     640:	81 81       	ldd	r24, Z+1	; 0x01
     642:	8f 32       	cpi	r24, 0x2F	; 47
     644:	61 f3       	breq	.-40     	; 0x61e <MulDiv_Sequence+0x4e>
     646:	52 c0       	rjmp	.+164    	; 0x6ec <MulDiv_Sequence+0x11c>
			{
				Multiplication();
				Division();
			}
		}
		else if (Operations[i] == '/' && Operations[i+1] == 'x')
     648:	2f 32       	cpi	r18, 0x2F	; 47
     64a:	09 f0       	breq	.+2      	; 0x64e <MulDiv_Sequence+0x7e>
     64c:	4f c0       	rjmp	.+158    	; 0x6ec <MulDiv_Sequence+0x11c>
     64e:	fc 01       	movw	r30, r24
     650:	e0 51       	subi	r30, 0x10	; 16
     652:	ff 4f       	sbci	r31, 0xFF	; 255
     654:	81 81       	ldd	r24, Z+1	; 0x01
     656:	88 37       	cpi	r24, 0x78	; 120
     658:	b9 f5       	brne	.+110    	; 0x6c8 <MulDiv_Sequence+0xf8>
		{
			while (Operations [i] == '/' && Operations[i+1] == 'x')
     65a:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <i>
     65e:	90 e0       	ldi	r25, 0x00	; 0
     660:	fc 01       	movw	r30, r24
     662:	e0 51       	subi	r30, 0x10	; 16
     664:	ff 4f       	sbci	r31, 0xFF	; 255
     666:	20 81       	ld	r18, Z
     668:	2f 32       	cpi	r18, 0x2F	; 47
     66a:	09 f0       	breq	.+2      	; 0x66e <MulDiv_Sequence+0x9e>
     66c:	3f c0       	rjmp	.+126    	; 0x6ec <MulDiv_Sequence+0x11c>
     66e:	fc 01       	movw	r30, r24
     670:	e0 51       	subi	r30, 0x10	; 16
     672:	ff 4f       	sbci	r31, 0xFF	; 255
     674:	81 81       	ldd	r24, Z+1	; 0x01
     676:	88 37       	cpi	r24, 0x78	; 120
     678:	c9 f5       	brne	.+114    	; 0x6ec <MulDiv_Sequence+0x11c>
			{
				Division();
     67a:	0e 94 53 02 	call	0x4a6	; 0x4a6 <Division>
			    Multiplication();
     67e:	0e 94 c9 01 	call	0x392	; 0x392 <Multiplication>
				Division();
			}
		}
		else if (Operations[i] == '/' && Operations[i+1] == 'x')
		{
			while (Operations [i] == '/' && Operations[i+1] == 'x')
     682:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <i>
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	fc 01       	movw	r30, r24
     68a:	e0 51       	subi	r30, 0x10	; 16
     68c:	ff 4f       	sbci	r31, 0xFF	; 255
     68e:	20 81       	ld	r18, Z
     690:	2f 32       	cpi	r18, 0x2F	; 47
     692:	61 f5       	brne	.+88     	; 0x6ec <MulDiv_Sequence+0x11c>
     694:	fc 01       	movw	r30, r24
     696:	e0 51       	subi	r30, 0x10	; 16
     698:	ff 4f       	sbci	r31, 0xFF	; 255
     69a:	81 81       	ldd	r24, Z+1	; 0x01
     69c:	88 37       	cpi	r24, 0x78	; 120
     69e:	69 f3       	breq	.-38     	; 0x67a <MulDiv_Sequence+0xaa>
     6a0:	25 c0       	rjmp	.+74     	; 0x6ec <MulDiv_Sequence+0x11c>
		}
		else 
		{
			if (Operations[i] == 'x')
			{
				while (Operations [i] == 'x')
     6a2:	e0 91 e3 00 	lds	r30, 0x00E3	; 0x8000e3 <i>
     6a6:	f0 e0       	ldi	r31, 0x00	; 0
     6a8:	e0 51       	subi	r30, 0x10	; 16
     6aa:	ff 4f       	sbci	r31, 0xFF	; 255
     6ac:	80 81       	ld	r24, Z
     6ae:	88 37       	cpi	r24, 0x78	; 120
     6b0:	e9 f4       	brne	.+58     	; 0x6ec <MulDiv_Sequence+0x11c>
				{
					Multiplication();
     6b2:	0e 94 c9 01 	call	0x392	; 0x392 <Multiplication>
		}
		else 
		{
			if (Operations[i] == 'x')
			{
				while (Operations [i] == 'x')
     6b6:	e0 91 e3 00 	lds	r30, 0x00E3	; 0x8000e3 <i>
     6ba:	f0 e0       	ldi	r31, 0x00	; 0
     6bc:	e0 51       	subi	r30, 0x10	; 16
     6be:	ff 4f       	sbci	r31, 0xFF	; 255
     6c0:	80 81       	ld	r24, Z
     6c2:	88 37       	cpi	r24, 0x78	; 120
     6c4:	b1 f3       	breq	.-20     	; 0x6b2 <MulDiv_Sequence+0xe2>
     6c6:	12 c0       	rjmp	.+36     	; 0x6ec <MulDiv_Sequence+0x11c>
					Multiplication();
				}
			}
			else if (Operations[i] == '/')
			{
				while (Operations [i] == '/')
     6c8:	e0 91 e3 00 	lds	r30, 0x00E3	; 0x8000e3 <i>
     6cc:	f0 e0       	ldi	r31, 0x00	; 0
     6ce:	e0 51       	subi	r30, 0x10	; 16
     6d0:	ff 4f       	sbci	r31, 0xFF	; 255
     6d2:	80 81       	ld	r24, Z
     6d4:	8f 32       	cpi	r24, 0x2F	; 47
     6d6:	51 f4       	brne	.+20     	; 0x6ec <MulDiv_Sequence+0x11c>
				{
					Division();
     6d8:	0e 94 53 02 	call	0x4a6	; 0x4a6 <Division>
					Multiplication();
				}
			}
			else if (Operations[i] == '/')
			{
				while (Operations [i] == '/')
     6dc:	e0 91 e3 00 	lds	r30, 0x00E3	; 0x8000e3 <i>
     6e0:	f0 e0       	ldi	r31, 0x00	; 0
     6e2:	e0 51       	subi	r30, 0x10	; 16
     6e4:	ff 4f       	sbci	r31, 0xFF	; 255
     6e6:	80 81       	ld	r24, Z
     6e8:	8f 32       	cpi	r24, 0x2F	; 47
     6ea:	b1 f3       	breq	.-20     	; 0x6d8 <MulDiv_Sequence+0x108>

}

void MulDiv_Sequence (void)
{
	for (i=0 ; i < op_cntr ; i++)
     6ec:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <i>
     6f0:	8f 5f       	subi	r24, 0xFF	; 255
     6f2:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <i>
     6f6:	90 91 e4 00 	lds	r25, 0x00E4	; 0x8000e4 <op_cntr>
     6fa:	89 17       	cp	r24, r25
     6fc:	08 f4       	brcc	.+2      	; 0x700 <MulDiv_Sequence+0x130>
     6fe:	70 cf       	rjmp	.-288    	; 0x5e0 <MulDiv_Sequence+0x10>
					Division();
				}
			}
		}
	}
	result = Numbers[0];	
     700:	ea ef       	ldi	r30, 0xFA	; 250
     702:	f0 e0       	ldi	r31, 0x00	; 0
     704:	80 81       	ld	r24, Z
     706:	80 93 e7 00 	sts	0x00E7, r24	; 0x8000e7 <result>
     70a:	81 81       	ldd	r24, Z+1	; 0x01
     70c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <result+0x1>
     710:	82 81       	ldd	r24, Z+2	; 0x02
     712:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <result+0x2>
     716:	83 81       	ldd	r24, Z+3	; 0x03
     718:	80 93 ea 00 	sts	0x00EA, r24	; 0x8000ea <result+0x3>
     71c:	84 81       	ldd	r24, Z+4	; 0x04
     71e:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <result+0x4>
     722:	85 81       	ldd	r24, Z+5	; 0x05
     724:	80 93 ec 00 	sts	0x00EC, r24	; 0x8000ec <result+0x5>
     728:	86 81       	ldd	r24, Z+6	; 0x06
     72a:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <result+0x6>
     72e:	87 81       	ldd	r24, Z+7	; 0x07
     730:	80 93 ee 00 	sts	0x00EE, r24	; 0x8000ee <result+0x7>
     734:	08 95       	ret

00000736 <SumSub_Sequence>:
		Numbers[j+1] = Numbers[j+2];
	}
}

void SumSub_Sequence (void)
{
     736:	8f 92       	push	r8
     738:	9f 92       	push	r9
     73a:	af 92       	push	r10
     73c:	bf 92       	push	r11
     73e:	cf 92       	push	r12
     740:	df 92       	push	r13
     742:	ef 92       	push	r14
     744:	ff 92       	push	r15
     746:	0f 93       	push	r16
     748:	1f 93       	push	r17
     74a:	cf 93       	push	r28
     74c:	df 93       	push	r29
	for(i = 0 ; i < op_cntr; i++)
     74e:	10 92 e3 00 	sts	0x00E3, r1	; 0x8000e3 <i>
     752:	d0 91 e4 00 	lds	r29, 0x00E4	; 0x8000e4 <op_cntr>
     756:	dd 23       	and	r29, r29
     758:	09 f4       	brne	.+2      	; 0x75c <SumSub_Sequence+0x26>
     75a:	4c c0       	rjmp	.+152    	; 0x7f4 <SumSub_Sequence+0xbe>
     75c:	20 91 e7 00 	lds	r18, 0x00E7	; 0x8000e7 <result>
     760:	30 91 e8 00 	lds	r19, 0x00E8	; 0x8000e8 <result+0x1>
     764:	40 91 e9 00 	lds	r20, 0x00E9	; 0x8000e9 <result+0x2>
     768:	50 91 ea 00 	lds	r21, 0x00EA	; 0x8000ea <result+0x3>
     76c:	60 91 eb 00 	lds	r22, 0x00EB	; 0x8000eb <result+0x4>
     770:	70 91 ec 00 	lds	r23, 0x00EC	; 0x8000ec <result+0x5>
     774:	80 91 ed 00 	lds	r24, 0x00ED	; 0x8000ed <result+0x6>
     778:	90 91 ee 00 	lds	r25, 0x00EE	; 0x8000ee <result+0x7>
     77c:	a0 ef       	ldi	r26, 0xF0	; 240
     77e:	b0 e0       	ldi	r27, 0x00	; 0
     780:	e2 e0       	ldi	r30, 0x02	; 2
     782:	f1 e0       	ldi	r31, 0x01	; 1
     784:	88 24       	eor	r8, r8
     786:	8a 94       	dec	r8
     788:	8d 0e       	add	r8, r29
     78a:	91 2c       	mov	r9, r1
     78c:	84 01       	movw	r16, r8
     78e:	0f 50       	subi	r16, 0x0F	; 15
     790:	1f 4f       	sbci	r17, 0xFF	; 255
     792:	48 01       	movw	r8, r16
	{
		if(Operations[i] == '+')
     794:	cd 91       	ld	r28, X+
     796:	cb 32       	cpi	r28, 0x2B	; 43
     798:	59 f4       	brne	.+22     	; 0x7b0 <SumSub_Sequence+0x7a>
		result += Numbers[i+1];
     79a:	a0 80       	ld	r10, Z
     79c:	b1 80       	ldd	r11, Z+1	; 0x01
     79e:	c2 80       	ldd	r12, Z+2	; 0x02
     7a0:	d3 80       	ldd	r13, Z+3	; 0x03
     7a2:	e4 80       	ldd	r14, Z+4	; 0x04
     7a4:	f5 80       	ldd	r15, Z+5	; 0x05
     7a6:	06 81       	ldd	r16, Z+6	; 0x06
     7a8:	17 81       	ldd	r17, Z+7	; 0x07
     7aa:	0e 94 31 12 	call	0x2462	; 0x2462 <__adddi3>
     7ae:	0c c0       	rjmp	.+24     	; 0x7c8 <SumSub_Sequence+0x92>

		else if (Operations[i] == '-')
     7b0:	cd 32       	cpi	r28, 0x2D	; 45
     7b2:	51 f4       	brne	.+20     	; 0x7c8 <SumSub_Sequence+0x92>
		result -= Numbers[i+1];
     7b4:	a0 80       	ld	r10, Z
     7b6:	b1 80       	ldd	r11, Z+1	; 0x01
     7b8:	c2 80       	ldd	r12, Z+2	; 0x02
     7ba:	d3 80       	ldd	r13, Z+3	; 0x03
     7bc:	e4 80       	ldd	r14, Z+4	; 0x04
     7be:	f5 80       	ldd	r15, Z+5	; 0x05
     7c0:	06 81       	ldd	r16, Z+6	; 0x06
     7c2:	17 81       	ldd	r17, Z+7	; 0x07
     7c4:	0e 94 3a 12 	call	0x2474	; 0x2474 <__subdi3>
     7c8:	38 96       	adiw	r30, 0x08	; 8
	}
}

void SumSub_Sequence (void)
{
	for(i = 0 ; i < op_cntr; i++)
     7ca:	a8 15       	cp	r26, r8
     7cc:	b9 05       	cpc	r27, r9
     7ce:	11 f7       	brne	.-60     	; 0x794 <SumSub_Sequence+0x5e>
     7d0:	20 93 e7 00 	sts	0x00E7, r18	; 0x8000e7 <result>
     7d4:	30 93 e8 00 	sts	0x00E8, r19	; 0x8000e8 <result+0x1>
     7d8:	40 93 e9 00 	sts	0x00E9, r20	; 0x8000e9 <result+0x2>
     7dc:	50 93 ea 00 	sts	0x00EA, r21	; 0x8000ea <result+0x3>
     7e0:	60 93 eb 00 	sts	0x00EB, r22	; 0x8000eb <result+0x4>
     7e4:	70 93 ec 00 	sts	0x00EC, r23	; 0x8000ec <result+0x5>
     7e8:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <result+0x6>
     7ec:	90 93 ee 00 	sts	0x00EE, r25	; 0x8000ee <result+0x7>
     7f0:	d0 93 e3 00 	sts	0x00E3, r29	; 0x8000e3 <i>
		result += Numbers[i+1];

		else if (Operations[i] == '-')
		result -= Numbers[i+1];
	}
}
     7f4:	df 91       	pop	r29
     7f6:	cf 91       	pop	r28
     7f8:	1f 91       	pop	r17
     7fa:	0f 91       	pop	r16
     7fc:	ff 90       	pop	r15
     7fe:	ef 90       	pop	r14
     800:	df 90       	pop	r13
     802:	cf 90       	pop	r12
     804:	bf 90       	pop	r11
     806:	af 90       	pop	r10
     808:	9f 90       	pop	r9
     80a:	8f 90       	pop	r8
     80c:	08 95       	ret

0000080e <Calculate>:
}


void Calculate (void)
{
	MulDiv_Sequence();
     80e:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <MulDiv_Sequence>
	SumSub_Sequence();
     812:	0e 94 9b 03 	call	0x736	; 0x736 <SumSub_Sequence>
	
	if (Division_By_Zero_Flag == 1)
     816:	80 91 e6 00 	lds	r24, 0x00E6	; 0x8000e6 <Division_By_Zero_Flag>
     81a:	81 30       	cpi	r24, 0x01	; 1
     81c:	11 f4       	brne	.+4      	; 0x822 <Calculate+0x14>
	{
		Division_By_Zero();
     81e:	0e 94 96 01 	call	0x32c	; 0x32c <Division_By_Zero>
     822:	08 95       	ret

00000824 <Task1_KeyPad_GetValue>:

void Task1_KeyPad_GetValue (void *ptr)
{
	while (1)
	{
		Key_Value= KeyPad_GetValue();
     824:	0e 94 97 04 	call	0x92e	; 0x92e <KeyPad_GetValue>
     828:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <Key_Value>
		if (Key_Value != 0)
     82c:	88 23       	and	r24, r24
     82e:	51 f1       	breq	.+84     	; 0x884 <__stack+0x25>
		{
			xQueueSend(	Queue1_Handle,(const void *) &Key_Value,(TickType_t) portMAX_DELAY );
     830:	20 e0       	ldi	r18, 0x00	; 0
     832:	4f ef       	ldi	r20, 0xFF	; 255
     834:	5f ef       	ldi	r21, 0xFF	; 255
     836:	6f ee       	ldi	r22, 0xEF	; 239
     838:	70 e0       	ldi	r23, 0x00	; 0
     83a:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <Queue1_Handle>
     83e:	90 91 73 01 	lds	r25, 0x0173	; 0x800173 <Queue1_Handle+0x1>
     842:	0e 94 05 0b 	call	0x160a	; 0x160a <xQueueGenericSend>
			
			if (Key_Value == 'x' || Key_Value == '/' || Key_Value == '+' || Key_Value == '-')
     846:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <Key_Value>
     84a:	88 37       	cpi	r24, 0x78	; 120
     84c:	31 f0       	breq	.+12     	; 0x85a <Task1_KeyPad_GetValue+0x36>
     84e:	98 2f       	mov	r25, r24
     850:	9b 7f       	andi	r25, 0xFB	; 251
     852:	9b 32       	cpi	r25, 0x2B	; 43
     854:	11 f0       	breq	.+4      	; 0x85a <Task1_KeyPad_GetValue+0x36>
     856:	8d 32       	cpi	r24, 0x2D	; 45
     858:	19 f4       	brne	.+6      	; 0x860 <__stack+0x1>
			{
				Operations_Buttons();
     85a:	0e 94 1c 01 	call	0x238	; 0x238 <Operations_Buttons>
     85e:	12 c0       	rjmp	.+36     	; 0x884 <__stack+0x25>
			}
			else if (Key_Value >= '0' && Key_Value <= '9')
     860:	90 ed       	ldi	r25, 0xD0	; 208
     862:	98 0f       	add	r25, r24
     864:	9a 30       	cpi	r25, 0x0A	; 10
     866:	18 f4       	brcc	.+6      	; 0x86e <__stack+0xf>
			{
				Numbers_Buttons();
     868:	0e 94 2e 01 	call	0x25c	; 0x25c <Numbers_Buttons>
     86c:	0b c0       	rjmp	.+22     	; 0x884 <__stack+0x25>
			}
			else if (Key_Value == '=')
     86e:	8d 33       	cpi	r24, 0x3D	; 61
     870:	29 f4       	brne	.+10     	; 0x87c <__stack+0x1d>
			{
				Calculate();
     872:	0e 94 07 04 	call	0x80e	; 0x80e <Calculate>
				Calculate();
     876:	0e 94 07 04 	call	0x80e	; 0x80e <Calculate>
     87a:	04 c0       	rjmp	.+8      	; 0x884 <__stack+0x25>
			}
			else if (Key_Value == 'c')
     87c:	83 36       	cpi	r24, 0x63	; 99
     87e:	11 f4       	brne	.+4      	; 0x884 <__stack+0x25>
			{
				Clear_Button();
     880:	0e 94 e7 00 	call	0x1ce	; 0x1ce <Clear_Button>
			}
		}
		vTaskDelay( (const TickType_t) 100);
     884:	84 e6       	ldi	r24, 0x64	; 100
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <vTaskDelay>
	}
     88c:	cb cf       	rjmp	.-106    	; 0x824 <Task1_KeyPad_GetValue>

0000088e <App>:
		vTaskDelay( (const TickType_t) 50);
	}
}

void App (void)
{
     88e:	ef 92       	push	r14
     890:	ff 92       	push	r15
     892:	0f 93       	push	r16
	xTaskCreate(    Tasks_Init ,
     894:	0f 2e       	mov	r0, r31
     896:	f8 e7       	ldi	r31, 0x78	; 120
     898:	ef 2e       	mov	r14, r31
     89a:	f1 e0       	ldi	r31, 0x01	; 1
     89c:	ff 2e       	mov	r15, r31
     89e:	f0 2d       	mov	r31, r0
     8a0:	03 e0       	ldi	r16, 0x03	; 3
     8a2:	20 e0       	ldi	r18, 0x00	; 0
     8a4:	30 e0       	ldi	r19, 0x00	; 0
     8a6:	44 e6       	ldi	r20, 0x64	; 100
     8a8:	50 e0       	ldi	r21, 0x00	; 0
     8aa:	6e ea       	ldi	r22, 0xAE	; 174
     8ac:	70 e0       	ldi	r23, 0x00	; 0
     8ae:	89 e4       	ldi	r24, 0x49	; 73
     8b0:	90 e0       	ldi	r25, 0x00	; 0
     8b2:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <xTaskCreate>
	NULL,
	3,
	&Init_Task_Handle
	);
	
	xTaskCreate(    Task1_KeyPad_GetValue,
     8b6:	0f 2e       	mov	r0, r31
     8b8:	f6 e7       	ldi	r31, 0x76	; 118
     8ba:	ef 2e       	mov	r14, r31
     8bc:	f1 e0       	ldi	r31, 0x01	; 1
     8be:	ff 2e       	mov	r15, r31
     8c0:	f0 2d       	mov	r31, r0
     8c2:	02 e0       	ldi	r16, 0x02	; 2
     8c4:	20 e0       	ldi	r18, 0x00	; 0
     8c6:	30 e0       	ldi	r19, 0x00	; 0
     8c8:	44 e6       	ldi	r20, 0x64	; 100
     8ca:	50 e0       	ldi	r21, 0x00	; 0
     8cc:	68 eb       	ldi	r22, 0xB8	; 184
     8ce:	70 e0       	ldi	r23, 0x00	; 0
     8d0:	82 e1       	ldi	r24, 0x12	; 18
     8d2:	94 e0       	ldi	r25, 0x04	; 4
     8d4:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <xTaskCreate>
	NULL,
	2,
	&Task_1_Handle
	);
	
	xTaskCreate(    Task2_LCDDisplay,
     8d8:	0f 2e       	mov	r0, r31
     8da:	f4 e7       	ldi	r31, 0x74	; 116
     8dc:	ef 2e       	mov	r14, r31
     8de:	f1 e0       	ldi	r31, 0x01	; 1
     8e0:	ff 2e       	mov	r15, r31
     8e2:	f0 2d       	mov	r31, r0
     8e4:	01 e0       	ldi	r16, 0x01	; 1
     8e6:	20 e0       	ldi	r18, 0x00	; 0
     8e8:	30 e0       	ldi	r19, 0x00	; 0
     8ea:	44 e6       	ldi	r20, 0x64	; 100
     8ec:	50 e0       	ldi	r21, 0x00	; 0
     8ee:	60 ec       	ldi	r22, 0xC0	; 192
     8f0:	70 e0       	ldi	r23, 0x00	; 0
     8f2:	8d e8       	ldi	r24, 0x8D	; 141
     8f4:	90 e0       	ldi	r25, 0x00	; 0
     8f6:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <xTaskCreate>
	NULL,
	1,
	&Task_2_Handle
	);
	
	vTaskStartScheduler();
     8fa:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vTaskStartScheduler>

     8fe:	0f 91       	pop	r16
     900:	ff 90       	pop	r15
     902:	ef 90       	pop	r14
     904:	08 95       	ret

00000906 <main>:

#include "Calculator.h"

int main(void)
{
   App();
     906:	0e 94 47 04 	call	0x88e	; 0x88e <App>
     90a:	ff cf       	rjmp	.-2      	; 0x90a <main+0x4>

0000090c <KeyPad_Init>:
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void KeyPad_Init(void)
{
	DIO_WriteChannel( KEYPAD_ROW_0 , PIN_HIGH);
     90c:	61 e0       	ldi	r22, 0x01	; 1
     90e:	8c e0       	ldi	r24, 0x0C	; 12
     910:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel( KEYPAD_ROW_1 , PIN_HIGH);
     914:	61 e0       	ldi	r22, 0x01	; 1
     916:	8d e0       	ldi	r24, 0x0D	; 13
     918:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel( KEYPAD_ROW_2 , PIN_HIGH);
     91c:	61 e0       	ldi	r22, 0x01	; 1
     91e:	8e e0       	ldi	r24, 0x0E	; 14
     920:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel( KEYPAD_ROW_3 , PIN_HIGH);
     924:	61 e0       	ldi	r22, 0x01	; 1
     926:	8f e0       	ldi	r24, 0x0F	; 15
     928:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
     92c:	08 95       	ret

0000092e <KeyPad_GetValue>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
uint8 KeyPad_GetValue (void)
{
     92e:	df 92       	push	r13
     930:	ef 92       	push	r14
     932:	ff 92       	push	r15
     934:	0f 93       	push	r16
     936:	1f 93       	push	r17
     938:	cf 93       	push	r28
     93a:	df 93       	push	r29
     93c:	0f 2e       	mov	r0, r31
     93e:	fc ec       	ldi	r31, 0xCC	; 204
     940:	ef 2e       	mov	r14, r31
     942:	f0 e0       	ldi	r31, 0x00	; 0
     944:	ff 2e       	mov	r15, r31
     946:	f0 2d       	mov	r31, r0
	uint8 ROW_LOC = 0 , COL_LOC = 0 , Button_Val = 0 , Temp_Val = 0;
     948:	d1 2c       	mov	r13, r1
	for (ROW_LOC = KEYPAD_ROW_START ; ROW_LOC <= KEYPAD_ROW_END ; ROW_LOC++)
     94a:	dc e0       	ldi	r29, 0x0C	; 12
	{
		DIO_WriteChannel( ROW_LOC , PIN_LOW);
     94c:	60 e0       	ldi	r22, 0x00	; 0
     94e:	8d 2f       	mov	r24, r29
     950:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
     954:	87 01       	movw	r16, r14
		
		for(COL_LOC= KEYPAD_COL_START ; COL_LOC <= KEYPAD_COL_END ; COL_LOC++)
     956:	ca e1       	ldi	r28, 0x1A	; 26
		{
			Temp_Val = DIO_ReadChannel(COL_LOC);
     958:	8c 2f       	mov	r24, r28
     95a:	0e 94 07 07 	call	0xe0e	; 0xe0e <DIO_ReadChannel>
			
			if (Temp_Val == 0)
     95e:	81 11       	cpse	r24, r1
     960:	0d c0       	rjmp	.+26     	; 0x97c <KeyPad_GetValue+0x4e>
			{
				Button_Val = KeyPad_Values[ROW_LOC - KEYPAD_ROW_START][COL_LOC - KEYPAD_COL_START];
     962:	f8 01       	movw	r30, r16
     964:	d0 80       	ld	r13, Z
				while(Temp_Val == 0)
				{
					Temp_Val = DIO_ReadChannel(COL_LOC);
     966:	8c 2f       	mov	r24, r28
     968:	0e 94 07 07 	call	0xe0e	; 0xe0e <DIO_ReadChannel>
			Temp_Val = DIO_ReadChannel(COL_LOC);
			
			if (Temp_Val == 0)
			{
				Button_Val = KeyPad_Values[ROW_LOC - KEYPAD_ROW_START][COL_LOC - KEYPAD_COL_START];
				while(Temp_Val == 0)
     96c:	88 23       	and	r24, r24
     96e:	d9 f3       	breq	.-10     	; 0x966 <KeyPad_GetValue+0x38>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     970:	8f e3       	ldi	r24, 0x3F	; 63
     972:	9c e9       	ldi	r25, 0x9C	; 156
     974:	01 97       	sbiw	r24, 0x01	; 1
     976:	f1 f7       	brne	.-4      	; 0x974 <KeyPad_GetValue+0x46>
     978:	00 c0       	rjmp	.+0      	; 0x97a <KeyPad_GetValue+0x4c>
     97a:	00 00       	nop
	uint8 ROW_LOC = 0 , COL_LOC = 0 , Button_Val = 0 , Temp_Val = 0;
	for (ROW_LOC = KEYPAD_ROW_START ; ROW_LOC <= KEYPAD_ROW_END ; ROW_LOC++)
	{
		DIO_WriteChannel( ROW_LOC , PIN_LOW);
		
		for(COL_LOC= KEYPAD_COL_START ; COL_LOC <= KEYPAD_COL_END ; COL_LOC++)
     97c:	cf 5f       	subi	r28, 0xFF	; 255
     97e:	0f 5f       	subi	r16, 0xFF	; 255
     980:	1f 4f       	sbci	r17, 0xFF	; 255
     982:	ce 31       	cpi	r28, 0x1E	; 30
     984:	49 f7       	brne	.-46     	; 0x958 <KeyPad_GetValue+0x2a>
					Temp_Val = DIO_ReadChannel(COL_LOC);
				}
				_delay_ms(10);
			}
		}
		DIO_WriteChannel(ROW_LOC , PIN_HIGH);
     986:	61 e0       	ldi	r22, 0x01	; 1
     988:	8d 2f       	mov	r24, r29
     98a:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
*                                    E_NOT_OK
*******************************************************************************/
uint8 KeyPad_GetValue (void)
{
	uint8 ROW_LOC = 0 , COL_LOC = 0 , Button_Val = 0 , Temp_Val = 0;
	for (ROW_LOC = KEYPAD_ROW_START ; ROW_LOC <= KEYPAD_ROW_END ; ROW_LOC++)
     98e:	df 5f       	subi	r29, 0xFF	; 255
     990:	94 e0       	ldi	r25, 0x04	; 4
     992:	e9 0e       	add	r14, r25
     994:	f1 1c       	adc	r15, r1
     996:	d0 31       	cpi	r29, 0x10	; 16
     998:	c9 f6       	brne	.-78     	; 0x94c <KeyPad_GetValue+0x1e>
		}
		DIO_WriteChannel(ROW_LOC , PIN_HIGH);
	}
	
	return Button_Val;
}
     99a:	8d 2d       	mov	r24, r13
     99c:	df 91       	pop	r29
     99e:	cf 91       	pop	r28
     9a0:	1f 91       	pop	r17
     9a2:	0f 91       	pop	r16
     9a4:	ff 90       	pop	r15
     9a6:	ef 90       	pop	r14
     9a8:	df 90       	pop	r13
     9aa:	08 95       	ret

000009ac <LCD_WriteCommand>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void LCD_WriteCommand(uint8 cmd)
{
     9ac:	cf 93       	push	r28
     9ae:	c8 2f       	mov	r28, r24
	DIO_WriteChannel(LCD_RS_PIN , PIN_LOW);
     9b0:	60 e0       	ldi	r22, 0x00	; 0
     9b2:	81 e0       	ldi	r24, 0x01	; 1
     9b4:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_E_PIN , PIN_LOW);
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	82 e0       	ldi	r24, 0x02	; 2
     9bc:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_D4_PIN , GET_BIT(cmd , 4));
     9c0:	c4 fb       	bst	r28, 4
     9c2:	66 27       	eor	r22, r22
     9c4:	60 f9       	bld	r22, 0
     9c6:	83 e0       	ldi	r24, 0x03	; 3
     9c8:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D5_PIN , GET_BIT(cmd , 5));
     9cc:	c5 fb       	bst	r28, 5
     9ce:	66 27       	eor	r22, r22
     9d0:	60 f9       	bld	r22, 0
     9d2:	84 e0       	ldi	r24, 0x04	; 4
     9d4:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D6_PIN , GET_BIT(cmd , 6));
     9d8:	c6 fb       	bst	r28, 6
     9da:	66 27       	eor	r22, r22
     9dc:	60 f9       	bld	r22, 0
     9de:	85 e0       	ldi	r24, 0x05	; 5
     9e0:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D7_PIN , GET_BIT(cmd , 7));
     9e4:	6c 2f       	mov	r22, r28
     9e6:	66 1f       	adc	r22, r22
     9e8:	66 27       	eor	r22, r22
     9ea:	66 1f       	adc	r22, r22
     9ec:	86 e0       	ldi	r24, 0x06	; 6
     9ee:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_E_PIN , PIN_HIGH);
     9f2:	61 e0       	ldi	r22, 0x01	; 1
     9f4:	82 e0       	ldi	r24, 0x02	; 2
     9f6:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
     9fa:	8f e9       	ldi	r24, 0x9F	; 159
     9fc:	9f e0       	ldi	r25, 0x0F	; 15
     9fe:	01 97       	sbiw	r24, 0x01	; 1
     a00:	f1 f7       	brne	.-4      	; 0x9fe <LCD_WriteCommand+0x52>
     a02:	00 c0       	rjmp	.+0      	; 0xa04 <LCD_WriteCommand+0x58>
     a04:	00 00       	nop
	_delay_ms(1);
	DIO_WriteChannel(LCD_E_PIN , PIN_LOW);
     a06:	60 e0       	ldi	r22, 0x00	; 0
     a08:	82 e0       	ldi	r24, 0x02	; 2
     a0a:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_D4_PIN , GET_BIT(cmd , 0));
     a0e:	6c 2f       	mov	r22, r28
     a10:	61 70       	andi	r22, 0x01	; 1
     a12:	83 e0       	ldi	r24, 0x03	; 3
     a14:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D5_PIN , GET_BIT(cmd , 1));
     a18:	c1 fb       	bst	r28, 1
     a1a:	66 27       	eor	r22, r22
     a1c:	60 f9       	bld	r22, 0
     a1e:	84 e0       	ldi	r24, 0x04	; 4
     a20:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D6_PIN , GET_BIT(cmd , 2));
     a24:	c2 fb       	bst	r28, 2
     a26:	66 27       	eor	r22, r22
     a28:	60 f9       	bld	r22, 0
     a2a:	85 e0       	ldi	r24, 0x05	; 5
     a2c:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D7_PIN , GET_BIT(cmd , 3));
     a30:	c3 fb       	bst	r28, 3
     a32:	66 27       	eor	r22, r22
     a34:	60 f9       	bld	r22, 0
     a36:	86 e0       	ldi	r24, 0x06	; 6
     a38:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_E_PIN , PIN_HIGH);
     a3c:	61 e0       	ldi	r22, 0x01	; 1
     a3e:	82 e0       	ldi	r24, 0x02	; 2
     a40:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
     a44:	8f e9       	ldi	r24, 0x9F	; 159
     a46:	9f e0       	ldi	r25, 0x0F	; 15
     a48:	01 97       	sbiw	r24, 0x01	; 1
     a4a:	f1 f7       	brne	.-4      	; 0xa48 <LCD_WriteCommand+0x9c>
     a4c:	00 c0       	rjmp	.+0      	; 0xa4e <LCD_WriteCommand+0xa2>
     a4e:	00 00       	nop
	_delay_ms(1);
	DIO_WriteChannel(LCD_E_PIN , PIN_LOW);
     a50:	60 e0       	ldi	r22, 0x00	; 0
     a52:	82 e0       	ldi	r24, 0x02	; 2
     a54:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
     a58:	8f e1       	ldi	r24, 0x1F	; 31
     a5a:	9e e4       	ldi	r25, 0x4E	; 78
     a5c:	01 97       	sbiw	r24, 0x01	; 1
     a5e:	f1 f7       	brne	.-4      	; 0xa5c <LCD_WriteCommand+0xb0>
     a60:	00 c0       	rjmp	.+0      	; 0xa62 <LCD_WriteCommand+0xb6>
     a62:	00 00       	nop
	
	_delay_ms(5);
}
     a64:	cf 91       	pop	r28
     a66:	08 95       	ret

00000a68 <LCD_Init>:
*******************************************************************************/
void LCD_Init(void)
{
	#if (LCD_OPERATION_MODE == 4)
	/*LCD 4 BIT MODE COMMANDS*/
	LCD_WriteCommand(0X33);
     a68:	83 e3       	ldi	r24, 0x33	; 51
     a6a:	0e 94 d6 04 	call	0x9ac	; 0x9ac <LCD_WriteCommand>
	LCD_WriteCommand(0X32);
     a6e:	82 e3       	ldi	r24, 0x32	; 50
     a70:	0e 94 d6 04 	call	0x9ac	; 0x9ac <LCD_WriteCommand>
	LCD_WriteCommand(0X28); // 2Lines and 5*8 dots
     a74:	88 e2       	ldi	r24, 0x28	; 40
     a76:	0e 94 d6 04 	call	0x9ac	; 0x9ac <LCD_WriteCommand>
	
	LCD_WriteCommand(0X01); // Clear Display
     a7a:	81 e0       	ldi	r24, 0x01	; 1
     a7c:	0e 94 d6 04 	call	0x9ac	; 0x9ac <LCD_WriteCommand>
	LCD_WriteCommand(0X06); // Increase Cursor to the Right, and Shift entire Display OFF
     a80:	86 e0       	ldi	r24, 0x06	; 6
     a82:	0e 94 d6 04 	call	0x9ac	; 0x9ac <LCD_WriteCommand>
	LCD_WriteCommand(0x0C); // Display ON , Cursor OFF , Cursor Blink OFF
     a86:	8c e0       	ldi	r24, 0x0C	; 12
     a88:	0e 94 d6 04 	call	0x9ac	; 0x9ac <LCD_WriteCommand>
	LCD_WriteCommand(0X02); // Return Home Instruction 
     a8c:	82 e0       	ldi	r24, 0x02	; 2
     a8e:	0e 94 d6 04 	call	0x9ac	; 0x9ac <LCD_WriteCommand>
     a92:	8f e1       	ldi	r24, 0x1F	; 31
     a94:	9e e4       	ldi	r25, 0x4E	; 78
     a96:	01 97       	sbiw	r24, 0x01	; 1
     a98:	f1 f7       	brne	.-4      	; 0xa96 <LCD_Init+0x2e>
     a9a:	00 c0       	rjmp	.+0      	; 0xa9c <LCD_Init+0x34>
     a9c:	00 00       	nop
     a9e:	08 95       	ret

00000aa0 <LCD_WriteChar>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void LCD_WriteChar(uint8 Data)
{
     aa0:	cf 93       	push	r28
     aa2:	c8 2f       	mov	r28, r24
	DIO_WriteChannel(LCD_RS_PIN , PIN_HIGH);
     aa4:	61 e0       	ldi	r22, 0x01	; 1
     aa6:	81 e0       	ldi	r24, 0x01	; 1
     aa8:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_E_PIN , PIN_LOW);
     aac:	60 e0       	ldi	r22, 0x00	; 0
     aae:	82 e0       	ldi	r24, 0x02	; 2
     ab0:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_D4_PIN , GET_BIT(Data , 4));
     ab4:	c4 fb       	bst	r28, 4
     ab6:	66 27       	eor	r22, r22
     ab8:	60 f9       	bld	r22, 0
     aba:	83 e0       	ldi	r24, 0x03	; 3
     abc:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D5_PIN , GET_BIT(Data , 5));
     ac0:	c5 fb       	bst	r28, 5
     ac2:	66 27       	eor	r22, r22
     ac4:	60 f9       	bld	r22, 0
     ac6:	84 e0       	ldi	r24, 0x04	; 4
     ac8:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D6_PIN , GET_BIT(Data , 6));
     acc:	c6 fb       	bst	r28, 6
     ace:	66 27       	eor	r22, r22
     ad0:	60 f9       	bld	r22, 0
     ad2:	85 e0       	ldi	r24, 0x05	; 5
     ad4:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D7_PIN , GET_BIT(Data , 7));
     ad8:	6c 2f       	mov	r22, r28
     ada:	66 1f       	adc	r22, r22
     adc:	66 27       	eor	r22, r22
     ade:	66 1f       	adc	r22, r22
     ae0:	86 e0       	ldi	r24, 0x06	; 6
     ae2:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_E_PIN , PIN_HIGH);
     ae6:	61 e0       	ldi	r22, 0x01	; 1
     ae8:	82 e0       	ldi	r24, 0x02	; 2
     aea:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
     aee:	8f e9       	ldi	r24, 0x9F	; 159
     af0:	9f e0       	ldi	r25, 0x0F	; 15
     af2:	01 97       	sbiw	r24, 0x01	; 1
     af4:	f1 f7       	brne	.-4      	; 0xaf2 <LCD_WriteChar+0x52>
     af6:	00 c0       	rjmp	.+0      	; 0xaf8 <LCD_WriteChar+0x58>
     af8:	00 00       	nop
	_delay_ms(1);
	DIO_WriteChannel(LCD_E_PIN , PIN_LOW);
     afa:	60 e0       	ldi	r22, 0x00	; 0
     afc:	82 e0       	ldi	r24, 0x02	; 2
     afe:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_D4_PIN , GET_BIT(Data , 0));
     b02:	6c 2f       	mov	r22, r28
     b04:	61 70       	andi	r22, 0x01	; 1
     b06:	83 e0       	ldi	r24, 0x03	; 3
     b08:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D5_PIN , GET_BIT(Data , 1));
     b0c:	c1 fb       	bst	r28, 1
     b0e:	66 27       	eor	r22, r22
     b10:	60 f9       	bld	r22, 0
     b12:	84 e0       	ldi	r24, 0x04	; 4
     b14:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D6_PIN , GET_BIT(Data , 2));
     b18:	c2 fb       	bst	r28, 2
     b1a:	66 27       	eor	r22, r22
     b1c:	60 f9       	bld	r22, 0
     b1e:	85 e0       	ldi	r24, 0x05	; 5
     b20:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D7_PIN , GET_BIT(Data , 3));
     b24:	c3 fb       	bst	r28, 3
     b26:	66 27       	eor	r22, r22
     b28:	60 f9       	bld	r22, 0
     b2a:	86 e0       	ldi	r24, 0x06	; 6
     b2c:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_E_PIN , PIN_HIGH);
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	82 e0       	ldi	r24, 0x02	; 2
     b34:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
     b38:	8f e9       	ldi	r24, 0x9F	; 159
     b3a:	9f e0       	ldi	r25, 0x0F	; 15
     b3c:	01 97       	sbiw	r24, 0x01	; 1
     b3e:	f1 f7       	brne	.-4      	; 0xb3c <LCD_WriteChar+0x9c>
     b40:	00 c0       	rjmp	.+0      	; 0xb42 <LCD_WriteChar+0xa2>
     b42:	00 00       	nop
	_delay_ms(1);
	DIO_WriteChannel(LCD_E_PIN , PIN_LOW);
     b44:	60 e0       	ldi	r22, 0x00	; 0
     b46:	82 e0       	ldi	r24, 0x02	; 2
     b48:	0e 94 80 06 	call	0xd00	; 0xd00 <DIO_WriteChannel>
     b4c:	8f e1       	ldi	r24, 0x1F	; 31
     b4e:	9e e4       	ldi	r25, 0x4E	; 78
     b50:	01 97       	sbiw	r24, 0x01	; 1
     b52:	f1 f7       	brne	.-4      	; 0xb50 <LCD_WriteChar+0xb0>
     b54:	00 c0       	rjmp	.+0      	; 0xb56 <LCD_WriteChar+0xb6>
     b56:	00 00       	nop
	
	_delay_ms(5);
}
     b58:	cf 91       	pop	r28
     b5a:	08 95       	ret

00000b5c <LCD_WriteString>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void LCD_WriteString(uint8* str)
{
     b5c:	0f 93       	push	r16
     b5e:	1f 93       	push	r17
     b60:	cf 93       	push	r28
     b62:	fc 01       	movw	r30, r24
	uint8 i=0;
	while(str[i]!='\0')
     b64:	80 81       	ld	r24, Z
     b66:	88 23       	and	r24, r24
     b68:	59 f0       	breq	.+22     	; 0xb80 <LCD_WriteString+0x24>
     b6a:	8f 01       	movw	r16, r30
     b6c:	c0 e0       	ldi	r28, 0x00	; 0
	{
		LCD_WriteChar(str[i]);
     b6e:	0e 94 50 05 	call	0xaa0	; 0xaa0 <LCD_WriteChar>
		i++;
     b72:	cf 5f       	subi	r28, 0xFF	; 255
*                                    E_NOT_OK
*******************************************************************************/
void LCD_WriteString(uint8* str)
{
	uint8 i=0;
	while(str[i]!='\0')
     b74:	f8 01       	movw	r30, r16
     b76:	ec 0f       	add	r30, r28
     b78:	f1 1d       	adc	r31, r1
     b7a:	80 81       	ld	r24, Z
     b7c:	81 11       	cpse	r24, r1
     b7e:	f7 cf       	rjmp	.-18     	; 0xb6e <LCD_WriteString+0x12>
     b80:	8f e1       	ldi	r24, 0x1F	; 31
     b82:	9e e4       	ldi	r25, 0x4E	; 78
     b84:	01 97       	sbiw	r24, 0x01	; 1
     b86:	f1 f7       	brne	.-4      	; 0xb84 <LCD_WriteString+0x28>
     b88:	00 c0       	rjmp	.+0      	; 0xb8a <LCD_WriteString+0x2e>
     b8a:	00 00       	nop
	{
		LCD_WriteChar(str[i]);
		i++;
	}
	_delay_ms(5);
}
     b8c:	cf 91       	pop	r28
     b8e:	1f 91       	pop	r17
     b90:	0f 91       	pop	r16
     b92:	08 95       	ret

00000b94 <LCD_WriteInteger>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void LCD_WriteInteger(sint32 num)
{
     b94:	4f 92       	push	r4
     b96:	5f 92       	push	r5
     b98:	6f 92       	push	r6
     b9a:	7f 92       	push	r7
     b9c:	8f 92       	push	r8
     b9e:	9f 92       	push	r9
     ba0:	af 92       	push	r10
     ba2:	bf 92       	push	r11
     ba4:	cf 92       	push	r12
     ba6:	df 92       	push	r13
     ba8:	ef 92       	push	r14
     baa:	ff 92       	push	r15
     bac:	6b 01       	movw	r12, r22
     bae:	7c 01       	movw	r14, r24
	 sint32 temp = 1;
	 if(num == 0)
     bb0:	61 15       	cp	r22, r1
     bb2:	71 05       	cpc	r23, r1
     bb4:	81 05       	cpc	r24, r1
     bb6:	91 05       	cpc	r25, r1
     bb8:	51 f4       	brne	.+20     	; 0xbce <LCD_WriteInteger+0x3a>
	 {
		 LCD_WriteChar('0');
     bba:	80 e3       	ldi	r24, 0x30	; 48
     bbc:	0e 94 50 05 	call	0xaa0	; 0xaa0 <LCD_WriteChar>
     bc0:	67 c0       	rjmp	.+206    	; 0xc90 <LCD_WriteInteger+0xfc>
		 LCD_WriteChar('-');
		 num *= -1;
	 }

		 
	 while(num > 0)
     bc2:	1c 14       	cp	r1, r12
     bc4:	1d 04       	cpc	r1, r13
     bc6:	1e 04       	cpc	r1, r14
     bc8:	1f 04       	cpc	r1, r15
     bca:	7c f0       	brlt	.+30     	; 0xbea <LCD_WriteInteger+0x56>
     bcc:	61 c0       	rjmp	.+194    	; 0xc90 <LCD_WriteInteger+0xfc>
	 if(num == 0)
	 {
		 LCD_WriteChar('0');
	 }

	 else if(num < 0)
     bce:	99 23       	and	r25, r25
     bd0:	c4 f7       	brge	.-16     	; 0xbc2 <LCD_WriteInteger+0x2e>
	 {
		 LCD_WriteChar('-');
     bd2:	8d e2       	ldi	r24, 0x2D	; 45
     bd4:	0e 94 50 05 	call	0xaa0	; 0xaa0 <LCD_WriteChar>
		 num *= -1;
     bd8:	f0 94       	com	r15
     bda:	e0 94       	com	r14
     bdc:	d0 94       	com	r13
     bde:	c0 94       	com	r12
     be0:	c1 1c       	adc	r12, r1
     be2:	d1 1c       	adc	r13, r1
     be4:	e1 1c       	adc	r14, r1
     be6:	f1 1c       	adc	r15, r1
     be8:	ec cf       	rjmp	.-40     	; 0xbc2 <LCD_WriteInteger+0x2e>
	 }

		 
	 while(num > 0)
     bea:	61 e0       	ldi	r22, 0x01	; 1
     bec:	70 e0       	ldi	r23, 0x00	; 0
     bee:	80 e0       	ldi	r24, 0x00	; 0
     bf0:	90 e0       	ldi	r25, 0x00	; 0
	 {
	  temp = ((temp*10) + (num%10));
     bf2:	0f 2e       	mov	r0, r31
     bf4:	fa e0       	ldi	r31, 0x0A	; 10
     bf6:	8f 2e       	mov	r8, r31
     bf8:	91 2c       	mov	r9, r1
     bfa:	a1 2c       	mov	r10, r1
     bfc:	b1 2c       	mov	r11, r1
     bfe:	f0 2d       	mov	r31, r0
     c00:	dc 01       	movw	r26, r24
     c02:	cb 01       	movw	r24, r22
     c04:	88 0f       	add	r24, r24
     c06:	99 1f       	adc	r25, r25
     c08:	aa 1f       	adc	r26, r26
     c0a:	bb 1f       	adc	r27, r27
     c0c:	2c 01       	movw	r4, r24
     c0e:	3d 01       	movw	r6, r26
     c10:	44 0c       	add	r4, r4
     c12:	55 1c       	adc	r5, r5
     c14:	66 1c       	adc	r6, r6
     c16:	77 1c       	adc	r7, r7
     c18:	44 0c       	add	r4, r4
     c1a:	55 1c       	adc	r5, r5
     c1c:	66 1c       	adc	r6, r6
     c1e:	77 1c       	adc	r7, r7
     c20:	48 0e       	add	r4, r24
     c22:	59 1e       	adc	r5, r25
     c24:	6a 1e       	adc	r6, r26
     c26:	7b 1e       	adc	r7, r27
     c28:	c7 01       	movw	r24, r14
     c2a:	b6 01       	movw	r22, r12
     c2c:	a5 01       	movw	r20, r10
     c2e:	94 01       	movw	r18, r8
     c30:	0e 94 c9 10 	call	0x2192	; 0x2192 <__divmodsi4>
     c34:	64 0d       	add	r22, r4
     c36:	75 1d       	adc	r23, r5
     c38:	86 1d       	adc	r24, r6
     c3a:	97 1d       	adc	r25, r7
	  num /= 10;
     c3c:	c2 2e       	mov	r12, r18
     c3e:	d3 2e       	mov	r13, r19
     c40:	e4 2e       	mov	r14, r20
     c42:	f5 2e       	mov	r15, r21
		 LCD_WriteChar('-');
		 num *= -1;
	 }

		 
	 while(num > 0)
     c44:	1c 14       	cp	r1, r12
     c46:	1d 04       	cpc	r1, r13
     c48:	1e 04       	cpc	r1, r14
     c4a:	1f 04       	cpc	r1, r15
     c4c:	cc f2       	brlt	.-78     	; 0xc00 <LCD_WriteInteger+0x6c>
	 {
	  temp = ((temp*10) + (num%10));
	  num /= 10;
	 }
	 
	 while(temp > 1 )
     c4e:	62 30       	cpi	r22, 0x02	; 2
     c50:	71 05       	cpc	r23, r1
     c52:	81 05       	cpc	r24, r1
     c54:	91 05       	cpc	r25, r1
     c56:	e4 f0       	brlt	.+56     	; 0xc90 <LCD_WriteInteger+0xfc>
	 {
	  LCD_WriteChar(((temp%10)+48));
     c58:	0f 2e       	mov	r0, r31
     c5a:	fa e0       	ldi	r31, 0x0A	; 10
     c5c:	8f 2e       	mov	r8, r31
     c5e:	91 2c       	mov	r9, r1
     c60:	a1 2c       	mov	r10, r1
     c62:	b1 2c       	mov	r11, r1
     c64:	f0 2d       	mov	r31, r0
     c66:	a5 01       	movw	r20, r10
     c68:	94 01       	movw	r18, r8
     c6a:	0e 94 c9 10 	call	0x2192	; 0x2192 <__divmodsi4>
     c6e:	c2 2e       	mov	r12, r18
     c70:	d3 2e       	mov	r13, r19
     c72:	e4 2e       	mov	r14, r20
     c74:	f5 2e       	mov	r15, r21
     c76:	80 e3       	ldi	r24, 0x30	; 48
     c78:	86 0f       	add	r24, r22
     c7a:	0e 94 50 05 	call	0xaa0	; 0xaa0 <LCD_WriteChar>
	  temp /= 10;
     c7e:	6c 2d       	mov	r22, r12
     c80:	7d 2d       	mov	r23, r13
     c82:	8e 2d       	mov	r24, r14
     c84:	9f 2d       	mov	r25, r15
	 {
	  temp = ((temp*10) + (num%10));
	  num /= 10;
	 }
	 
	 while(temp > 1 )
     c86:	62 30       	cpi	r22, 0x02	; 2
     c88:	71 05       	cpc	r23, r1
     c8a:	81 05       	cpc	r24, r1
     c8c:	91 05       	cpc	r25, r1
     c8e:	5c f7       	brge	.-42     	; 0xc66 <LCD_WriteInteger+0xd2>
     c90:	8f e1       	ldi	r24, 0x1F	; 31
     c92:	9e e4       	ldi	r25, 0x4E	; 78
     c94:	01 97       	sbiw	r24, 0x01	; 1
     c96:	f1 f7       	brne	.-4      	; 0xc94 <LCD_WriteInteger+0x100>
     c98:	00 c0       	rjmp	.+0      	; 0xc9a <LCD_WriteInteger+0x106>
     c9a:	00 00       	nop
	 {
	  LCD_WriteChar(((temp%10)+48));
	  temp /= 10;
	 }
	 _delay_ms(5);
}
     c9c:	ff 90       	pop	r15
     c9e:	ef 90       	pop	r14
     ca0:	df 90       	pop	r13
     ca2:	cf 90       	pop	r12
     ca4:	bf 90       	pop	r11
     ca6:	af 90       	pop	r10
     ca8:	9f 90       	pop	r9
     caa:	8f 90       	pop	r8
     cac:	7f 90       	pop	r7
     cae:	6f 90       	pop	r6
     cb0:	5f 90       	pop	r5
     cb2:	4f 90       	pop	r4
     cb4:	08 95       	ret

00000cb6 <LCD_GoTo>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void LCD_GoTo(uint8 Row, uint8 Column)
{
     cb6:	cf 93       	push	r28
     cb8:	df 93       	push	r29
     cba:	00 d0       	rcall	.+0      	; 0xcbc <LCD_GoTo+0x6>
     cbc:	cd b7       	in	r28, 0x3d	; 61
     cbe:	de b7       	in	r29, 0x3e	; 62
	uint8 LCD_Loc[2]={0X80 , 0XC0};	
     cc0:	90 e8       	ldi	r25, 0x80	; 128
     cc2:	99 83       	std	Y+1, r25	; 0x01
     cc4:	90 ec       	ldi	r25, 0xC0	; 192
     cc6:	9a 83       	std	Y+2, r25	; 0x02
	LCD_WriteCommand(LCD_Loc[Row] + Column);
     cc8:	fe 01       	movw	r30, r28
     cca:	e8 0f       	add	r30, r24
     ccc:	f1 1d       	adc	r31, r1
     cce:	81 81       	ldd	r24, Z+1	; 0x01
     cd0:	86 0f       	add	r24, r22
     cd2:	0e 94 d6 04 	call	0x9ac	; 0x9ac <LCD_WriteCommand>
     cd6:	8f e1       	ldi	r24, 0x1F	; 31
     cd8:	9e e4       	ldi	r25, 0x4E	; 78
     cda:	01 97       	sbiw	r24, 0x01	; 1
     cdc:	f1 f7       	brne	.-4      	; 0xcda <LCD_GoTo+0x24>
     cde:	00 c0       	rjmp	.+0      	; 0xce0 <LCD_GoTo+0x2a>
     ce0:	00 00       	nop
	_delay_ms(5);
}
     ce2:	0f 90       	pop	r0
     ce4:	0f 90       	pop	r0
     ce6:	df 91       	pop	r29
     ce8:	cf 91       	pop	r28
     cea:	08 95       	ret

00000cec <LCD_Clear>:
*                                    E_NOT_OK
*******************************************************************************/
void LCD_Clear(void)
{
	//command to clear LCD
	LCD_WriteCommand(0X01);
     cec:	81 e0       	ldi	r24, 0x01	; 1
     cee:	0e 94 d6 04 	call	0x9ac	; 0x9ac <LCD_WriteCommand>
     cf2:	8f e1       	ldi	r24, 0x1F	; 31
     cf4:	9e e4       	ldi	r25, 0x4E	; 78
     cf6:	01 97       	sbiw	r24, 0x01	; 1
     cf8:	f1 f7       	brne	.-4      	; 0xcf6 <LCD_Clear+0xa>
     cfa:	00 c0       	rjmp	.+0      	; 0xcfc <LCD_Clear+0x10>
     cfc:	00 00       	nop
     cfe:	08 95       	ret

00000d00 <DIO_WriteChannel>:
*                                    E_NOT_OK
*******************************************************************************/
void DIO_WriteChannel (uint8 Pin_Order, PIN_VAL_e Pin_Val)
{
	uint8 PORT =0, PIN=0 ;
	PORT= Pin_Order / NUMBER_OF_PORT_PINS;
     d00:	98 2f       	mov	r25, r24
     d02:	96 95       	lsr	r25
     d04:	96 95       	lsr	r25
     d06:	96 95       	lsr	r25
	PIN=  Pin_Order  % NUMBER_OF_PORT_PINS;
     d08:	87 70       	andi	r24, 0x07	; 7
	
	switch (Pin_Val)
     d0a:	66 23       	and	r22, r22
     d0c:	09 f4       	brne	.+2      	; 0xd10 <DIO_WriteChannel+0x10>
     d0e:	3f c0       	rjmp	.+126    	; 0xd8e <DIO_WriteChannel+0x8e>
     d10:	61 30       	cpi	r22, 0x01	; 1
     d12:	09 f0       	breq	.+2      	; 0xd16 <DIO_WriteChannel+0x16>
     d14:	7b c0       	rjmp	.+246    	; 0xe0c <DIO_WriteChannel+0x10c>
	{
		case PIN_HIGH :
		switch(PORT)
     d16:	91 30       	cpi	r25, 0x01	; 1
     d18:	99 f0       	breq	.+38     	; 0xd40 <DIO_WriteChannel+0x40>
     d1a:	28 f0       	brcs	.+10     	; 0xd26 <DIO_WriteChannel+0x26>
     d1c:	92 30       	cpi	r25, 0x02	; 2
     d1e:	e9 f0       	breq	.+58     	; 0xd5a <DIO_WriteChannel+0x5a>
     d20:	93 30       	cpi	r25, 0x03	; 3
     d22:	41 f1       	breq	.+80     	; 0xd74 <DIO_WriteChannel+0x74>
     d24:	08 95       	ret
		{
			case 0:
			SET_BIT (PORTA , PIN);
     d26:	4b b3       	in	r20, 0x1b	; 27
     d28:	21 e0       	ldi	r18, 0x01	; 1
     d2a:	30 e0       	ldi	r19, 0x00	; 0
     d2c:	b9 01       	movw	r22, r18
     d2e:	02 c0       	rjmp	.+4      	; 0xd34 <DIO_WriteChannel+0x34>
     d30:	66 0f       	add	r22, r22
     d32:	77 1f       	adc	r23, r23
     d34:	8a 95       	dec	r24
     d36:	e2 f7       	brpl	.-8      	; 0xd30 <DIO_WriteChannel+0x30>
     d38:	cb 01       	movw	r24, r22
     d3a:	84 2b       	or	r24, r20
     d3c:	8b bb       	out	0x1b, r24	; 27
			break;
     d3e:	08 95       	ret
			case 1:
			SET_BIT (PORTB , PIN);
     d40:	48 b3       	in	r20, 0x18	; 24
     d42:	21 e0       	ldi	r18, 0x01	; 1
     d44:	30 e0       	ldi	r19, 0x00	; 0
     d46:	b9 01       	movw	r22, r18
     d48:	02 c0       	rjmp	.+4      	; 0xd4e <DIO_WriteChannel+0x4e>
     d4a:	66 0f       	add	r22, r22
     d4c:	77 1f       	adc	r23, r23
     d4e:	8a 95       	dec	r24
     d50:	e2 f7       	brpl	.-8      	; 0xd4a <DIO_WriteChannel+0x4a>
     d52:	cb 01       	movw	r24, r22
     d54:	84 2b       	or	r24, r20
     d56:	88 bb       	out	0x18, r24	; 24
			break;
     d58:	08 95       	ret
			case 2:
			SET_BIT (PORTC , PIN);
     d5a:	45 b3       	in	r20, 0x15	; 21
     d5c:	21 e0       	ldi	r18, 0x01	; 1
     d5e:	30 e0       	ldi	r19, 0x00	; 0
     d60:	b9 01       	movw	r22, r18
     d62:	02 c0       	rjmp	.+4      	; 0xd68 <DIO_WriteChannel+0x68>
     d64:	66 0f       	add	r22, r22
     d66:	77 1f       	adc	r23, r23
     d68:	8a 95       	dec	r24
     d6a:	e2 f7       	brpl	.-8      	; 0xd64 <DIO_WriteChannel+0x64>
     d6c:	cb 01       	movw	r24, r22
     d6e:	84 2b       	or	r24, r20
     d70:	85 bb       	out	0x15, r24	; 21
			break;
     d72:	08 95       	ret
			case 3:
			SET_BIT (PORTD , PIN);
     d74:	42 b3       	in	r20, 0x12	; 18
     d76:	21 e0       	ldi	r18, 0x01	; 1
     d78:	30 e0       	ldi	r19, 0x00	; 0
     d7a:	b9 01       	movw	r22, r18
     d7c:	02 c0       	rjmp	.+4      	; 0xd82 <DIO_WriteChannel+0x82>
     d7e:	66 0f       	add	r22, r22
     d80:	77 1f       	adc	r23, r23
     d82:	8a 95       	dec	r24
     d84:	e2 f7       	brpl	.-8      	; 0xd7e <DIO_WriteChannel+0x7e>
     d86:	cb 01       	movw	r24, r22
     d88:	84 2b       	or	r24, r20
     d8a:	82 bb       	out	0x12, r24	; 18
			break;
     d8c:	08 95       	ret
			break;
		}
		break;
		
		case PIN_LOW :
		switch(PORT)
     d8e:	91 30       	cpi	r25, 0x01	; 1
     d90:	a1 f0       	breq	.+40     	; 0xdba <DIO_WriteChannel+0xba>
     d92:	28 f0       	brcs	.+10     	; 0xd9e <DIO_WriteChannel+0x9e>
     d94:	92 30       	cpi	r25, 0x02	; 2
     d96:	f9 f0       	breq	.+62     	; 0xdd6 <DIO_WriteChannel+0xd6>
     d98:	93 30       	cpi	r25, 0x03	; 3
     d9a:	59 f1       	breq	.+86     	; 0xdf2 <DIO_WriteChannel+0xf2>
     d9c:	08 95       	ret
		{
			case 0:
			CLR_BIT (PORTA , PIN);
     d9e:	4b b3       	in	r20, 0x1b	; 27
     da0:	21 e0       	ldi	r18, 0x01	; 1
     da2:	30 e0       	ldi	r19, 0x00	; 0
     da4:	b9 01       	movw	r22, r18
     da6:	02 c0       	rjmp	.+4      	; 0xdac <DIO_WriteChannel+0xac>
     da8:	66 0f       	add	r22, r22
     daa:	77 1f       	adc	r23, r23
     dac:	8a 95       	dec	r24
     dae:	e2 f7       	brpl	.-8      	; 0xda8 <DIO_WriteChannel+0xa8>
     db0:	cb 01       	movw	r24, r22
     db2:	80 95       	com	r24
     db4:	84 23       	and	r24, r20
     db6:	8b bb       	out	0x1b, r24	; 27
			break;
     db8:	08 95       	ret
			case 1:
			CLR_BIT (PORTB , PIN);
     dba:	48 b3       	in	r20, 0x18	; 24
     dbc:	21 e0       	ldi	r18, 0x01	; 1
     dbe:	30 e0       	ldi	r19, 0x00	; 0
     dc0:	b9 01       	movw	r22, r18
     dc2:	02 c0       	rjmp	.+4      	; 0xdc8 <DIO_WriteChannel+0xc8>
     dc4:	66 0f       	add	r22, r22
     dc6:	77 1f       	adc	r23, r23
     dc8:	8a 95       	dec	r24
     dca:	e2 f7       	brpl	.-8      	; 0xdc4 <DIO_WriteChannel+0xc4>
     dcc:	cb 01       	movw	r24, r22
     dce:	80 95       	com	r24
     dd0:	84 23       	and	r24, r20
     dd2:	88 bb       	out	0x18, r24	; 24
			break;
     dd4:	08 95       	ret
			case 2:
			CLR_BIT (PORTC , PIN);
     dd6:	45 b3       	in	r20, 0x15	; 21
     dd8:	21 e0       	ldi	r18, 0x01	; 1
     dda:	30 e0       	ldi	r19, 0x00	; 0
     ddc:	b9 01       	movw	r22, r18
     dde:	02 c0       	rjmp	.+4      	; 0xde4 <DIO_WriteChannel+0xe4>
     de0:	66 0f       	add	r22, r22
     de2:	77 1f       	adc	r23, r23
     de4:	8a 95       	dec	r24
     de6:	e2 f7       	brpl	.-8      	; 0xde0 <DIO_WriteChannel+0xe0>
     de8:	cb 01       	movw	r24, r22
     dea:	80 95       	com	r24
     dec:	84 23       	and	r24, r20
     dee:	85 bb       	out	0x15, r24	; 21
			break;
     df0:	08 95       	ret
			case 3:
			CLR_BIT (PORTD , PIN);
     df2:	42 b3       	in	r20, 0x12	; 18
     df4:	21 e0       	ldi	r18, 0x01	; 1
     df6:	30 e0       	ldi	r19, 0x00	; 0
     df8:	b9 01       	movw	r22, r18
     dfa:	02 c0       	rjmp	.+4      	; 0xe00 <DIO_WriteChannel+0x100>
     dfc:	66 0f       	add	r22, r22
     dfe:	77 1f       	adc	r23, r23
     e00:	8a 95       	dec	r24
     e02:	e2 f7       	brpl	.-8      	; 0xdfc <DIO_WriteChannel+0xfc>
     e04:	cb 01       	movw	r24, r22
     e06:	80 95       	com	r24
     e08:	84 23       	and	r24, r20
     e0a:	82 bb       	out	0x12, r24	; 18
     e0c:	08 95       	ret

00000e0e <DIO_ReadChannel>:

PIN_VAL_e DIO_ReadChannel (uint8 Pin_Order)
{
		uint8 PORT =0, PIN=0, OUTPUT_Val=0 ;
		PORT= Pin_Order / NUMBER_OF_PORT_PINS;
		PIN=  Pin_Order  % NUMBER_OF_PORT_PINS;
     e0e:	28 2f       	mov	r18, r24
     e10:	27 70       	andi	r18, 0x07	; 7
		
		switch (PORT)
     e12:	86 95       	lsr	r24
     e14:	86 95       	lsr	r24
     e16:	86 95       	lsr	r24
     e18:	81 30       	cpi	r24, 0x01	; 1
     e1a:	79 f0       	breq	.+30     	; 0xe3a <DIO_ReadChannel+0x2c>
     e1c:	28 f0       	brcs	.+10     	; 0xe28 <DIO_ReadChannel+0x1a>
     e1e:	82 30       	cpi	r24, 0x02	; 2
     e20:	a9 f0       	breq	.+42     	; 0xe4c <DIO_ReadChannel+0x3e>
     e22:	83 30       	cpi	r24, 0x03	; 3
     e24:	e1 f0       	breq	.+56     	; 0xe5e <DIO_ReadChannel+0x50>
     e26:	24 c0       	rjmp	.+72     	; 0xe70 <DIO_ReadChannel+0x62>
		{
			case 0:
			OUTPUT_Val= GET_BIT (PINA , PIN);
     e28:	89 b3       	in	r24, 0x19	; 25
     e2a:	90 e0       	ldi	r25, 0x00	; 0
     e2c:	02 c0       	rjmp	.+4      	; 0xe32 <DIO_ReadChannel+0x24>
     e2e:	95 95       	asr	r25
     e30:	87 95       	ror	r24
     e32:	2a 95       	dec	r18
     e34:	e2 f7       	brpl	.-8      	; 0xe2e <DIO_ReadChannel+0x20>
     e36:	81 70       	andi	r24, 0x01	; 1
			break;
     e38:	08 95       	ret
			case 1:
			OUTPUT_Val= GET_BIT (PINB , PIN);
     e3a:	86 b3       	in	r24, 0x16	; 22
     e3c:	90 e0       	ldi	r25, 0x00	; 0
     e3e:	02 c0       	rjmp	.+4      	; 0xe44 <DIO_ReadChannel+0x36>
     e40:	95 95       	asr	r25
     e42:	87 95       	ror	r24
     e44:	2a 95       	dec	r18
     e46:	e2 f7       	brpl	.-8      	; 0xe40 <DIO_ReadChannel+0x32>
     e48:	81 70       	andi	r24, 0x01	; 1
			break;
     e4a:	08 95       	ret
			case 2:
			OUTPUT_Val= GET_BIT (PINC , PIN);
     e4c:	83 b3       	in	r24, 0x13	; 19
     e4e:	90 e0       	ldi	r25, 0x00	; 0
     e50:	02 c0       	rjmp	.+4      	; 0xe56 <DIO_ReadChannel+0x48>
     e52:	95 95       	asr	r25
     e54:	87 95       	ror	r24
     e56:	2a 95       	dec	r18
     e58:	e2 f7       	brpl	.-8      	; 0xe52 <DIO_ReadChannel+0x44>
     e5a:	81 70       	andi	r24, 0x01	; 1
			break;
     e5c:	08 95       	ret
			case 3:
			OUTPUT_Val= GET_BIT (PIND , PIN);
     e5e:	80 b3       	in	r24, 0x10	; 16
     e60:	90 e0       	ldi	r25, 0x00	; 0
     e62:	02 c0       	rjmp	.+4      	; 0xe68 <DIO_ReadChannel+0x5a>
     e64:	95 95       	asr	r25
     e66:	87 95       	ror	r24
     e68:	2a 95       	dec	r18
     e6a:	e2 f7       	brpl	.-8      	; 0xe64 <DIO_ReadChannel+0x56>
     e6c:	81 70       	andi	r24, 0x01	; 1
			break;
     e6e:	08 95       	ret
*                                    E_NOT_OK
*******************************************************************************/

PIN_VAL_e DIO_ReadChannel (uint8 Pin_Order)
{
		uint8 PORT =0, PIN=0, OUTPUT_Val=0 ;
     e70:	80 e0       	ldi	r24, 0x00	; 0
			break;
			default:
			break;
		}
		return OUTPUT_Val;
}
     e72:	08 95       	ret

00000e74 <PORT_Init>:
 */ 

#include "PORT_Core.h"

void PORT_Init(void)
{
     e74:	e0 e6       	ldi	r30, 0x60	; 96
     e76:	f0 e0       	ldi	r31, 0x00	; 0
     e78:	44 e8       	ldi	r20, 0x84	; 132
     e7a:	50 e0       	ldi	r21, 0x00	; 0
					case PORT_A:
					     CLR_BIT(DDRA , PIN);
					break;
					
					case PORT_B:
					     CLR_BIT(DDRB , PIN);
     e7c:	61 e0       	ldi	r22, 0x01	; 1
     e7e:	70 e0       	ldi	r23, 0x00	; 0
void PORT_Init(void)
{
	uint8 cntr=0 , PORT=0 , PIN =0 , DIR= 0;
	for(cntr = 0 ; cntr < DEFINED_PINS ; cntr++ )
	{
		PORT = PORT_Initialization[cntr].PIN_NUM/NUMBER_OF_PORT_PINS;
     e80:	80 81       	ld	r24, Z
     e82:	98 2f       	mov	r25, r24
     e84:	96 95       	lsr	r25
     e86:	96 95       	lsr	r25
     e88:	96 95       	lsr	r25
		PIN =  PORT_Initialization[cntr].PIN_NUM%NUMBER_OF_PORT_PINS;
     e8a:	87 70       	andi	r24, 0x07	; 7
		DIR =  PORT_Initialization[cntr].DIR;
		
		switch (DIR)
     e8c:	21 81       	ldd	r18, Z+1	; 0x01
     e8e:	22 23       	and	r18, r18
     e90:	19 f0       	breq	.+6      	; 0xe98 <PORT_Init+0x24>
     e92:	21 30       	cpi	r18, 0x01	; 1
     e94:	c9 f1       	breq	.+114    	; 0xf08 <PORT_Init+0x94>
     e96:	6b c0       	rjmp	.+214    	; 0xf6e <PORT_Init+0xfa>
		{
			case PIN_DIR_INPUT :
			    switch (PORT)
     e98:	91 30       	cpi	r25, 0x01	; 1
     e9a:	91 f0       	breq	.+36     	; 0xec0 <PORT_Init+0x4c>
     e9c:	28 f0       	brcs	.+10     	; 0xea8 <PORT_Init+0x34>
     e9e:	92 30       	cpi	r25, 0x02	; 2
     ea0:	d9 f0       	breq	.+54     	; 0xed8 <PORT_Init+0x64>
     ea2:	93 30       	cpi	r25, 0x03	; 3
     ea4:	29 f1       	breq	.+74     	; 0xef0 <PORT_Init+0x7c>
     ea6:	63 c0       	rjmp	.+198    	; 0xf6e <PORT_Init+0xfa>
				{
					case PORT_A:
					     CLR_BIT(DDRA , PIN);
     ea8:	9a b3       	in	r25, 0x1a	; 26
     eaa:	9b 01       	movw	r18, r22
     eac:	02 c0       	rjmp	.+4      	; 0xeb2 <PORT_Init+0x3e>
     eae:	22 0f       	add	r18, r18
     eb0:	33 1f       	adc	r19, r19
     eb2:	8a 95       	dec	r24
     eb4:	e2 f7       	brpl	.-8      	; 0xeae <PORT_Init+0x3a>
     eb6:	82 2f       	mov	r24, r18
     eb8:	80 95       	com	r24
     eba:	89 23       	and	r24, r25
     ebc:	8a bb       	out	0x1a, r24	; 26
					break;
     ebe:	57 c0       	rjmp	.+174    	; 0xf6e <PORT_Init+0xfa>
					
					case PORT_B:
					     CLR_BIT(DDRB , PIN);
     ec0:	97 b3       	in	r25, 0x17	; 23
     ec2:	9b 01       	movw	r18, r22
     ec4:	02 c0       	rjmp	.+4      	; 0xeca <PORT_Init+0x56>
     ec6:	22 0f       	add	r18, r18
     ec8:	33 1f       	adc	r19, r19
     eca:	8a 95       	dec	r24
     ecc:	e2 f7       	brpl	.-8      	; 0xec6 <PORT_Init+0x52>
     ece:	82 2f       	mov	r24, r18
     ed0:	80 95       	com	r24
     ed2:	89 23       	and	r24, r25
     ed4:	87 bb       	out	0x17, r24	; 23
					break;
     ed6:	4b c0       	rjmp	.+150    	; 0xf6e <PORT_Init+0xfa>
					
					case PORT_C:
					     CLR_BIT(DDRC , PIN);
     ed8:	94 b3       	in	r25, 0x14	; 20
     eda:	9b 01       	movw	r18, r22
     edc:	02 c0       	rjmp	.+4      	; 0xee2 <PORT_Init+0x6e>
     ede:	22 0f       	add	r18, r18
     ee0:	33 1f       	adc	r19, r19
     ee2:	8a 95       	dec	r24
     ee4:	e2 f7       	brpl	.-8      	; 0xede <PORT_Init+0x6a>
     ee6:	82 2f       	mov	r24, r18
     ee8:	80 95       	com	r24
     eea:	89 23       	and	r24, r25
     eec:	84 bb       	out	0x14, r24	; 20
					break;
     eee:	3f c0       	rjmp	.+126    	; 0xf6e <PORT_Init+0xfa>
					
					case PORT_D:
					     CLR_BIT(DDRD , PIN);
     ef0:	91 b3       	in	r25, 0x11	; 17
     ef2:	9b 01       	movw	r18, r22
     ef4:	02 c0       	rjmp	.+4      	; 0xefa <PORT_Init+0x86>
     ef6:	22 0f       	add	r18, r18
     ef8:	33 1f       	adc	r19, r19
     efa:	8a 95       	dec	r24
     efc:	e2 f7       	brpl	.-8      	; 0xef6 <PORT_Init+0x82>
     efe:	82 2f       	mov	r24, r18
     f00:	80 95       	com	r24
     f02:	89 23       	and	r24, r25
     f04:	81 bb       	out	0x11, r24	; 17
					break;
     f06:	33 c0       	rjmp	.+102    	; 0xf6e <PORT_Init+0xfa>
					break;
				}
			break;
			
			case PIN_DIR_OUTPUT :
			    switch (PORT)
     f08:	91 30       	cpi	r25, 0x01	; 1
     f0a:	89 f0       	breq	.+34     	; 0xf2e <PORT_Init+0xba>
     f0c:	28 f0       	brcs	.+10     	; 0xf18 <PORT_Init+0xa4>
     f0e:	92 30       	cpi	r25, 0x02	; 2
     f10:	c9 f0       	breq	.+50     	; 0xf44 <PORT_Init+0xd0>
     f12:	93 30       	cpi	r25, 0x03	; 3
     f14:	11 f1       	breq	.+68     	; 0xf5a <PORT_Init+0xe6>
     f16:	2b c0       	rjmp	.+86     	; 0xf6e <PORT_Init+0xfa>
			    {
				    case PORT_A:
				    SET_BIT(DDRA , PIN);
     f18:	2a b3       	in	r18, 0x1a	; 26
     f1a:	db 01       	movw	r26, r22
     f1c:	02 c0       	rjmp	.+4      	; 0xf22 <PORT_Init+0xae>
     f1e:	aa 0f       	add	r26, r26
     f20:	bb 1f       	adc	r27, r27
     f22:	8a 95       	dec	r24
     f24:	e2 f7       	brpl	.-8      	; 0xf1e <PORT_Init+0xaa>
     f26:	cd 01       	movw	r24, r26
     f28:	82 2b       	or	r24, r18
     f2a:	8a bb       	out	0x1a, r24	; 26
				    break;
     f2c:	20 c0       	rjmp	.+64     	; 0xf6e <PORT_Init+0xfa>
				    
				    case PORT_B:
				    SET_BIT(DDRB , PIN);
     f2e:	27 b3       	in	r18, 0x17	; 23
     f30:	db 01       	movw	r26, r22
     f32:	02 c0       	rjmp	.+4      	; 0xf38 <PORT_Init+0xc4>
     f34:	aa 0f       	add	r26, r26
     f36:	bb 1f       	adc	r27, r27
     f38:	8a 95       	dec	r24
     f3a:	e2 f7       	brpl	.-8      	; 0xf34 <PORT_Init+0xc0>
     f3c:	cd 01       	movw	r24, r26
     f3e:	82 2b       	or	r24, r18
     f40:	87 bb       	out	0x17, r24	; 23
				    break;
     f42:	15 c0       	rjmp	.+42     	; 0xf6e <PORT_Init+0xfa>
				    
				    case PORT_C:
				    SET_BIT(DDRC , PIN);
     f44:	24 b3       	in	r18, 0x14	; 20
     f46:	db 01       	movw	r26, r22
     f48:	02 c0       	rjmp	.+4      	; 0xf4e <PORT_Init+0xda>
     f4a:	aa 0f       	add	r26, r26
     f4c:	bb 1f       	adc	r27, r27
     f4e:	8a 95       	dec	r24
     f50:	e2 f7       	brpl	.-8      	; 0xf4a <PORT_Init+0xd6>
     f52:	cd 01       	movw	r24, r26
     f54:	82 2b       	or	r24, r18
     f56:	84 bb       	out	0x14, r24	; 20
				    break;
     f58:	0a c0       	rjmp	.+20     	; 0xf6e <PORT_Init+0xfa>
				    
				    case PORT_D:
				    SET_BIT(DDRD , PIN);
     f5a:	21 b3       	in	r18, 0x11	; 17
     f5c:	db 01       	movw	r26, r22
     f5e:	02 c0       	rjmp	.+4      	; 0xf64 <PORT_Init+0xf0>
     f60:	aa 0f       	add	r26, r26
     f62:	bb 1f       	adc	r27, r27
     f64:	8a 95       	dec	r24
     f66:	e2 f7       	brpl	.-8      	; 0xf60 <PORT_Init+0xec>
     f68:	cd 01       	movw	r24, r26
     f6a:	82 2b       	or	r24, r18
     f6c:	81 bb       	out	0x11, r24	; 17
     f6e:	32 96       	adiw	r30, 0x02	; 2
#include "PORT_Core.h"

void PORT_Init(void)
{
	uint8 cntr=0 , PORT=0 , PIN =0 , DIR= 0;
	for(cntr = 0 ; cntr < DEFINED_PINS ; cntr++ )
     f70:	e4 17       	cp	r30, r20
     f72:	f5 07       	cpc	r31, r21
     f74:	09 f0       	breq	.+2      	; 0xf78 <PORT_Init+0x104>
     f76:	84 cf       	rjmp	.-248    	; 0xe80 <PORT_Init+0xc>
			
			default:
			break;
		}
	}
     f78:	08 95       	ret

00000f7a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     f7a:	cf 93       	push	r28
     f7c:	df 93       	push	r29
     f7e:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     f80:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     f84:	80 91 7a 01 	lds	r24, 0x017A	; 0x80017a <pucAlignedHeap.2084>
     f88:	90 91 7b 01 	lds	r25, 0x017B	; 0x80017b <pucAlignedHeap.2084+0x1>
     f8c:	89 2b       	or	r24, r25
     f8e:	31 f4       	brne	.+12     	; 0xf9c <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     f90:	8f e7       	ldi	r24, 0x7F	; 127
     f92:	91 e0       	ldi	r25, 0x01	; 1
     f94:	90 93 7b 01 	sts	0x017B, r25	; 0x80017b <pucAlignedHeap.2084+0x1>
     f98:	80 93 7a 01 	sts	0x017A, r24	; 0x80017a <pucAlignedHeap.2084>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     f9c:	20 91 7c 01 	lds	r18, 0x017C	; 0x80017c <xNextFreeByte>
     fa0:	30 91 7d 01 	lds	r19, 0x017D	; 0x80017d <xNextFreeByte+0x1>
     fa4:	c9 01       	movw	r24, r18
     fa6:	8c 0f       	add	r24, r28
     fa8:	9d 1f       	adc	r25, r29
     faa:	8b 3d       	cpi	r24, 0xDB	; 219
     fac:	45 e0       	ldi	r20, 0x05	; 5
     fae:	94 07       	cpc	r25, r20
     fb0:	70 f4       	brcc	.+28     	; 0xfce <pvPortMalloc+0x54>
     fb2:	28 17       	cp	r18, r24
     fb4:	39 07       	cpc	r19, r25
     fb6:	70 f4       	brcc	.+28     	; 0xfd4 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     fb8:	c0 91 7a 01 	lds	r28, 0x017A	; 0x80017a <pucAlignedHeap.2084>
     fbc:	d0 91 7b 01 	lds	r29, 0x017B	; 0x80017b <pucAlignedHeap.2084+0x1>
     fc0:	c2 0f       	add	r28, r18
     fc2:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     fc4:	90 93 7d 01 	sts	0x017D, r25	; 0x80017d <xNextFreeByte+0x1>
     fc8:	80 93 7c 01 	sts	0x017C, r24	; 0x80017c <xNextFreeByte>
     fcc:	05 c0       	rjmp	.+10     	; 0xfd8 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     fce:	c0 e0       	ldi	r28, 0x00	; 0
     fd0:	d0 e0       	ldi	r29, 0x00	; 0
     fd2:	02 c0       	rjmp	.+4      	; 0xfd8 <pvPortMalloc+0x5e>
     fd4:	c0 e0       	ldi	r28, 0x00	; 0
     fd6:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     fd8:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     fdc:	ce 01       	movw	r24, r28
     fde:	df 91       	pop	r29
     fe0:	cf 91       	pop	r28
     fe2:	08 95       	ret

00000fe4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     fe4:	08 95       	ret

00000fe6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     fe6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     fe8:	03 96       	adiw	r24, 0x03	; 3
     fea:	92 83       	std	Z+2, r25	; 0x02
     fec:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     fee:	2f ef       	ldi	r18, 0xFF	; 255
     ff0:	3f ef       	ldi	r19, 0xFF	; 255
     ff2:	34 83       	std	Z+4, r19	; 0x04
     ff4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     ff6:	96 83       	std	Z+6, r25	; 0x06
     ff8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     ffa:	90 87       	std	Z+8, r25	; 0x08
     ffc:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     ffe:	10 82       	st	Z, r1
    1000:	08 95       	ret

00001002 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1002:	fc 01       	movw	r30, r24
    1004:	11 86       	std	Z+9, r1	; 0x09
    1006:	10 86       	std	Z+8, r1	; 0x08
    1008:	08 95       	ret

0000100a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    100a:	cf 93       	push	r28
    100c:	df 93       	push	r29
    100e:	9c 01       	movw	r18, r24
    1010:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1012:	dc 01       	movw	r26, r24
    1014:	11 96       	adiw	r26, 0x01	; 1
    1016:	cd 91       	ld	r28, X+
    1018:	dc 91       	ld	r29, X
    101a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    101c:	d3 83       	std	Z+3, r29	; 0x03
    101e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1020:	8c 81       	ldd	r24, Y+4	; 0x04
    1022:	9d 81       	ldd	r25, Y+5	; 0x05
    1024:	95 83       	std	Z+5, r25	; 0x05
    1026:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1028:	8c 81       	ldd	r24, Y+4	; 0x04
    102a:	9d 81       	ldd	r25, Y+5	; 0x05
    102c:	dc 01       	movw	r26, r24
    102e:	13 96       	adiw	r26, 0x03	; 3
    1030:	7c 93       	st	X, r23
    1032:	6e 93       	st	-X, r22
    1034:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1036:	7d 83       	std	Y+5, r23	; 0x05
    1038:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    103a:	31 87       	std	Z+9, r19	; 0x09
    103c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    103e:	f9 01       	movw	r30, r18
    1040:	80 81       	ld	r24, Z
    1042:	8f 5f       	subi	r24, 0xFF	; 255
    1044:	80 83       	st	Z, r24
}
    1046:	df 91       	pop	r29
    1048:	cf 91       	pop	r28
    104a:	08 95       	ret

0000104c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    104c:	cf 93       	push	r28
    104e:	df 93       	push	r29
    1050:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1052:	48 81       	ld	r20, Y
    1054:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1056:	4f 3f       	cpi	r20, 0xFF	; 255
    1058:	2f ef       	ldi	r18, 0xFF	; 255
    105a:	52 07       	cpc	r21, r18
    105c:	21 f4       	brne	.+8      	; 0x1066 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    105e:	fc 01       	movw	r30, r24
    1060:	a7 81       	ldd	r26, Z+7	; 0x07
    1062:	b0 85       	ldd	r27, Z+8	; 0x08
    1064:	0d c0       	rjmp	.+26     	; 0x1080 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1066:	dc 01       	movw	r26, r24
    1068:	13 96       	adiw	r26, 0x03	; 3
    106a:	01 c0       	rjmp	.+2      	; 0x106e <vListInsert+0x22>
    106c:	df 01       	movw	r26, r30
    106e:	12 96       	adiw	r26, 0x02	; 2
    1070:	ed 91       	ld	r30, X+
    1072:	fc 91       	ld	r31, X
    1074:	13 97       	sbiw	r26, 0x03	; 3
    1076:	20 81       	ld	r18, Z
    1078:	31 81       	ldd	r19, Z+1	; 0x01
    107a:	42 17       	cp	r20, r18
    107c:	53 07       	cpc	r21, r19
    107e:	b0 f7       	brcc	.-20     	; 0x106c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1080:	12 96       	adiw	r26, 0x02	; 2
    1082:	ed 91       	ld	r30, X+
    1084:	fc 91       	ld	r31, X
    1086:	13 97       	sbiw	r26, 0x03	; 3
    1088:	fb 83       	std	Y+3, r31	; 0x03
    108a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    108c:	d5 83       	std	Z+5, r29	; 0x05
    108e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1090:	bd 83       	std	Y+5, r27	; 0x05
    1092:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1094:	13 96       	adiw	r26, 0x03	; 3
    1096:	dc 93       	st	X, r29
    1098:	ce 93       	st	-X, r28
    109a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    109c:	99 87       	std	Y+9, r25	; 0x09
    109e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    10a0:	fc 01       	movw	r30, r24
    10a2:	20 81       	ld	r18, Z
    10a4:	2f 5f       	subi	r18, 0xFF	; 255
    10a6:	20 83       	st	Z, r18
}
    10a8:	df 91       	pop	r29
    10aa:	cf 91       	pop	r28
    10ac:	08 95       	ret

000010ae <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    10ae:	cf 93       	push	r28
    10b0:	df 93       	push	r29
    10b2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    10b4:	a0 85       	ldd	r26, Z+8	; 0x08
    10b6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    10b8:	c2 81       	ldd	r28, Z+2	; 0x02
    10ba:	d3 81       	ldd	r29, Z+3	; 0x03
    10bc:	84 81       	ldd	r24, Z+4	; 0x04
    10be:	95 81       	ldd	r25, Z+5	; 0x05
    10c0:	9d 83       	std	Y+5, r25	; 0x05
    10c2:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    10c4:	c4 81       	ldd	r28, Z+4	; 0x04
    10c6:	d5 81       	ldd	r29, Z+5	; 0x05
    10c8:	82 81       	ldd	r24, Z+2	; 0x02
    10ca:	93 81       	ldd	r25, Z+3	; 0x03
    10cc:	9b 83       	std	Y+3, r25	; 0x03
    10ce:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    10d0:	11 96       	adiw	r26, 0x01	; 1
    10d2:	8d 91       	ld	r24, X+
    10d4:	9c 91       	ld	r25, X
    10d6:	12 97       	sbiw	r26, 0x02	; 2
    10d8:	e8 17       	cp	r30, r24
    10da:	f9 07       	cpc	r31, r25
    10dc:	31 f4       	brne	.+12     	; 0x10ea <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    10de:	84 81       	ldd	r24, Z+4	; 0x04
    10e0:	95 81       	ldd	r25, Z+5	; 0x05
    10e2:	12 96       	adiw	r26, 0x02	; 2
    10e4:	9c 93       	st	X, r25
    10e6:	8e 93       	st	-X, r24
    10e8:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    10ea:	11 86       	std	Z+9, r1	; 0x09
    10ec:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    10ee:	8c 91       	ld	r24, X
    10f0:	81 50       	subi	r24, 0x01	; 1
    10f2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    10f4:	8c 91       	ld	r24, X
}
    10f6:	df 91       	pop	r29
    10f8:	cf 91       	pop	r28
    10fa:	08 95       	ret

000010fc <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    10fc:	31 e1       	ldi	r19, 0x11	; 17
    10fe:	fc 01       	movw	r30, r24
    1100:	30 83       	st	Z, r19
    1102:	31 97       	sbiw	r30, 0x01	; 1
    1104:	22 e2       	ldi	r18, 0x22	; 34
    1106:	20 83       	st	Z, r18
    1108:	31 97       	sbiw	r30, 0x01	; 1
    110a:	a3 e3       	ldi	r26, 0x33	; 51
    110c:	a0 83       	st	Z, r26
    110e:	31 97       	sbiw	r30, 0x01	; 1
    1110:	60 83       	st	Z, r22
    1112:	31 97       	sbiw	r30, 0x01	; 1
    1114:	70 83       	st	Z, r23
    1116:	31 97       	sbiw	r30, 0x01	; 1
    1118:	10 82       	st	Z, r1
    111a:	31 97       	sbiw	r30, 0x01	; 1
    111c:	60 e8       	ldi	r22, 0x80	; 128
    111e:	60 83       	st	Z, r22
    1120:	31 97       	sbiw	r30, 0x01	; 1
    1122:	10 82       	st	Z, r1
    1124:	31 97       	sbiw	r30, 0x01	; 1
    1126:	62 e0       	ldi	r22, 0x02	; 2
    1128:	60 83       	st	Z, r22
    112a:	31 97       	sbiw	r30, 0x01	; 1
    112c:	63 e0       	ldi	r22, 0x03	; 3
    112e:	60 83       	st	Z, r22
    1130:	31 97       	sbiw	r30, 0x01	; 1
    1132:	64 e0       	ldi	r22, 0x04	; 4
    1134:	60 83       	st	Z, r22
    1136:	31 97       	sbiw	r30, 0x01	; 1
    1138:	65 e0       	ldi	r22, 0x05	; 5
    113a:	60 83       	st	Z, r22
    113c:	31 97       	sbiw	r30, 0x01	; 1
    113e:	66 e0       	ldi	r22, 0x06	; 6
    1140:	60 83       	st	Z, r22
    1142:	31 97       	sbiw	r30, 0x01	; 1
    1144:	67 e0       	ldi	r22, 0x07	; 7
    1146:	60 83       	st	Z, r22
    1148:	31 97       	sbiw	r30, 0x01	; 1
    114a:	68 e0       	ldi	r22, 0x08	; 8
    114c:	60 83       	st	Z, r22
    114e:	31 97       	sbiw	r30, 0x01	; 1
    1150:	69 e0       	ldi	r22, 0x09	; 9
    1152:	60 83       	st	Z, r22
    1154:	31 97       	sbiw	r30, 0x01	; 1
    1156:	60 e1       	ldi	r22, 0x10	; 16
    1158:	60 83       	st	Z, r22
    115a:	31 97       	sbiw	r30, 0x01	; 1
    115c:	30 83       	st	Z, r19
    115e:	31 97       	sbiw	r30, 0x01	; 1
    1160:	32 e1       	ldi	r19, 0x12	; 18
    1162:	30 83       	st	Z, r19
    1164:	31 97       	sbiw	r30, 0x01	; 1
    1166:	33 e1       	ldi	r19, 0x13	; 19
    1168:	30 83       	st	Z, r19
    116a:	31 97       	sbiw	r30, 0x01	; 1
    116c:	34 e1       	ldi	r19, 0x14	; 20
    116e:	30 83       	st	Z, r19
    1170:	31 97       	sbiw	r30, 0x01	; 1
    1172:	35 e1       	ldi	r19, 0x15	; 21
    1174:	30 83       	st	Z, r19
    1176:	31 97       	sbiw	r30, 0x01	; 1
    1178:	36 e1       	ldi	r19, 0x16	; 22
    117a:	30 83       	st	Z, r19
    117c:	31 97       	sbiw	r30, 0x01	; 1
    117e:	37 e1       	ldi	r19, 0x17	; 23
    1180:	30 83       	st	Z, r19
    1182:	31 97       	sbiw	r30, 0x01	; 1
    1184:	38 e1       	ldi	r19, 0x18	; 24
    1186:	30 83       	st	Z, r19
    1188:	31 97       	sbiw	r30, 0x01	; 1
    118a:	39 e1       	ldi	r19, 0x19	; 25
    118c:	30 83       	st	Z, r19
    118e:	31 97       	sbiw	r30, 0x01	; 1
    1190:	30 e2       	ldi	r19, 0x20	; 32
    1192:	30 83       	st	Z, r19
    1194:	31 97       	sbiw	r30, 0x01	; 1
    1196:	31 e2       	ldi	r19, 0x21	; 33
    1198:	30 83       	st	Z, r19
    119a:	31 97       	sbiw	r30, 0x01	; 1
    119c:	20 83       	st	Z, r18
    119e:	31 97       	sbiw	r30, 0x01	; 1
    11a0:	23 e2       	ldi	r18, 0x23	; 35
    11a2:	20 83       	st	Z, r18
    11a4:	31 97       	sbiw	r30, 0x01	; 1
    11a6:	40 83       	st	Z, r20
    11a8:	31 97       	sbiw	r30, 0x01	; 1
    11aa:	50 83       	st	Z, r21
    11ac:	31 97       	sbiw	r30, 0x01	; 1
    11ae:	26 e2       	ldi	r18, 0x26	; 38
    11b0:	20 83       	st	Z, r18
    11b2:	31 97       	sbiw	r30, 0x01	; 1
    11b4:	27 e2       	ldi	r18, 0x27	; 39
    11b6:	20 83       	st	Z, r18
    11b8:	31 97       	sbiw	r30, 0x01	; 1
    11ba:	28 e2       	ldi	r18, 0x28	; 40
    11bc:	20 83       	st	Z, r18
    11be:	31 97       	sbiw	r30, 0x01	; 1
    11c0:	29 e2       	ldi	r18, 0x29	; 41
    11c2:	20 83       	st	Z, r18
    11c4:	31 97       	sbiw	r30, 0x01	; 1
    11c6:	20 e3       	ldi	r18, 0x30	; 48
    11c8:	20 83       	st	Z, r18
    11ca:	31 97       	sbiw	r30, 0x01	; 1
    11cc:	21 e3       	ldi	r18, 0x31	; 49
    11ce:	20 83       	st	Z, r18
    11d0:	86 97       	sbiw	r24, 0x26	; 38
    11d2:	08 95       	ret

000011d4 <xPortStartScheduler>:
    11d4:	1b bc       	out	0x2b, r1	; 43
    11d6:	89 ef       	ldi	r24, 0xF9	; 249
    11d8:	8a bd       	out	0x2a, r24	; 42
    11da:	8b e0       	ldi	r24, 0x0B	; 11
    11dc:	8e bd       	out	0x2e, r24	; 46
    11de:	89 b7       	in	r24, 0x39	; 57
    11e0:	80 61       	ori	r24, 0x10	; 16
    11e2:	89 bf       	out	0x39, r24	; 57
    11e4:	a0 91 be 07 	lds	r26, 0x07BE	; 0x8007be <pxCurrentTCB>
    11e8:	b0 91 bf 07 	lds	r27, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    11ec:	cd 91       	ld	r28, X+
    11ee:	cd bf       	out	0x3d, r28	; 61
    11f0:	dd 91       	ld	r29, X+
    11f2:	de bf       	out	0x3e, r29	; 62
    11f4:	ff 91       	pop	r31
    11f6:	ef 91       	pop	r30
    11f8:	df 91       	pop	r29
    11fa:	cf 91       	pop	r28
    11fc:	bf 91       	pop	r27
    11fe:	af 91       	pop	r26
    1200:	9f 91       	pop	r25
    1202:	8f 91       	pop	r24
    1204:	7f 91       	pop	r23
    1206:	6f 91       	pop	r22
    1208:	5f 91       	pop	r21
    120a:	4f 91       	pop	r20
    120c:	3f 91       	pop	r19
    120e:	2f 91       	pop	r18
    1210:	1f 91       	pop	r17
    1212:	0f 91       	pop	r16
    1214:	ff 90       	pop	r15
    1216:	ef 90       	pop	r14
    1218:	df 90       	pop	r13
    121a:	cf 90       	pop	r12
    121c:	bf 90       	pop	r11
    121e:	af 90       	pop	r10
    1220:	9f 90       	pop	r9
    1222:	8f 90       	pop	r8
    1224:	7f 90       	pop	r7
    1226:	6f 90       	pop	r6
    1228:	5f 90       	pop	r5
    122a:	4f 90       	pop	r4
    122c:	3f 90       	pop	r3
    122e:	2f 90       	pop	r2
    1230:	1f 90       	pop	r1
    1232:	0f 90       	pop	r0
    1234:	0f be       	out	0x3f, r0	; 63
    1236:	0f 90       	pop	r0
    1238:	08 95       	ret
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	08 95       	ret

0000123e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    123e:	0f 92       	push	r0
    1240:	0f b6       	in	r0, 0x3f	; 63
    1242:	f8 94       	cli
    1244:	0f 92       	push	r0
    1246:	1f 92       	push	r1
    1248:	11 24       	eor	r1, r1
    124a:	2f 92       	push	r2
    124c:	3f 92       	push	r3
    124e:	4f 92       	push	r4
    1250:	5f 92       	push	r5
    1252:	6f 92       	push	r6
    1254:	7f 92       	push	r7
    1256:	8f 92       	push	r8
    1258:	9f 92       	push	r9
    125a:	af 92       	push	r10
    125c:	bf 92       	push	r11
    125e:	cf 92       	push	r12
    1260:	df 92       	push	r13
    1262:	ef 92       	push	r14
    1264:	ff 92       	push	r15
    1266:	0f 93       	push	r16
    1268:	1f 93       	push	r17
    126a:	2f 93       	push	r18
    126c:	3f 93       	push	r19
    126e:	4f 93       	push	r20
    1270:	5f 93       	push	r21
    1272:	6f 93       	push	r22
    1274:	7f 93       	push	r23
    1276:	8f 93       	push	r24
    1278:	9f 93       	push	r25
    127a:	af 93       	push	r26
    127c:	bf 93       	push	r27
    127e:	cf 93       	push	r28
    1280:	df 93       	push	r29
    1282:	ef 93       	push	r30
    1284:	ff 93       	push	r31
    1286:	a0 91 be 07 	lds	r26, 0x07BE	; 0x8007be <pxCurrentTCB>
    128a:	b0 91 bf 07 	lds	r27, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    128e:	0d b6       	in	r0, 0x3d	; 61
    1290:	0d 92       	st	X+, r0
    1292:	0e b6       	in	r0, 0x3e	; 62
    1294:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1296:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    129a:	a0 91 be 07 	lds	r26, 0x07BE	; 0x8007be <pxCurrentTCB>
    129e:	b0 91 bf 07 	lds	r27, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    12a2:	cd 91       	ld	r28, X+
    12a4:	cd bf       	out	0x3d, r28	; 61
    12a6:	dd 91       	ld	r29, X+
    12a8:	de bf       	out	0x3e, r29	; 62
    12aa:	ff 91       	pop	r31
    12ac:	ef 91       	pop	r30
    12ae:	df 91       	pop	r29
    12b0:	cf 91       	pop	r28
    12b2:	bf 91       	pop	r27
    12b4:	af 91       	pop	r26
    12b6:	9f 91       	pop	r25
    12b8:	8f 91       	pop	r24
    12ba:	7f 91       	pop	r23
    12bc:	6f 91       	pop	r22
    12be:	5f 91       	pop	r21
    12c0:	4f 91       	pop	r20
    12c2:	3f 91       	pop	r19
    12c4:	2f 91       	pop	r18
    12c6:	1f 91       	pop	r17
    12c8:	0f 91       	pop	r16
    12ca:	ff 90       	pop	r15
    12cc:	ef 90       	pop	r14
    12ce:	df 90       	pop	r13
    12d0:	cf 90       	pop	r12
    12d2:	bf 90       	pop	r11
    12d4:	af 90       	pop	r10
    12d6:	9f 90       	pop	r9
    12d8:	8f 90       	pop	r8
    12da:	7f 90       	pop	r7
    12dc:	6f 90       	pop	r6
    12de:	5f 90       	pop	r5
    12e0:	4f 90       	pop	r4
    12e2:	3f 90       	pop	r3
    12e4:	2f 90       	pop	r2
    12e6:	1f 90       	pop	r1
    12e8:	0f 90       	pop	r0
    12ea:	0f be       	out	0x3f, r0	; 63
    12ec:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12ee:	08 95       	ret

000012f0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    12f0:	0f 92       	push	r0
    12f2:	0f b6       	in	r0, 0x3f	; 63
    12f4:	f8 94       	cli
    12f6:	0f 92       	push	r0
    12f8:	1f 92       	push	r1
    12fa:	11 24       	eor	r1, r1
    12fc:	2f 92       	push	r2
    12fe:	3f 92       	push	r3
    1300:	4f 92       	push	r4
    1302:	5f 92       	push	r5
    1304:	6f 92       	push	r6
    1306:	7f 92       	push	r7
    1308:	8f 92       	push	r8
    130a:	9f 92       	push	r9
    130c:	af 92       	push	r10
    130e:	bf 92       	push	r11
    1310:	cf 92       	push	r12
    1312:	df 92       	push	r13
    1314:	ef 92       	push	r14
    1316:	ff 92       	push	r15
    1318:	0f 93       	push	r16
    131a:	1f 93       	push	r17
    131c:	2f 93       	push	r18
    131e:	3f 93       	push	r19
    1320:	4f 93       	push	r20
    1322:	5f 93       	push	r21
    1324:	6f 93       	push	r22
    1326:	7f 93       	push	r23
    1328:	8f 93       	push	r24
    132a:	9f 93       	push	r25
    132c:	af 93       	push	r26
    132e:	bf 93       	push	r27
    1330:	cf 93       	push	r28
    1332:	df 93       	push	r29
    1334:	ef 93       	push	r30
    1336:	ff 93       	push	r31
    1338:	a0 91 be 07 	lds	r26, 0x07BE	; 0x8007be <pxCurrentTCB>
    133c:	b0 91 bf 07 	lds	r27, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    1340:	0d b6       	in	r0, 0x3d	; 61
    1342:	0d 92       	st	X+, r0
    1344:	0e b6       	in	r0, 0x3e	; 62
    1346:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1348:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <xTaskIncrementTick>
    134c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    134e:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1352:	a0 91 be 07 	lds	r26, 0x07BE	; 0x8007be <pxCurrentTCB>
    1356:	b0 91 bf 07 	lds	r27, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    135a:	cd 91       	ld	r28, X+
    135c:	cd bf       	out	0x3d, r28	; 61
    135e:	dd 91       	ld	r29, X+
    1360:	de bf       	out	0x3e, r29	; 62
    1362:	ff 91       	pop	r31
    1364:	ef 91       	pop	r30
    1366:	df 91       	pop	r29
    1368:	cf 91       	pop	r28
    136a:	bf 91       	pop	r27
    136c:	af 91       	pop	r26
    136e:	9f 91       	pop	r25
    1370:	8f 91       	pop	r24
    1372:	7f 91       	pop	r23
    1374:	6f 91       	pop	r22
    1376:	5f 91       	pop	r21
    1378:	4f 91       	pop	r20
    137a:	3f 91       	pop	r19
    137c:	2f 91       	pop	r18
    137e:	1f 91       	pop	r17
    1380:	0f 91       	pop	r16
    1382:	ff 90       	pop	r15
    1384:	ef 90       	pop	r14
    1386:	df 90       	pop	r13
    1388:	cf 90       	pop	r12
    138a:	bf 90       	pop	r11
    138c:	af 90       	pop	r10
    138e:	9f 90       	pop	r9
    1390:	8f 90       	pop	r8
    1392:	7f 90       	pop	r7
    1394:	6f 90       	pop	r6
    1396:	5f 90       	pop	r5
    1398:	4f 90       	pop	r4
    139a:	3f 90       	pop	r3
    139c:	2f 90       	pop	r2
    139e:	1f 90       	pop	r1
    13a0:	0f 90       	pop	r0
    13a2:	0f be       	out	0x3f, r0	; 63
    13a4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    13a6:	08 95       	ret

000013a8 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    13a8:	0e 94 78 09 	call	0x12f0	; 0x12f0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    13ac:	18 95       	reti

000013ae <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    13ae:	0f b6       	in	r0, 0x3f	; 63
    13b0:	f8 94       	cli
    13b2:	0f 92       	push	r0
    13b4:	fc 01       	movw	r30, r24
    13b6:	92 8d       	ldd	r25, Z+26	; 0x1a
    13b8:	0f 90       	pop	r0
    13ba:	0f be       	out	0x3f, r0	; 63
    13bc:	81 e0       	ldi	r24, 0x01	; 1
    13be:	91 11       	cpse	r25, r1
    13c0:	80 e0       	ldi	r24, 0x00	; 0
    13c2:	08 95       	ret

000013c4 <prvCopyDataToQueue>:
    13c4:	0f 93       	push	r16
    13c6:	1f 93       	push	r17
    13c8:	cf 93       	push	r28
    13ca:	df 93       	push	r29
    13cc:	ec 01       	movw	r28, r24
    13ce:	04 2f       	mov	r16, r20
    13d0:	1a 8d       	ldd	r17, Y+26	; 0x1a
    13d2:	4c 8d       	ldd	r20, Y+28	; 0x1c
    13d4:	44 23       	and	r20, r20
    13d6:	b9 f1       	breq	.+110    	; 0x1446 <prvCopyDataToQueue+0x82>
    13d8:	01 11       	cpse	r16, r1
    13da:	16 c0       	rjmp	.+44     	; 0x1408 <prvCopyDataToQueue+0x44>
    13dc:	50 e0       	ldi	r21, 0x00	; 0
    13de:	8a 81       	ldd	r24, Y+2	; 0x02
    13e0:	9b 81       	ldd	r25, Y+3	; 0x03
    13e2:	0e 94 80 12 	call	0x2500	; 0x2500 <memcpy>
    13e6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    13e8:	8a 81       	ldd	r24, Y+2	; 0x02
    13ea:	9b 81       	ldd	r25, Y+3	; 0x03
    13ec:	82 0f       	add	r24, r18
    13ee:	91 1d       	adc	r25, r1
    13f0:	9b 83       	std	Y+3, r25	; 0x03
    13f2:	8a 83       	std	Y+2, r24	; 0x02
    13f4:	2c 81       	ldd	r18, Y+4	; 0x04
    13f6:	3d 81       	ldd	r19, Y+5	; 0x05
    13f8:	82 17       	cp	r24, r18
    13fa:	93 07       	cpc	r25, r19
    13fc:	20 f1       	brcs	.+72     	; 0x1446 <prvCopyDataToQueue+0x82>
    13fe:	88 81       	ld	r24, Y
    1400:	99 81       	ldd	r25, Y+1	; 0x01
    1402:	9b 83       	std	Y+3, r25	; 0x03
    1404:	8a 83       	std	Y+2, r24	; 0x02
    1406:	1f c0       	rjmp	.+62     	; 0x1446 <prvCopyDataToQueue+0x82>
    1408:	50 e0       	ldi	r21, 0x00	; 0
    140a:	8e 81       	ldd	r24, Y+6	; 0x06
    140c:	9f 81       	ldd	r25, Y+7	; 0x07
    140e:	0e 94 80 12 	call	0x2500	; 0x2500 <memcpy>
    1412:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1414:	90 e0       	ldi	r25, 0x00	; 0
    1416:	91 95       	neg	r25
    1418:	81 95       	neg	r24
    141a:	91 09       	sbc	r25, r1
    141c:	2e 81       	ldd	r18, Y+6	; 0x06
    141e:	3f 81       	ldd	r19, Y+7	; 0x07
    1420:	28 0f       	add	r18, r24
    1422:	39 1f       	adc	r19, r25
    1424:	3f 83       	std	Y+7, r19	; 0x07
    1426:	2e 83       	std	Y+6, r18	; 0x06
    1428:	48 81       	ld	r20, Y
    142a:	59 81       	ldd	r21, Y+1	; 0x01
    142c:	24 17       	cp	r18, r20
    142e:	35 07       	cpc	r19, r21
    1430:	30 f4       	brcc	.+12     	; 0x143e <prvCopyDataToQueue+0x7a>
    1432:	2c 81       	ldd	r18, Y+4	; 0x04
    1434:	3d 81       	ldd	r19, Y+5	; 0x05
    1436:	82 0f       	add	r24, r18
    1438:	93 1f       	adc	r25, r19
    143a:	9f 83       	std	Y+7, r25	; 0x07
    143c:	8e 83       	std	Y+6, r24	; 0x06
    143e:	02 30       	cpi	r16, 0x02	; 2
    1440:	11 f4       	brne	.+4      	; 0x1446 <prvCopyDataToQueue+0x82>
    1442:	11 11       	cpse	r17, r1
    1444:	11 50       	subi	r17, 0x01	; 1
    1446:	1f 5f       	subi	r17, 0xFF	; 255
    1448:	1a 8f       	std	Y+26, r17	; 0x1a
    144a:	80 e0       	ldi	r24, 0x00	; 0
    144c:	df 91       	pop	r29
    144e:	cf 91       	pop	r28
    1450:	1f 91       	pop	r17
    1452:	0f 91       	pop	r16
    1454:	08 95       	ret

00001456 <prvCopyDataFromQueue>:
    1456:	fc 01       	movw	r30, r24
    1458:	44 8d       	ldd	r20, Z+28	; 0x1c
    145a:	44 23       	and	r20, r20
    145c:	a9 f0       	breq	.+42     	; 0x1488 <prvCopyDataFromQueue+0x32>
    145e:	50 e0       	ldi	r21, 0x00	; 0
    1460:	26 81       	ldd	r18, Z+6	; 0x06
    1462:	37 81       	ldd	r19, Z+7	; 0x07
    1464:	24 0f       	add	r18, r20
    1466:	35 1f       	adc	r19, r21
    1468:	37 83       	std	Z+7, r19	; 0x07
    146a:	26 83       	std	Z+6, r18	; 0x06
    146c:	84 81       	ldd	r24, Z+4	; 0x04
    146e:	95 81       	ldd	r25, Z+5	; 0x05
    1470:	28 17       	cp	r18, r24
    1472:	39 07       	cpc	r19, r25
    1474:	20 f0       	brcs	.+8      	; 0x147e <prvCopyDataFromQueue+0x28>
    1476:	80 81       	ld	r24, Z
    1478:	91 81       	ldd	r25, Z+1	; 0x01
    147a:	97 83       	std	Z+7, r25	; 0x07
    147c:	86 83       	std	Z+6, r24	; 0x06
    147e:	cb 01       	movw	r24, r22
    1480:	66 81       	ldd	r22, Z+6	; 0x06
    1482:	77 81       	ldd	r23, Z+7	; 0x07
    1484:	0e 94 80 12 	call	0x2500	; 0x2500 <memcpy>
    1488:	08 95       	ret

0000148a <prvUnlockQueue>:
    148a:	ef 92       	push	r14
    148c:	ff 92       	push	r15
    148e:	0f 93       	push	r16
    1490:	1f 93       	push	r17
    1492:	cf 93       	push	r28
    1494:	8c 01       	movw	r16, r24
    1496:	0f b6       	in	r0, 0x3f	; 63
    1498:	f8 94       	cli
    149a:	0f 92       	push	r0
    149c:	fc 01       	movw	r30, r24
    149e:	c6 8d       	ldd	r28, Z+30	; 0x1e
    14a0:	1c 16       	cp	r1, r28
    14a2:	ac f4       	brge	.+42     	; 0x14ce <prvUnlockQueue+0x44>
    14a4:	81 89       	ldd	r24, Z+17	; 0x11
    14a6:	81 11       	cpse	r24, r1
    14a8:	06 c0       	rjmp	.+12     	; 0x14b6 <prvUnlockQueue+0x2c>
    14aa:	11 c0       	rjmp	.+34     	; 0x14ce <prvUnlockQueue+0x44>
    14ac:	f8 01       	movw	r30, r16
    14ae:	81 89       	ldd	r24, Z+17	; 0x11
    14b0:	81 11       	cpse	r24, r1
    14b2:	05 c0       	rjmp	.+10     	; 0x14be <prvUnlockQueue+0x34>
    14b4:	0c c0       	rjmp	.+24     	; 0x14ce <prvUnlockQueue+0x44>
    14b6:	78 01       	movw	r14, r16
    14b8:	f1 e1       	ldi	r31, 0x11	; 17
    14ba:	ef 0e       	add	r14, r31
    14bc:	f1 1c       	adc	r15, r1
    14be:	c7 01       	movw	r24, r14
    14c0:	0e 94 3c 10 	call	0x2078	; 0x2078 <xTaskRemoveFromEventList>
    14c4:	81 11       	cpse	r24, r1
    14c6:	0e 94 c5 10 	call	0x218a	; 0x218a <vTaskMissedYield>
    14ca:	c1 50       	subi	r28, 0x01	; 1
    14cc:	79 f7       	brne	.-34     	; 0x14ac <prvUnlockQueue+0x22>
    14ce:	8f ef       	ldi	r24, 0xFF	; 255
    14d0:	f8 01       	movw	r30, r16
    14d2:	86 8f       	std	Z+30, r24	; 0x1e
    14d4:	0f 90       	pop	r0
    14d6:	0f be       	out	0x3f, r0	; 63
    14d8:	0f b6       	in	r0, 0x3f	; 63
    14da:	f8 94       	cli
    14dc:	0f 92       	push	r0
    14de:	c5 8d       	ldd	r28, Z+29	; 0x1d
    14e0:	1c 16       	cp	r1, r28
    14e2:	ac f4       	brge	.+42     	; 0x150e <prvUnlockQueue+0x84>
    14e4:	80 85       	ldd	r24, Z+8	; 0x08
    14e6:	81 11       	cpse	r24, r1
    14e8:	06 c0       	rjmp	.+12     	; 0x14f6 <prvUnlockQueue+0x6c>
    14ea:	11 c0       	rjmp	.+34     	; 0x150e <prvUnlockQueue+0x84>
    14ec:	f8 01       	movw	r30, r16
    14ee:	80 85       	ldd	r24, Z+8	; 0x08
    14f0:	81 11       	cpse	r24, r1
    14f2:	05 c0       	rjmp	.+10     	; 0x14fe <prvUnlockQueue+0x74>
    14f4:	0c c0       	rjmp	.+24     	; 0x150e <prvUnlockQueue+0x84>
    14f6:	78 01       	movw	r14, r16
    14f8:	f8 e0       	ldi	r31, 0x08	; 8
    14fa:	ef 0e       	add	r14, r31
    14fc:	f1 1c       	adc	r15, r1
    14fe:	c7 01       	movw	r24, r14
    1500:	0e 94 3c 10 	call	0x2078	; 0x2078 <xTaskRemoveFromEventList>
    1504:	81 11       	cpse	r24, r1
    1506:	0e 94 c5 10 	call	0x218a	; 0x218a <vTaskMissedYield>
    150a:	c1 50       	subi	r28, 0x01	; 1
    150c:	79 f7       	brne	.-34     	; 0x14ec <prvUnlockQueue+0x62>
    150e:	8f ef       	ldi	r24, 0xFF	; 255
    1510:	f8 01       	movw	r30, r16
    1512:	85 8f       	std	Z+29, r24	; 0x1d
    1514:	0f 90       	pop	r0
    1516:	0f be       	out	0x3f, r0	; 63
    1518:	cf 91       	pop	r28
    151a:	1f 91       	pop	r17
    151c:	0f 91       	pop	r16
    151e:	ff 90       	pop	r15
    1520:	ef 90       	pop	r14
    1522:	08 95       	ret

00001524 <xQueueGenericReset>:
    1524:	cf 93       	push	r28
    1526:	df 93       	push	r29
    1528:	ec 01       	movw	r28, r24
    152a:	0f b6       	in	r0, 0x3f	; 63
    152c:	f8 94       	cli
    152e:	0f 92       	push	r0
    1530:	e8 81       	ld	r30, Y
    1532:	f9 81       	ldd	r31, Y+1	; 0x01
    1534:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1536:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1538:	90 e0       	ldi	r25, 0x00	; 0
    153a:	30 e0       	ldi	r19, 0x00	; 0
    153c:	82 9f       	mul	r24, r18
    153e:	a0 01       	movw	r20, r0
    1540:	83 9f       	mul	r24, r19
    1542:	50 0d       	add	r21, r0
    1544:	92 9f       	mul	r25, r18
    1546:	50 0d       	add	r21, r0
    1548:	11 24       	eor	r1, r1
    154a:	4e 0f       	add	r20, r30
    154c:	5f 1f       	adc	r21, r31
    154e:	5d 83       	std	Y+5, r21	; 0x05
    1550:	4c 83       	std	Y+4, r20	; 0x04
    1552:	1a 8e       	std	Y+26, r1	; 0x1a
    1554:	fb 83       	std	Y+3, r31	; 0x03
    1556:	ea 83       	std	Y+2, r30	; 0x02
    1558:	01 97       	sbiw	r24, 0x01	; 1
    155a:	82 9f       	mul	r24, r18
    155c:	a0 01       	movw	r20, r0
    155e:	83 9f       	mul	r24, r19
    1560:	50 0d       	add	r21, r0
    1562:	92 9f       	mul	r25, r18
    1564:	50 0d       	add	r21, r0
    1566:	11 24       	eor	r1, r1
    1568:	cf 01       	movw	r24, r30
    156a:	84 0f       	add	r24, r20
    156c:	95 1f       	adc	r25, r21
    156e:	9f 83       	std	Y+7, r25	; 0x07
    1570:	8e 83       	std	Y+6, r24	; 0x06
    1572:	8f ef       	ldi	r24, 0xFF	; 255
    1574:	8d 8f       	std	Y+29, r24	; 0x1d
    1576:	8e 8f       	std	Y+30, r24	; 0x1e
    1578:	61 11       	cpse	r22, r1
    157a:	0c c0       	rjmp	.+24     	; 0x1594 <xQueueGenericReset+0x70>
    157c:	88 85       	ldd	r24, Y+8	; 0x08
    157e:	88 23       	and	r24, r24
    1580:	89 f0       	breq	.+34     	; 0x15a4 <xQueueGenericReset+0x80>
    1582:	ce 01       	movw	r24, r28
    1584:	08 96       	adiw	r24, 0x08	; 8
    1586:	0e 94 3c 10 	call	0x2078	; 0x2078 <xTaskRemoveFromEventList>
    158a:	88 23       	and	r24, r24
    158c:	59 f0       	breq	.+22     	; 0x15a4 <xQueueGenericReset+0x80>
    158e:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortYield>
    1592:	08 c0       	rjmp	.+16     	; 0x15a4 <xQueueGenericReset+0x80>
    1594:	ce 01       	movw	r24, r28
    1596:	08 96       	adiw	r24, 0x08	; 8
    1598:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <vListInitialise>
    159c:	ce 01       	movw	r24, r28
    159e:	41 96       	adiw	r24, 0x11	; 17
    15a0:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <vListInitialise>
    15a4:	0f 90       	pop	r0
    15a6:	0f be       	out	0x3f, r0	; 63
    15a8:	81 e0       	ldi	r24, 0x01	; 1
    15aa:	df 91       	pop	r29
    15ac:	cf 91       	pop	r28
    15ae:	08 95       	ret

000015b0 <xQueueGenericCreate>:
    15b0:	0f 93       	push	r16
    15b2:	1f 93       	push	r17
    15b4:	cf 93       	push	r28
    15b6:	df 93       	push	r29
    15b8:	08 2f       	mov	r16, r24
    15ba:	16 2f       	mov	r17, r22
    15bc:	66 23       	and	r22, r22
    15be:	c1 f0       	breq	.+48     	; 0x15f0 <xQueueGenericCreate+0x40>
    15c0:	86 9f       	mul	r24, r22
    15c2:	c0 01       	movw	r24, r0
    15c4:	11 24       	eor	r1, r1
    15c6:	4f 96       	adiw	r24, 0x1f	; 31
    15c8:	0e 94 bd 07 	call	0xf7a	; 0xf7a <pvPortMalloc>
    15cc:	ec 01       	movw	r28, r24
    15ce:	00 97       	sbiw	r24, 0x00	; 0
    15d0:	41 f4       	brne	.+16     	; 0x15e2 <xQueueGenericCreate+0x32>
    15d2:	15 c0       	rjmp	.+42     	; 0x15fe <xQueueGenericCreate+0x4e>
    15d4:	0b 8f       	std	Y+27, r16	; 0x1b
    15d6:	1c 8f       	std	Y+28, r17	; 0x1c
    15d8:	61 e0       	ldi	r22, 0x01	; 1
    15da:	ce 01       	movw	r24, r28
    15dc:	0e 94 92 0a 	call	0x1524	; 0x1524 <xQueueGenericReset>
    15e0:	0e c0       	rjmp	.+28     	; 0x15fe <xQueueGenericCreate+0x4e>
    15e2:	4f 96       	adiw	r24, 0x1f	; 31
    15e4:	99 83       	std	Y+1, r25	; 0x01
    15e6:	88 83       	st	Y, r24
    15e8:	f5 cf       	rjmp	.-22     	; 0x15d4 <xQueueGenericCreate+0x24>
    15ea:	d9 83       	std	Y+1, r29	; 0x01
    15ec:	c8 83       	st	Y, r28
    15ee:	f2 cf       	rjmp	.-28     	; 0x15d4 <xQueueGenericCreate+0x24>
    15f0:	8f e1       	ldi	r24, 0x1F	; 31
    15f2:	90 e0       	ldi	r25, 0x00	; 0
    15f4:	0e 94 bd 07 	call	0xf7a	; 0xf7a <pvPortMalloc>
    15f8:	ec 01       	movw	r28, r24
    15fa:	89 2b       	or	r24, r25
    15fc:	b1 f7       	brne	.-20     	; 0x15ea <xQueueGenericCreate+0x3a>
    15fe:	ce 01       	movw	r24, r28
    1600:	df 91       	pop	r29
    1602:	cf 91       	pop	r28
    1604:	1f 91       	pop	r17
    1606:	0f 91       	pop	r16
    1608:	08 95       	ret

0000160a <xQueueGenericSend>:
    160a:	9f 92       	push	r9
    160c:	af 92       	push	r10
    160e:	bf 92       	push	r11
    1610:	cf 92       	push	r12
    1612:	df 92       	push	r13
    1614:	ef 92       	push	r14
    1616:	ff 92       	push	r15
    1618:	0f 93       	push	r16
    161a:	1f 93       	push	r17
    161c:	cf 93       	push	r28
    161e:	df 93       	push	r29
    1620:	00 d0       	rcall	.+0      	; 0x1622 <xQueueGenericSend+0x18>
    1622:	00 d0       	rcall	.+0      	; 0x1624 <xQueueGenericSend+0x1a>
    1624:	1f 92       	push	r1
    1626:	cd b7       	in	r28, 0x3d	; 61
    1628:	de b7       	in	r29, 0x3e	; 62
    162a:	8c 01       	movw	r16, r24
    162c:	6b 01       	movw	r12, r22
    162e:	5d 83       	std	Y+5, r21	; 0x05
    1630:	4c 83       	std	Y+4, r20	; 0x04
    1632:	a2 2e       	mov	r10, r18
    1634:	b1 2c       	mov	r11, r1
    1636:	99 24       	eor	r9, r9
    1638:	93 94       	inc	r9
    163a:	7c 01       	movw	r14, r24
    163c:	88 e0       	ldi	r24, 0x08	; 8
    163e:	e8 0e       	add	r14, r24
    1640:	f1 1c       	adc	r15, r1
    1642:	0f b6       	in	r0, 0x3f	; 63
    1644:	f8 94       	cli
    1646:	0f 92       	push	r0
    1648:	f8 01       	movw	r30, r16
    164a:	92 8d       	ldd	r25, Z+26	; 0x1a
    164c:	83 8d       	ldd	r24, Z+27	; 0x1b
    164e:	98 17       	cp	r25, r24
    1650:	18 f0       	brcs	.+6      	; 0x1658 <xQueueGenericSend+0x4e>
    1652:	f2 e0       	ldi	r31, 0x02	; 2
    1654:	af 12       	cpse	r10, r31
    1656:	19 c0       	rjmp	.+50     	; 0x168a <xQueueGenericSend+0x80>
    1658:	4a 2d       	mov	r20, r10
    165a:	b6 01       	movw	r22, r12
    165c:	c8 01       	movw	r24, r16
    165e:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <prvCopyDataToQueue>
    1662:	f8 01       	movw	r30, r16
    1664:	91 89       	ldd	r25, Z+17	; 0x11
    1666:	99 23       	and	r25, r25
    1668:	49 f0       	breq	.+18     	; 0x167c <xQueueGenericSend+0x72>
    166a:	c8 01       	movw	r24, r16
    166c:	41 96       	adiw	r24, 0x11	; 17
    166e:	0e 94 3c 10 	call	0x2078	; 0x2078 <xTaskRemoveFromEventList>
    1672:	88 23       	and	r24, r24
    1674:	31 f0       	breq	.+12     	; 0x1682 <xQueueGenericSend+0x78>
    1676:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortYield>
    167a:	03 c0       	rjmp	.+6      	; 0x1682 <xQueueGenericSend+0x78>
    167c:	81 11       	cpse	r24, r1
    167e:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortYield>
    1682:	0f 90       	pop	r0
    1684:	0f be       	out	0x3f, r0	; 63
    1686:	81 e0       	ldi	r24, 0x01	; 1
    1688:	50 c0       	rjmp	.+160    	; 0x172a <xQueueGenericSend+0x120>
    168a:	8c 81       	ldd	r24, Y+4	; 0x04
    168c:	9d 81       	ldd	r25, Y+5	; 0x05
    168e:	89 2b       	or	r24, r25
    1690:	21 f4       	brne	.+8      	; 0x169a <xQueueGenericSend+0x90>
    1692:	0f 90       	pop	r0
    1694:	0f be       	out	0x3f, r0	; 63
    1696:	80 e0       	ldi	r24, 0x00	; 0
    1698:	48 c0       	rjmp	.+144    	; 0x172a <xQueueGenericSend+0x120>
    169a:	b1 10       	cpse	r11, r1
    169c:	05 c0       	rjmp	.+10     	; 0x16a8 <xQueueGenericSend+0x9e>
    169e:	ce 01       	movw	r24, r28
    16a0:	01 96       	adiw	r24, 0x01	; 1
    16a2:	0e 94 84 10 	call	0x2108	; 0x2108 <vTaskInternalSetTimeOutState>
    16a6:	b9 2c       	mov	r11, r9
    16a8:	0f 90       	pop	r0
    16aa:	0f be       	out	0x3f, r0	; 63
    16ac:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vTaskSuspendAll>
    16b0:	0f b6       	in	r0, 0x3f	; 63
    16b2:	f8 94       	cli
    16b4:	0f 92       	push	r0
    16b6:	f8 01       	movw	r30, r16
    16b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    16ba:	8f 3f       	cpi	r24, 0xFF	; 255
    16bc:	09 f4       	brne	.+2      	; 0x16c0 <xQueueGenericSend+0xb6>
    16be:	15 8e       	std	Z+29, r1	; 0x1d
    16c0:	f8 01       	movw	r30, r16
    16c2:	86 8d       	ldd	r24, Z+30	; 0x1e
    16c4:	8f 3f       	cpi	r24, 0xFF	; 255
    16c6:	09 f4       	brne	.+2      	; 0x16ca <xQueueGenericSend+0xc0>
    16c8:	16 8e       	std	Z+30, r1	; 0x1e
    16ca:	0f 90       	pop	r0
    16cc:	0f be       	out	0x3f, r0	; 63
    16ce:	be 01       	movw	r22, r28
    16d0:	6c 5f       	subi	r22, 0xFC	; 252
    16d2:	7f 4f       	sbci	r23, 0xFF	; 255
    16d4:	ce 01       	movw	r24, r28
    16d6:	01 96       	adiw	r24, 0x01	; 1
    16d8:	0e 94 8f 10 	call	0x211e	; 0x211e <xTaskCheckForTimeOut>
    16dc:	81 11       	cpse	r24, r1
    16de:	1f c0       	rjmp	.+62     	; 0x171e <xQueueGenericSend+0x114>
    16e0:	0f b6       	in	r0, 0x3f	; 63
    16e2:	f8 94       	cli
    16e4:	0f 92       	push	r0
    16e6:	f8 01       	movw	r30, r16
    16e8:	92 8d       	ldd	r25, Z+26	; 0x1a
    16ea:	0f 90       	pop	r0
    16ec:	0f be       	out	0x3f, r0	; 63
    16ee:	83 8d       	ldd	r24, Z+27	; 0x1b
    16f0:	98 13       	cpse	r25, r24
    16f2:	0f c0       	rjmp	.+30     	; 0x1712 <xQueueGenericSend+0x108>
    16f4:	6c 81       	ldd	r22, Y+4	; 0x04
    16f6:	7d 81       	ldd	r23, Y+5	; 0x05
    16f8:	c7 01       	movw	r24, r14
    16fa:	0e 94 2a 10 	call	0x2054	; 0x2054 <vTaskPlaceOnEventList>
    16fe:	c8 01       	movw	r24, r16
    1700:	0e 94 45 0a 	call	0x148a	; 0x148a <prvUnlockQueue>
    1704:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xTaskResumeAll>
    1708:	81 11       	cpse	r24, r1
    170a:	9b cf       	rjmp	.-202    	; 0x1642 <xQueueGenericSend+0x38>
    170c:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortYield>
    1710:	98 cf       	rjmp	.-208    	; 0x1642 <xQueueGenericSend+0x38>
    1712:	c8 01       	movw	r24, r16
    1714:	0e 94 45 0a 	call	0x148a	; 0x148a <prvUnlockQueue>
    1718:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xTaskResumeAll>
    171c:	92 cf       	rjmp	.-220    	; 0x1642 <xQueueGenericSend+0x38>
    171e:	c8 01       	movw	r24, r16
    1720:	0e 94 45 0a 	call	0x148a	; 0x148a <prvUnlockQueue>
    1724:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xTaskResumeAll>
    1728:	80 e0       	ldi	r24, 0x00	; 0
    172a:	0f 90       	pop	r0
    172c:	0f 90       	pop	r0
    172e:	0f 90       	pop	r0
    1730:	0f 90       	pop	r0
    1732:	0f 90       	pop	r0
    1734:	df 91       	pop	r29
    1736:	cf 91       	pop	r28
    1738:	1f 91       	pop	r17
    173a:	0f 91       	pop	r16
    173c:	ff 90       	pop	r15
    173e:	ef 90       	pop	r14
    1740:	df 90       	pop	r13
    1742:	cf 90       	pop	r12
    1744:	bf 90       	pop	r11
    1746:	af 90       	pop	r10
    1748:	9f 90       	pop	r9
    174a:	08 95       	ret

0000174c <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    174c:	9f 92       	push	r9
    174e:	af 92       	push	r10
    1750:	bf 92       	push	r11
    1752:	cf 92       	push	r12
    1754:	df 92       	push	r13
    1756:	ef 92       	push	r14
    1758:	ff 92       	push	r15
    175a:	0f 93       	push	r16
    175c:	1f 93       	push	r17
    175e:	cf 93       	push	r28
    1760:	df 93       	push	r29
    1762:	00 d0       	rcall	.+0      	; 0x1764 <xQueueReceive+0x18>
    1764:	00 d0       	rcall	.+0      	; 0x1766 <xQueueReceive+0x1a>
    1766:	1f 92       	push	r1
    1768:	cd b7       	in	r28, 0x3d	; 61
    176a:	de b7       	in	r29, 0x3e	; 62
    176c:	8c 01       	movw	r16, r24
    176e:	5b 01       	movw	r10, r22
    1770:	5d 83       	std	Y+5, r21	; 0x05
    1772:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1774:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1776:	99 24       	eor	r9, r9
    1778:	93 94       	inc	r9
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    177a:	6c 01       	movw	r12, r24
    177c:	81 e1       	ldi	r24, 0x11	; 17
    177e:	c8 0e       	add	r12, r24
    1780:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1782:	0f b6       	in	r0, 0x3f	; 63
    1784:	f8 94       	cli
    1786:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1788:	f8 01       	movw	r30, r16
    178a:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    178c:	ff 20       	and	r15, r15
    178e:	a9 f0       	breq	.+42     	; 0x17ba <xQueueReceive+0x6e>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1790:	b5 01       	movw	r22, r10
    1792:	c8 01       	movw	r24, r16
    1794:	0e 94 2b 0a 	call	0x1456	; 0x1456 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1798:	fa 94       	dec	r15
    179a:	f8 01       	movw	r30, r16
    179c:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    179e:	80 85       	ldd	r24, Z+8	; 0x08
    17a0:	88 23       	and	r24, r24
    17a2:	39 f0       	breq	.+14     	; 0x17b2 <xQueueReceive+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17a4:	c8 01       	movw	r24, r16
    17a6:	08 96       	adiw	r24, 0x08	; 8
    17a8:	0e 94 3c 10 	call	0x2078	; 0x2078 <xTaskRemoveFromEventList>
    17ac:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    17ae:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    17b2:	0f 90       	pop	r0
    17b4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    17b6:	81 e0       	ldi	r24, 0x01	; 1
    17b8:	51 c0       	rjmp	.+162    	; 0x185c <xQueueReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    17ba:	8c 81       	ldd	r24, Y+4	; 0x04
    17bc:	9d 81       	ldd	r25, Y+5	; 0x05
    17be:	89 2b       	or	r24, r25
    17c0:	21 f4       	brne	.+8      	; 0x17ca <xQueueReceive+0x7e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    17c2:	0f 90       	pop	r0
    17c4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    17c6:	80 e0       	ldi	r24, 0x00	; 0
    17c8:	49 c0       	rjmp	.+146    	; 0x185c <xQueueReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
    17ca:	e1 10       	cpse	r14, r1
    17cc:	05 c0       	rjmp	.+10     	; 0x17d8 <xQueueReceive+0x8c>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    17ce:	ce 01       	movw	r24, r28
    17d0:	01 96       	adiw	r24, 0x01	; 1
    17d2:	0e 94 84 10 	call	0x2108	; 0x2108 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    17d6:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    17d8:	0f 90       	pop	r0
    17da:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    17dc:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    17e0:	0f b6       	in	r0, 0x3f	; 63
    17e2:	f8 94       	cli
    17e4:	0f 92       	push	r0
    17e6:	f8 01       	movw	r30, r16
    17e8:	85 8d       	ldd	r24, Z+29	; 0x1d
    17ea:	8f 3f       	cpi	r24, 0xFF	; 255
    17ec:	09 f4       	brne	.+2      	; 0x17f0 <xQueueReceive+0xa4>
    17ee:	15 8e       	std	Z+29, r1	; 0x1d
    17f0:	f8 01       	movw	r30, r16
    17f2:	86 8d       	ldd	r24, Z+30	; 0x1e
    17f4:	8f 3f       	cpi	r24, 0xFF	; 255
    17f6:	09 f4       	brne	.+2      	; 0x17fa <xQueueReceive+0xae>
    17f8:	16 8e       	std	Z+30, r1	; 0x1e
    17fa:	0f 90       	pop	r0
    17fc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    17fe:	be 01       	movw	r22, r28
    1800:	6c 5f       	subi	r22, 0xFC	; 252
    1802:	7f 4f       	sbci	r23, 0xFF	; 255
    1804:	ce 01       	movw	r24, r28
    1806:	01 96       	adiw	r24, 0x01	; 1
    1808:	0e 94 8f 10 	call	0x211e	; 0x211e <xTaskCheckForTimeOut>
    180c:	81 11       	cpse	r24, r1
    180e:	1a c0       	rjmp	.+52     	; 0x1844 <xQueueReceive+0xf8>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1810:	c8 01       	movw	r24, r16
    1812:	0e 94 d7 09 	call	0x13ae	; 0x13ae <prvIsQueueEmpty>
    1816:	88 23       	and	r24, r24
    1818:	79 f0       	breq	.+30     	; 0x1838 <xQueueReceive+0xec>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    181a:	6c 81       	ldd	r22, Y+4	; 0x04
    181c:	7d 81       	ldd	r23, Y+5	; 0x05
    181e:	c6 01       	movw	r24, r12
    1820:	0e 94 2a 10 	call	0x2054	; 0x2054 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1824:	c8 01       	movw	r24, r16
    1826:	0e 94 45 0a 	call	0x148a	; 0x148a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    182a:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xTaskResumeAll>
    182e:	81 11       	cpse	r24, r1
    1830:	a8 cf       	rjmp	.-176    	; 0x1782 <xQueueReceive+0x36>
				{
					portYIELD_WITHIN_API();
    1832:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortYield>
    1836:	a5 cf       	rjmp	.-182    	; 0x1782 <xQueueReceive+0x36>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1838:	c8 01       	movw	r24, r16
    183a:	0e 94 45 0a 	call	0x148a	; 0x148a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    183e:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xTaskResumeAll>
    1842:	9f cf       	rjmp	.-194    	; 0x1782 <xQueueReceive+0x36>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1844:	c8 01       	movw	r24, r16
    1846:	0e 94 45 0a 	call	0x148a	; 0x148a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    184a:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    184e:	c8 01       	movw	r24, r16
    1850:	0e 94 d7 09 	call	0x13ae	; 0x13ae <prvIsQueueEmpty>
    1854:	88 23       	and	r24, r24
    1856:	09 f4       	brne	.+2      	; 0x185a <xQueueReceive+0x10e>
    1858:	94 cf       	rjmp	.-216    	; 0x1782 <xQueueReceive+0x36>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    185a:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    185c:	0f 90       	pop	r0
    185e:	0f 90       	pop	r0
    1860:	0f 90       	pop	r0
    1862:	0f 90       	pop	r0
    1864:	0f 90       	pop	r0
    1866:	df 91       	pop	r29
    1868:	cf 91       	pop	r28
    186a:	1f 91       	pop	r17
    186c:	0f 91       	pop	r16
    186e:	ff 90       	pop	r15
    1870:	ef 90       	pop	r14
    1872:	df 90       	pop	r13
    1874:	cf 90       	pop	r12
    1876:	bf 90       	pop	r11
    1878:	af 90       	pop	r10
    187a:	9f 90       	pop	r9
    187c:	08 95       	ret

0000187e <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    187e:	e0 91 86 07 	lds	r30, 0x0786	; 0x800786 <pxDelayedTaskList>
    1882:	f0 91 87 07 	lds	r31, 0x0787	; 0x800787 <pxDelayedTaskList+0x1>
    1886:	80 81       	ld	r24, Z
    1888:	81 11       	cpse	r24, r1
    188a:	07 c0       	rjmp	.+14     	; 0x189a <prvResetNextTaskUnblockTime+0x1c>
    188c:	8f ef       	ldi	r24, 0xFF	; 255
    188e:	9f ef       	ldi	r25, 0xFF	; 255
    1890:	90 93 5e 07 	sts	0x075E, r25	; 0x80075e <xNextTaskUnblockTime+0x1>
    1894:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <xNextTaskUnblockTime>
    1898:	08 95       	ret
    189a:	e0 91 86 07 	lds	r30, 0x0786	; 0x800786 <pxDelayedTaskList>
    189e:	f0 91 87 07 	lds	r31, 0x0787	; 0x800787 <pxDelayedTaskList+0x1>
    18a2:	05 80       	ldd	r0, Z+5	; 0x05
    18a4:	f6 81       	ldd	r31, Z+6	; 0x06
    18a6:	e0 2d       	mov	r30, r0
    18a8:	06 80       	ldd	r0, Z+6	; 0x06
    18aa:	f7 81       	ldd	r31, Z+7	; 0x07
    18ac:	e0 2d       	mov	r30, r0
    18ae:	82 81       	ldd	r24, Z+2	; 0x02
    18b0:	93 81       	ldd	r25, Z+3	; 0x03
    18b2:	90 93 5e 07 	sts	0x075E, r25	; 0x80075e <xNextTaskUnblockTime+0x1>
    18b6:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <xNextTaskUnblockTime>
    18ba:	08 95       	ret

000018bc <prvIdleTask>:
    18bc:	02 e7       	ldi	r16, 0x72	; 114
    18be:	17 e0       	ldi	r17, 0x07	; 7
    18c0:	80 91 71 07 	lds	r24, 0x0771	; 0x800771 <uxDeletedTasksWaitingCleanUp>
    18c4:	88 23       	and	r24, r24
    18c6:	e1 f3       	breq	.-8      	; 0x18c0 <prvIdleTask+0x4>
    18c8:	0f b6       	in	r0, 0x3f	; 63
    18ca:	f8 94       	cli
    18cc:	0f 92       	push	r0
    18ce:	d8 01       	movw	r26, r16
    18d0:	15 96       	adiw	r26, 0x05	; 5
    18d2:	ed 91       	ld	r30, X+
    18d4:	fc 91       	ld	r31, X
    18d6:	16 97       	sbiw	r26, 0x06	; 6
    18d8:	c6 81       	ldd	r28, Z+6	; 0x06
    18da:	d7 81       	ldd	r29, Z+7	; 0x07
    18dc:	ce 01       	movw	r24, r28
    18de:	02 96       	adiw	r24, 0x02	; 2
    18e0:	0e 94 57 08 	call	0x10ae	; 0x10ae <uxListRemove>
    18e4:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <uxCurrentNumberOfTasks>
    18e8:	81 50       	subi	r24, 0x01	; 1
    18ea:	80 93 67 07 	sts	0x0767, r24	; 0x800767 <uxCurrentNumberOfTasks>
    18ee:	80 91 71 07 	lds	r24, 0x0771	; 0x800771 <uxDeletedTasksWaitingCleanUp>
    18f2:	81 50       	subi	r24, 0x01	; 1
    18f4:	80 93 71 07 	sts	0x0771, r24	; 0x800771 <uxDeletedTasksWaitingCleanUp>
    18f8:	0f 90       	pop	r0
    18fa:	0f be       	out	0x3f, r0	; 63
    18fc:	8f 89       	ldd	r24, Y+23	; 0x17
    18fe:	98 8d       	ldd	r25, Y+24	; 0x18
    1900:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <vPortFree>
    1904:	ce 01       	movw	r24, r28
    1906:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <vPortFree>
    190a:	80 91 71 07 	lds	r24, 0x0771	; 0x800771 <uxDeletedTasksWaitingCleanUp>
    190e:	81 11       	cpse	r24, r1
    1910:	db cf       	rjmp	.-74     	; 0x18c8 <prvIdleTask+0xc>
    1912:	d6 cf       	rjmp	.-84     	; 0x18c0 <prvIdleTask+0x4>

00001914 <prvAddCurrentTaskToDelayedList>:
    1914:	ff 92       	push	r15
    1916:	0f 93       	push	r16
    1918:	1f 93       	push	r17
    191a:	cf 93       	push	r28
    191c:	df 93       	push	r29
    191e:	ec 01       	movw	r28, r24
    1920:	f6 2e       	mov	r15, r22
    1922:	00 91 65 07 	lds	r16, 0x0765	; 0x800765 <xTickCount>
    1926:	10 91 66 07 	lds	r17, 0x0766	; 0x800766 <xTickCount+0x1>
    192a:	80 91 be 07 	lds	r24, 0x07BE	; 0x8007be <pxCurrentTCB>
    192e:	90 91 bf 07 	lds	r25, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    1932:	02 96       	adiw	r24, 0x02	; 2
    1934:	0e 94 57 08 	call	0x10ae	; 0x10ae <uxListRemove>
    1938:	cf 3f       	cpi	r28, 0xFF	; 255
    193a:	8f ef       	ldi	r24, 0xFF	; 255
    193c:	d8 07       	cpc	r29, r24
    193e:	69 f4       	brne	.+26     	; 0x195a <prvAddCurrentTaskToDelayedList+0x46>
    1940:	ff 20       	and	r15, r15
    1942:	59 f0       	breq	.+22     	; 0x195a <prvAddCurrentTaskToDelayedList+0x46>
    1944:	60 91 be 07 	lds	r22, 0x07BE	; 0x8007be <pxCurrentTCB>
    1948:	70 91 bf 07 	lds	r23, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    194c:	6e 5f       	subi	r22, 0xFE	; 254
    194e:	7f 4f       	sbci	r23, 0xFF	; 255
    1950:	88 e6       	ldi	r24, 0x68	; 104
    1952:	97 e0       	ldi	r25, 0x07	; 7
    1954:	0e 94 05 08 	call	0x100a	; 0x100a <vListInsertEnd>
    1958:	2f c0       	rjmp	.+94     	; 0x19b8 <prvAddCurrentTaskToDelayedList+0xa4>
    195a:	c0 0f       	add	r28, r16
    195c:	d1 1f       	adc	r29, r17
    195e:	e0 91 be 07 	lds	r30, 0x07BE	; 0x8007be <pxCurrentTCB>
    1962:	f0 91 bf 07 	lds	r31, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    1966:	d3 83       	std	Z+3, r29	; 0x03
    1968:	c2 83       	std	Z+2, r28	; 0x02
    196a:	c0 17       	cp	r28, r16
    196c:	d1 07       	cpc	r29, r17
    196e:	68 f4       	brcc	.+26     	; 0x198a <prvAddCurrentTaskToDelayedList+0x76>
    1970:	60 91 be 07 	lds	r22, 0x07BE	; 0x8007be <pxCurrentTCB>
    1974:	70 91 bf 07 	lds	r23, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    1978:	80 91 84 07 	lds	r24, 0x0784	; 0x800784 <pxOverflowDelayedTaskList>
    197c:	90 91 85 07 	lds	r25, 0x0785	; 0x800785 <pxOverflowDelayedTaskList+0x1>
    1980:	6e 5f       	subi	r22, 0xFE	; 254
    1982:	7f 4f       	sbci	r23, 0xFF	; 255
    1984:	0e 94 26 08 	call	0x104c	; 0x104c <vListInsert>
    1988:	17 c0       	rjmp	.+46     	; 0x19b8 <prvAddCurrentTaskToDelayedList+0xa4>
    198a:	60 91 be 07 	lds	r22, 0x07BE	; 0x8007be <pxCurrentTCB>
    198e:	70 91 bf 07 	lds	r23, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    1992:	80 91 86 07 	lds	r24, 0x0786	; 0x800786 <pxDelayedTaskList>
    1996:	90 91 87 07 	lds	r25, 0x0787	; 0x800787 <pxDelayedTaskList+0x1>
    199a:	6e 5f       	subi	r22, 0xFE	; 254
    199c:	7f 4f       	sbci	r23, 0xFF	; 255
    199e:	0e 94 26 08 	call	0x104c	; 0x104c <vListInsert>
    19a2:	80 91 5d 07 	lds	r24, 0x075D	; 0x80075d <xNextTaskUnblockTime>
    19a6:	90 91 5e 07 	lds	r25, 0x075E	; 0x80075e <xNextTaskUnblockTime+0x1>
    19aa:	c8 17       	cp	r28, r24
    19ac:	d9 07       	cpc	r29, r25
    19ae:	20 f4       	brcc	.+8      	; 0x19b8 <prvAddCurrentTaskToDelayedList+0xa4>
    19b0:	d0 93 5e 07 	sts	0x075E, r29	; 0x80075e <xNextTaskUnblockTime+0x1>
    19b4:	c0 93 5d 07 	sts	0x075D, r28	; 0x80075d <xNextTaskUnblockTime>
    19b8:	df 91       	pop	r29
    19ba:	cf 91       	pop	r28
    19bc:	1f 91       	pop	r17
    19be:	0f 91       	pop	r16
    19c0:	ff 90       	pop	r15
    19c2:	08 95       	ret

000019c4 <xTaskCreate>:
    19c4:	4f 92       	push	r4
    19c6:	5f 92       	push	r5
    19c8:	6f 92       	push	r6
    19ca:	7f 92       	push	r7
    19cc:	8f 92       	push	r8
    19ce:	9f 92       	push	r9
    19d0:	af 92       	push	r10
    19d2:	bf 92       	push	r11
    19d4:	cf 92       	push	r12
    19d6:	df 92       	push	r13
    19d8:	ef 92       	push	r14
    19da:	ff 92       	push	r15
    19dc:	0f 93       	push	r16
    19de:	cf 93       	push	r28
    19e0:	df 93       	push	r29
    19e2:	4c 01       	movw	r8, r24
    19e4:	6b 01       	movw	r12, r22
    19e6:	5a 01       	movw	r10, r20
    19e8:	29 01       	movw	r4, r18
    19ea:	ca 01       	movw	r24, r20
    19ec:	0e 94 bd 07 	call	0xf7a	; 0xf7a <pvPortMalloc>
    19f0:	3c 01       	movw	r6, r24
    19f2:	89 2b       	or	r24, r25
    19f4:	09 f4       	brne	.+2      	; 0x19f8 <xTaskCreate+0x34>
    19f6:	e7 c0       	rjmp	.+462    	; 0x1bc6 <xTaskCreate+0x202>
    19f8:	86 e2       	ldi	r24, 0x26	; 38
    19fa:	90 e0       	ldi	r25, 0x00	; 0
    19fc:	0e 94 bd 07 	call	0xf7a	; 0xf7a <pvPortMalloc>
    1a00:	ec 01       	movw	r28, r24
    1a02:	89 2b       	or	r24, r25
    1a04:	59 f0       	breq	.+22     	; 0x1a1c <xTaskCreate+0x58>
    1a06:	78 8e       	std	Y+24, r7	; 0x18
    1a08:	6f 8a       	std	Y+23, r6	; 0x17
    1a0a:	81 e0       	ldi	r24, 0x01	; 1
    1a0c:	a8 1a       	sub	r10, r24
    1a0e:	b1 08       	sbc	r11, r1
    1a10:	a6 0c       	add	r10, r6
    1a12:	b7 1c       	adc	r11, r7
    1a14:	c1 14       	cp	r12, r1
    1a16:	d1 04       	cpc	r13, r1
    1a18:	29 f4       	brne	.+10     	; 0x1a24 <xTaskCreate+0x60>
    1a1a:	20 c0       	rjmp	.+64     	; 0x1a5c <xTaskCreate+0x98>
    1a1c:	c3 01       	movw	r24, r6
    1a1e:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <vPortFree>
    1a22:	d1 c0       	rjmp	.+418    	; 0x1bc6 <xTaskCreate+0x202>
    1a24:	d6 01       	movw	r26, r12
    1a26:	8c 91       	ld	r24, X
    1a28:	89 8f       	std	Y+25, r24	; 0x19
    1a2a:	8c 91       	ld	r24, X
    1a2c:	88 23       	and	r24, r24
    1a2e:	a1 f0       	breq	.+40     	; 0x1a58 <xTaskCreate+0x94>
    1a30:	ae 01       	movw	r20, r28
    1a32:	46 5e       	subi	r20, 0xE6	; 230
    1a34:	5f 4f       	sbci	r21, 0xFF	; 255
    1a36:	f6 01       	movw	r30, r12
    1a38:	31 96       	adiw	r30, 0x01	; 1
    1a3a:	b8 e0       	ldi	r27, 0x08	; 8
    1a3c:	cb 0e       	add	r12, r27
    1a3e:	d1 1c       	adc	r13, r1
    1a40:	cf 01       	movw	r24, r30
    1a42:	21 91       	ld	r18, Z+
    1a44:	da 01       	movw	r26, r20
    1a46:	2d 93       	st	X+, r18
    1a48:	ad 01       	movw	r20, r26
    1a4a:	dc 01       	movw	r26, r24
    1a4c:	8c 91       	ld	r24, X
    1a4e:	88 23       	and	r24, r24
    1a50:	19 f0       	breq	.+6      	; 0x1a58 <xTaskCreate+0x94>
    1a52:	ec 15       	cp	r30, r12
    1a54:	fd 05       	cpc	r31, r13
    1a56:	a1 f7       	brne	.-24     	; 0x1a40 <xTaskCreate+0x7c>
    1a58:	18 a2       	std	Y+32, r1	; 0x20
    1a5a:	01 c0       	rjmp	.+2      	; 0x1a5e <xTaskCreate+0x9a>
    1a5c:	19 8e       	std	Y+25, r1	; 0x19
    1a5e:	04 30       	cpi	r16, 0x04	; 4
    1a60:	08 f0       	brcs	.+2      	; 0x1a64 <xTaskCreate+0xa0>
    1a62:	03 e0       	ldi	r16, 0x03	; 3
    1a64:	0e 8b       	std	Y+22, r16	; 0x16
    1a66:	6e 01       	movw	r12, r28
    1a68:	b2 e0       	ldi	r27, 0x02	; 2
    1a6a:	cb 0e       	add	r12, r27
    1a6c:	d1 1c       	adc	r13, r1
    1a6e:	c6 01       	movw	r24, r12
    1a70:	0e 94 01 08 	call	0x1002	; 0x1002 <vListInitialiseItem>
    1a74:	ce 01       	movw	r24, r28
    1a76:	0c 96       	adiw	r24, 0x0c	; 12
    1a78:	0e 94 01 08 	call	0x1002	; 0x1002 <vListInitialiseItem>
    1a7c:	d9 87       	std	Y+9, r29	; 0x09
    1a7e:	c8 87       	std	Y+8, r28	; 0x08
    1a80:	84 e0       	ldi	r24, 0x04	; 4
    1a82:	90 e0       	ldi	r25, 0x00	; 0
    1a84:	80 1b       	sub	r24, r16
    1a86:	91 09       	sbc	r25, r1
    1a88:	9d 87       	std	Y+13, r25	; 0x0d
    1a8a:	8c 87       	std	Y+12, r24	; 0x0c
    1a8c:	db 8b       	std	Y+19, r29	; 0x13
    1a8e:	ca 8b       	std	Y+18, r28	; 0x12
    1a90:	19 a2       	std	Y+33, r1	; 0x21
    1a92:	1a a2       	std	Y+34, r1	; 0x22
    1a94:	1b a2       	std	Y+35, r1	; 0x23
    1a96:	1c a2       	std	Y+36, r1	; 0x24
    1a98:	1d a2       	std	Y+37, r1	; 0x25
    1a9a:	a2 01       	movw	r20, r4
    1a9c:	b4 01       	movw	r22, r8
    1a9e:	c5 01       	movw	r24, r10
    1aa0:	0e 94 7e 08 	call	0x10fc	; 0x10fc <pxPortInitialiseStack>
    1aa4:	99 83       	std	Y+1, r25	; 0x01
    1aa6:	88 83       	st	Y, r24
    1aa8:	e1 14       	cp	r14, r1
    1aaa:	f1 04       	cpc	r15, r1
    1aac:	19 f0       	breq	.+6      	; 0x1ab4 <xTaskCreate+0xf0>
    1aae:	f7 01       	movw	r30, r14
    1ab0:	d1 83       	std	Z+1, r29	; 0x01
    1ab2:	c0 83       	st	Z, r28
    1ab4:	0f b6       	in	r0, 0x3f	; 63
    1ab6:	f8 94       	cli
    1ab8:	0f 92       	push	r0
    1aba:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <uxCurrentNumberOfTasks>
    1abe:	8f 5f       	subi	r24, 0xFF	; 255
    1ac0:	80 93 67 07 	sts	0x0767, r24	; 0x800767 <uxCurrentNumberOfTasks>
    1ac4:	80 91 be 07 	lds	r24, 0x07BE	; 0x8007be <pxCurrentTCB>
    1ac8:	90 91 bf 07 	lds	r25, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    1acc:	89 2b       	or	r24, r25
    1ace:	d1 f5       	brne	.+116    	; 0x1b44 <xTaskCreate+0x180>
    1ad0:	d0 93 bf 07 	sts	0x07BF, r29	; 0x8007bf <pxCurrentTCB+0x1>
    1ad4:	c0 93 be 07 	sts	0x07BE, r28	; 0x8007be <pxCurrentTCB>
    1ad8:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <uxCurrentNumberOfTasks>
    1adc:	81 30       	cpi	r24, 0x01	; 1
    1ade:	09 f0       	breq	.+2      	; 0x1ae2 <xTaskCreate+0x11e>
    1ae0:	41 c0       	rjmp	.+130    	; 0x1b64 <xTaskCreate+0x1a0>
    1ae2:	8a e9       	ldi	r24, 0x9A	; 154
    1ae4:	97 e0       	ldi	r25, 0x07	; 7
    1ae6:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <vListInitialise>
    1aea:	83 ea       	ldi	r24, 0xA3	; 163
    1aec:	97 e0       	ldi	r25, 0x07	; 7
    1aee:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <vListInitialise>
    1af2:	8c ea       	ldi	r24, 0xAC	; 172
    1af4:	97 e0       	ldi	r25, 0x07	; 7
    1af6:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <vListInitialise>
    1afa:	85 eb       	ldi	r24, 0xB5	; 181
    1afc:	97 e0       	ldi	r25, 0x07	; 7
    1afe:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <vListInitialise>
    1b02:	81 e9       	ldi	r24, 0x91	; 145
    1b04:	97 e0       	ldi	r25, 0x07	; 7
    1b06:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <vListInitialise>
    1b0a:	88 e8       	ldi	r24, 0x88	; 136
    1b0c:	97 e0       	ldi	r25, 0x07	; 7
    1b0e:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <vListInitialise>
    1b12:	8b e7       	ldi	r24, 0x7B	; 123
    1b14:	97 e0       	ldi	r25, 0x07	; 7
    1b16:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <vListInitialise>
    1b1a:	82 e7       	ldi	r24, 0x72	; 114
    1b1c:	97 e0       	ldi	r25, 0x07	; 7
    1b1e:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <vListInitialise>
    1b22:	88 e6       	ldi	r24, 0x68	; 104
    1b24:	97 e0       	ldi	r25, 0x07	; 7
    1b26:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <vListInitialise>
    1b2a:	81 e9       	ldi	r24, 0x91	; 145
    1b2c:	97 e0       	ldi	r25, 0x07	; 7
    1b2e:	90 93 87 07 	sts	0x0787, r25	; 0x800787 <pxDelayedTaskList+0x1>
    1b32:	80 93 86 07 	sts	0x0786, r24	; 0x800786 <pxDelayedTaskList>
    1b36:	88 e8       	ldi	r24, 0x88	; 136
    1b38:	97 e0       	ldi	r25, 0x07	; 7
    1b3a:	90 93 85 07 	sts	0x0785, r25	; 0x800785 <pxOverflowDelayedTaskList+0x1>
    1b3e:	80 93 84 07 	sts	0x0784, r24	; 0x800784 <pxOverflowDelayedTaskList>
    1b42:	10 c0       	rjmp	.+32     	; 0x1b64 <xTaskCreate+0x1a0>
    1b44:	80 91 63 07 	lds	r24, 0x0763	; 0x800763 <xSchedulerRunning>
    1b48:	81 11       	cpse	r24, r1
    1b4a:	0c c0       	rjmp	.+24     	; 0x1b64 <xTaskCreate+0x1a0>
    1b4c:	e0 91 be 07 	lds	r30, 0x07BE	; 0x8007be <pxCurrentTCB>
    1b50:	f0 91 bf 07 	lds	r31, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    1b54:	96 89       	ldd	r25, Z+22	; 0x16
    1b56:	8e 89       	ldd	r24, Y+22	; 0x16
    1b58:	89 17       	cp	r24, r25
    1b5a:	20 f0       	brcs	.+8      	; 0x1b64 <xTaskCreate+0x1a0>
    1b5c:	d0 93 bf 07 	sts	0x07BF, r29	; 0x8007bf <pxCurrentTCB+0x1>
    1b60:	c0 93 be 07 	sts	0x07BE, r28	; 0x8007be <pxCurrentTCB>
    1b64:	80 91 5f 07 	lds	r24, 0x075F	; 0x80075f <uxTaskNumber>
    1b68:	8f 5f       	subi	r24, 0xFF	; 255
    1b6a:	80 93 5f 07 	sts	0x075F, r24	; 0x80075f <uxTaskNumber>
    1b6e:	8e 89       	ldd	r24, Y+22	; 0x16
    1b70:	90 91 64 07 	lds	r25, 0x0764	; 0x800764 <uxTopReadyPriority>
    1b74:	98 17       	cp	r25, r24
    1b76:	10 f4       	brcc	.+4      	; 0x1b7c <xTaskCreate+0x1b8>
    1b78:	80 93 64 07 	sts	0x0764, r24	; 0x800764 <uxTopReadyPriority>
    1b7c:	90 e0       	ldi	r25, 0x00	; 0
    1b7e:	9c 01       	movw	r18, r24
    1b80:	22 0f       	add	r18, r18
    1b82:	33 1f       	adc	r19, r19
    1b84:	22 0f       	add	r18, r18
    1b86:	33 1f       	adc	r19, r19
    1b88:	22 0f       	add	r18, r18
    1b8a:	33 1f       	adc	r19, r19
    1b8c:	82 0f       	add	r24, r18
    1b8e:	93 1f       	adc	r25, r19
    1b90:	b6 01       	movw	r22, r12
    1b92:	86 56       	subi	r24, 0x66	; 102
    1b94:	98 4f       	sbci	r25, 0xF8	; 248
    1b96:	0e 94 05 08 	call	0x100a	; 0x100a <vListInsertEnd>
    1b9a:	0f 90       	pop	r0
    1b9c:	0f be       	out	0x3f, r0	; 63
    1b9e:	80 91 63 07 	lds	r24, 0x0763	; 0x800763 <xSchedulerRunning>
    1ba2:	88 23       	and	r24, r24
    1ba4:	61 f0       	breq	.+24     	; 0x1bbe <xTaskCreate+0x1fa>
    1ba6:	e0 91 be 07 	lds	r30, 0x07BE	; 0x8007be <pxCurrentTCB>
    1baa:	f0 91 bf 07 	lds	r31, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    1bae:	96 89       	ldd	r25, Z+22	; 0x16
    1bb0:	8e 89       	ldd	r24, Y+22	; 0x16
    1bb2:	98 17       	cp	r25, r24
    1bb4:	30 f4       	brcc	.+12     	; 0x1bc2 <xTaskCreate+0x1fe>
    1bb6:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortYield>
    1bba:	81 e0       	ldi	r24, 0x01	; 1
    1bbc:	05 c0       	rjmp	.+10     	; 0x1bc8 <xTaskCreate+0x204>
    1bbe:	81 e0       	ldi	r24, 0x01	; 1
    1bc0:	03 c0       	rjmp	.+6      	; 0x1bc8 <xTaskCreate+0x204>
    1bc2:	81 e0       	ldi	r24, 0x01	; 1
    1bc4:	01 c0       	rjmp	.+2      	; 0x1bc8 <xTaskCreate+0x204>
    1bc6:	8f ef       	ldi	r24, 0xFF	; 255
    1bc8:	df 91       	pop	r29
    1bca:	cf 91       	pop	r28
    1bcc:	0f 91       	pop	r16
    1bce:	ff 90       	pop	r15
    1bd0:	ef 90       	pop	r14
    1bd2:	df 90       	pop	r13
    1bd4:	cf 90       	pop	r12
    1bd6:	bf 90       	pop	r11
    1bd8:	af 90       	pop	r10
    1bda:	9f 90       	pop	r9
    1bdc:	8f 90       	pop	r8
    1bde:	7f 90       	pop	r7
    1be0:	6f 90       	pop	r6
    1be2:	5f 90       	pop	r5
    1be4:	4f 90       	pop	r4
    1be6:	08 95       	ret

00001be8 <vTaskStartScheduler>:
    1be8:	ef 92       	push	r14
    1bea:	ff 92       	push	r15
    1bec:	0f 93       	push	r16
    1bee:	0f 2e       	mov	r0, r31
    1bf0:	fb e5       	ldi	r31, 0x5B	; 91
    1bf2:	ef 2e       	mov	r14, r31
    1bf4:	f7 e0       	ldi	r31, 0x07	; 7
    1bf6:	ff 2e       	mov	r15, r31
    1bf8:	f0 2d       	mov	r31, r0
    1bfa:	00 e0       	ldi	r16, 0x00	; 0
    1bfc:	20 e0       	ldi	r18, 0x00	; 0
    1bfe:	30 e0       	ldi	r19, 0x00	; 0
    1c00:	45 e5       	ldi	r20, 0x55	; 85
    1c02:	50 e0       	ldi	r21, 0x00	; 0
    1c04:	6c ed       	ldi	r22, 0xDC	; 220
    1c06:	70 e0       	ldi	r23, 0x00	; 0
    1c08:	8e e5       	ldi	r24, 0x5E	; 94
    1c0a:	9c e0       	ldi	r25, 0x0C	; 12
    1c0c:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <xTaskCreate>
    1c10:	81 30       	cpi	r24, 0x01	; 1
    1c12:	81 f4       	brne	.+32     	; 0x1c34 <vTaskStartScheduler+0x4c>
    1c14:	f8 94       	cli
    1c16:	8f ef       	ldi	r24, 0xFF	; 255
    1c18:	9f ef       	ldi	r25, 0xFF	; 255
    1c1a:	90 93 5e 07 	sts	0x075E, r25	; 0x80075e <xNextTaskUnblockTime+0x1>
    1c1e:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <xNextTaskUnblockTime>
    1c22:	81 e0       	ldi	r24, 0x01	; 1
    1c24:	80 93 63 07 	sts	0x0763, r24	; 0x800763 <xSchedulerRunning>
    1c28:	10 92 66 07 	sts	0x0766, r1	; 0x800766 <xTickCount+0x1>
    1c2c:	10 92 65 07 	sts	0x0765, r1	; 0x800765 <xTickCount>
    1c30:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <xPortStartScheduler>
    1c34:	0f 91       	pop	r16
    1c36:	ff 90       	pop	r15
    1c38:	ef 90       	pop	r14
    1c3a:	08 95       	ret

00001c3c <vTaskSuspendAll>:
    1c3c:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <uxSchedulerSuspended>
    1c40:	8f 5f       	subi	r24, 0xFF	; 255
    1c42:	80 93 5a 07 	sts	0x075A, r24	; 0x80075a <uxSchedulerSuspended>
    1c46:	08 95       	ret

00001c48 <xTaskIncrementTick>:
    1c48:	cf 92       	push	r12
    1c4a:	df 92       	push	r13
    1c4c:	ef 92       	push	r14
    1c4e:	ff 92       	push	r15
    1c50:	0f 93       	push	r16
    1c52:	1f 93       	push	r17
    1c54:	cf 93       	push	r28
    1c56:	df 93       	push	r29
    1c58:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <uxSchedulerSuspended>
    1c5c:	81 11       	cpse	r24, r1
    1c5e:	99 c0       	rjmp	.+306    	; 0x1d92 <xTaskIncrementTick+0x14a>
    1c60:	e0 90 65 07 	lds	r14, 0x0765	; 0x800765 <xTickCount>
    1c64:	f0 90 66 07 	lds	r15, 0x0766	; 0x800766 <xTickCount+0x1>
    1c68:	8f ef       	ldi	r24, 0xFF	; 255
    1c6a:	e8 1a       	sub	r14, r24
    1c6c:	f8 0a       	sbc	r15, r24
    1c6e:	f0 92 66 07 	sts	0x0766, r15	; 0x800766 <xTickCount+0x1>
    1c72:	e0 92 65 07 	sts	0x0765, r14	; 0x800765 <xTickCount>
    1c76:	e1 14       	cp	r14, r1
    1c78:	f1 04       	cpc	r15, r1
    1c7a:	b9 f4       	brne	.+46     	; 0x1caa <xTaskIncrementTick+0x62>
    1c7c:	80 91 86 07 	lds	r24, 0x0786	; 0x800786 <pxDelayedTaskList>
    1c80:	90 91 87 07 	lds	r25, 0x0787	; 0x800787 <pxDelayedTaskList+0x1>
    1c84:	20 91 84 07 	lds	r18, 0x0784	; 0x800784 <pxOverflowDelayedTaskList>
    1c88:	30 91 85 07 	lds	r19, 0x0785	; 0x800785 <pxOverflowDelayedTaskList+0x1>
    1c8c:	30 93 87 07 	sts	0x0787, r19	; 0x800787 <pxDelayedTaskList+0x1>
    1c90:	20 93 86 07 	sts	0x0786, r18	; 0x800786 <pxDelayedTaskList>
    1c94:	90 93 85 07 	sts	0x0785, r25	; 0x800785 <pxOverflowDelayedTaskList+0x1>
    1c98:	80 93 84 07 	sts	0x0784, r24	; 0x800784 <pxOverflowDelayedTaskList>
    1c9c:	80 91 60 07 	lds	r24, 0x0760	; 0x800760 <xNumOfOverflows>
    1ca0:	8f 5f       	subi	r24, 0xFF	; 255
    1ca2:	80 93 60 07 	sts	0x0760, r24	; 0x800760 <xNumOfOverflows>
    1ca6:	0e 94 3f 0c 	call	0x187e	; 0x187e <prvResetNextTaskUnblockTime>
    1caa:	80 91 5d 07 	lds	r24, 0x075D	; 0x80075d <xNextTaskUnblockTime>
    1cae:	90 91 5e 07 	lds	r25, 0x075E	; 0x80075e <xNextTaskUnblockTime+0x1>
    1cb2:	e8 16       	cp	r14, r24
    1cb4:	f9 06       	cpc	r15, r25
    1cb6:	10 f4       	brcc	.+4      	; 0x1cbc <xTaskIncrementTick+0x74>
    1cb8:	d1 2c       	mov	r13, r1
    1cba:	53 c0       	rjmp	.+166    	; 0x1d62 <xTaskIncrementTick+0x11a>
    1cbc:	d1 2c       	mov	r13, r1
    1cbe:	cc 24       	eor	r12, r12
    1cc0:	c3 94       	inc	r12
    1cc2:	e0 91 86 07 	lds	r30, 0x0786	; 0x800786 <pxDelayedTaskList>
    1cc6:	f0 91 87 07 	lds	r31, 0x0787	; 0x800787 <pxDelayedTaskList+0x1>
    1cca:	80 81       	ld	r24, Z
    1ccc:	81 11       	cpse	r24, r1
    1cce:	07 c0       	rjmp	.+14     	; 0x1cde <xTaskIncrementTick+0x96>
    1cd0:	8f ef       	ldi	r24, 0xFF	; 255
    1cd2:	9f ef       	ldi	r25, 0xFF	; 255
    1cd4:	90 93 5e 07 	sts	0x075E, r25	; 0x80075e <xNextTaskUnblockTime+0x1>
    1cd8:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <xNextTaskUnblockTime>
    1cdc:	42 c0       	rjmp	.+132    	; 0x1d62 <xTaskIncrementTick+0x11a>
    1cde:	e0 91 86 07 	lds	r30, 0x0786	; 0x800786 <pxDelayedTaskList>
    1ce2:	f0 91 87 07 	lds	r31, 0x0787	; 0x800787 <pxDelayedTaskList+0x1>
    1ce6:	05 80       	ldd	r0, Z+5	; 0x05
    1ce8:	f6 81       	ldd	r31, Z+6	; 0x06
    1cea:	e0 2d       	mov	r30, r0
    1cec:	c6 81       	ldd	r28, Z+6	; 0x06
    1cee:	d7 81       	ldd	r29, Z+7	; 0x07
    1cf0:	8a 81       	ldd	r24, Y+2	; 0x02
    1cf2:	9b 81       	ldd	r25, Y+3	; 0x03
    1cf4:	e8 16       	cp	r14, r24
    1cf6:	f9 06       	cpc	r15, r25
    1cf8:	28 f4       	brcc	.+10     	; 0x1d04 <xTaskIncrementTick+0xbc>
    1cfa:	90 93 5e 07 	sts	0x075E, r25	; 0x80075e <xNextTaskUnblockTime+0x1>
    1cfe:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <xNextTaskUnblockTime>
    1d02:	2f c0       	rjmp	.+94     	; 0x1d62 <xTaskIncrementTick+0x11a>
    1d04:	8e 01       	movw	r16, r28
    1d06:	0e 5f       	subi	r16, 0xFE	; 254
    1d08:	1f 4f       	sbci	r17, 0xFF	; 255
    1d0a:	c8 01       	movw	r24, r16
    1d0c:	0e 94 57 08 	call	0x10ae	; 0x10ae <uxListRemove>
    1d10:	8c 89       	ldd	r24, Y+20	; 0x14
    1d12:	9d 89       	ldd	r25, Y+21	; 0x15
    1d14:	89 2b       	or	r24, r25
    1d16:	21 f0       	breq	.+8      	; 0x1d20 <xTaskIncrementTick+0xd8>
    1d18:	ce 01       	movw	r24, r28
    1d1a:	0c 96       	adiw	r24, 0x0c	; 12
    1d1c:	0e 94 57 08 	call	0x10ae	; 0x10ae <uxListRemove>
    1d20:	8e 89       	ldd	r24, Y+22	; 0x16
    1d22:	90 91 64 07 	lds	r25, 0x0764	; 0x800764 <uxTopReadyPriority>
    1d26:	98 17       	cp	r25, r24
    1d28:	10 f4       	brcc	.+4      	; 0x1d2e <xTaskIncrementTick+0xe6>
    1d2a:	80 93 64 07 	sts	0x0764, r24	; 0x800764 <uxTopReadyPriority>
    1d2e:	90 e0       	ldi	r25, 0x00	; 0
    1d30:	9c 01       	movw	r18, r24
    1d32:	22 0f       	add	r18, r18
    1d34:	33 1f       	adc	r19, r19
    1d36:	22 0f       	add	r18, r18
    1d38:	33 1f       	adc	r19, r19
    1d3a:	22 0f       	add	r18, r18
    1d3c:	33 1f       	adc	r19, r19
    1d3e:	82 0f       	add	r24, r18
    1d40:	93 1f       	adc	r25, r19
    1d42:	b8 01       	movw	r22, r16
    1d44:	86 56       	subi	r24, 0x66	; 102
    1d46:	98 4f       	sbci	r25, 0xF8	; 248
    1d48:	0e 94 05 08 	call	0x100a	; 0x100a <vListInsertEnd>
    1d4c:	e0 91 be 07 	lds	r30, 0x07BE	; 0x8007be <pxCurrentTCB>
    1d50:	f0 91 bf 07 	lds	r31, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    1d54:	9e 89       	ldd	r25, Y+22	; 0x16
    1d56:	86 89       	ldd	r24, Z+22	; 0x16
    1d58:	98 17       	cp	r25, r24
    1d5a:	08 f4       	brcc	.+2      	; 0x1d5e <xTaskIncrementTick+0x116>
    1d5c:	b2 cf       	rjmp	.-156    	; 0x1cc2 <xTaskIncrementTick+0x7a>
    1d5e:	dc 2c       	mov	r13, r12
    1d60:	b0 cf       	rjmp	.-160    	; 0x1cc2 <xTaskIncrementTick+0x7a>
    1d62:	e0 91 be 07 	lds	r30, 0x07BE	; 0x8007be <pxCurrentTCB>
    1d66:	f0 91 bf 07 	lds	r31, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    1d6a:	86 89       	ldd	r24, Z+22	; 0x16
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	fc 01       	movw	r30, r24
    1d70:	ee 0f       	add	r30, r30
    1d72:	ff 1f       	adc	r31, r31
    1d74:	ee 0f       	add	r30, r30
    1d76:	ff 1f       	adc	r31, r31
    1d78:	ee 0f       	add	r30, r30
    1d7a:	ff 1f       	adc	r31, r31
    1d7c:	8e 0f       	add	r24, r30
    1d7e:	9f 1f       	adc	r25, r31
    1d80:	fc 01       	movw	r30, r24
    1d82:	e6 56       	subi	r30, 0x66	; 102
    1d84:	f8 4f       	sbci	r31, 0xF8	; 248
    1d86:	80 81       	ld	r24, Z
    1d88:	82 30       	cpi	r24, 0x02	; 2
    1d8a:	48 f0       	brcs	.+18     	; 0x1d9e <xTaskIncrementTick+0x156>
    1d8c:	dd 24       	eor	r13, r13
    1d8e:	d3 94       	inc	r13
    1d90:	06 c0       	rjmp	.+12     	; 0x1d9e <xTaskIncrementTick+0x156>
    1d92:	80 91 62 07 	lds	r24, 0x0762	; 0x800762 <uxPendedTicks>
    1d96:	8f 5f       	subi	r24, 0xFF	; 255
    1d98:	80 93 62 07 	sts	0x0762, r24	; 0x800762 <uxPendedTicks>
    1d9c:	d1 2c       	mov	r13, r1
    1d9e:	80 91 61 07 	lds	r24, 0x0761	; 0x800761 <xYieldPending>
    1da2:	88 23       	and	r24, r24
    1da4:	11 f0       	breq	.+4      	; 0x1daa <xTaskIncrementTick+0x162>
    1da6:	dd 24       	eor	r13, r13
    1da8:	d3 94       	inc	r13
    1daa:	8d 2d       	mov	r24, r13
    1dac:	df 91       	pop	r29
    1dae:	cf 91       	pop	r28
    1db0:	1f 91       	pop	r17
    1db2:	0f 91       	pop	r16
    1db4:	ff 90       	pop	r15
    1db6:	ef 90       	pop	r14
    1db8:	df 90       	pop	r13
    1dba:	cf 90       	pop	r12
    1dbc:	08 95       	ret

00001dbe <xTaskResumeAll>:
    1dbe:	df 92       	push	r13
    1dc0:	ef 92       	push	r14
    1dc2:	ff 92       	push	r15
    1dc4:	0f 93       	push	r16
    1dc6:	1f 93       	push	r17
    1dc8:	cf 93       	push	r28
    1dca:	df 93       	push	r29
    1dcc:	0f b6       	in	r0, 0x3f	; 63
    1dce:	f8 94       	cli
    1dd0:	0f 92       	push	r0
    1dd2:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <uxSchedulerSuspended>
    1dd6:	81 50       	subi	r24, 0x01	; 1
    1dd8:	80 93 5a 07 	sts	0x075A, r24	; 0x80075a <uxSchedulerSuspended>
    1ddc:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <uxSchedulerSuspended>
    1de0:	81 11       	cpse	r24, r1
    1de2:	5f c0       	rjmp	.+190    	; 0x1ea2 <xTaskResumeAll+0xe4>
    1de4:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <uxCurrentNumberOfTasks>
    1de8:	81 11       	cpse	r24, r1
    1dea:	33 c0       	rjmp	.+102    	; 0x1e52 <xTaskResumeAll+0x94>
    1dec:	5d c0       	rjmp	.+186    	; 0x1ea8 <xTaskResumeAll+0xea>
    1dee:	d7 01       	movw	r26, r14
    1df0:	15 96       	adiw	r26, 0x05	; 5
    1df2:	ed 91       	ld	r30, X+
    1df4:	fc 91       	ld	r31, X
    1df6:	16 97       	sbiw	r26, 0x06	; 6
    1df8:	c6 81       	ldd	r28, Z+6	; 0x06
    1dfa:	d7 81       	ldd	r29, Z+7	; 0x07
    1dfc:	ce 01       	movw	r24, r28
    1dfe:	0c 96       	adiw	r24, 0x0c	; 12
    1e00:	0e 94 57 08 	call	0x10ae	; 0x10ae <uxListRemove>
    1e04:	8e 01       	movw	r16, r28
    1e06:	0e 5f       	subi	r16, 0xFE	; 254
    1e08:	1f 4f       	sbci	r17, 0xFF	; 255
    1e0a:	c8 01       	movw	r24, r16
    1e0c:	0e 94 57 08 	call	0x10ae	; 0x10ae <uxListRemove>
    1e10:	8e 89       	ldd	r24, Y+22	; 0x16
    1e12:	90 91 64 07 	lds	r25, 0x0764	; 0x800764 <uxTopReadyPriority>
    1e16:	98 17       	cp	r25, r24
    1e18:	10 f4       	brcc	.+4      	; 0x1e1e <xTaskResumeAll+0x60>
    1e1a:	80 93 64 07 	sts	0x0764, r24	; 0x800764 <uxTopReadyPriority>
    1e1e:	90 e0       	ldi	r25, 0x00	; 0
    1e20:	9c 01       	movw	r18, r24
    1e22:	22 0f       	add	r18, r18
    1e24:	33 1f       	adc	r19, r19
    1e26:	22 0f       	add	r18, r18
    1e28:	33 1f       	adc	r19, r19
    1e2a:	22 0f       	add	r18, r18
    1e2c:	33 1f       	adc	r19, r19
    1e2e:	82 0f       	add	r24, r18
    1e30:	93 1f       	adc	r25, r19
    1e32:	b8 01       	movw	r22, r16
    1e34:	86 56       	subi	r24, 0x66	; 102
    1e36:	98 4f       	sbci	r25, 0xF8	; 248
    1e38:	0e 94 05 08 	call	0x100a	; 0x100a <vListInsertEnd>
    1e3c:	e0 91 be 07 	lds	r30, 0x07BE	; 0x8007be <pxCurrentTCB>
    1e40:	f0 91 bf 07 	lds	r31, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    1e44:	9e 89       	ldd	r25, Y+22	; 0x16
    1e46:	86 89       	ldd	r24, Z+22	; 0x16
    1e48:	98 17       	cp	r25, r24
    1e4a:	68 f0       	brcs	.+26     	; 0x1e66 <xTaskResumeAll+0xa8>
    1e4c:	d0 92 61 07 	sts	0x0761, r13	; 0x800761 <xYieldPending>
    1e50:	0a c0       	rjmp	.+20     	; 0x1e66 <xTaskResumeAll+0xa8>
    1e52:	c0 e0       	ldi	r28, 0x00	; 0
    1e54:	d0 e0       	ldi	r29, 0x00	; 0
    1e56:	0f 2e       	mov	r0, r31
    1e58:	fb e7       	ldi	r31, 0x7B	; 123
    1e5a:	ef 2e       	mov	r14, r31
    1e5c:	f7 e0       	ldi	r31, 0x07	; 7
    1e5e:	ff 2e       	mov	r15, r31
    1e60:	f0 2d       	mov	r31, r0
    1e62:	dd 24       	eor	r13, r13
    1e64:	d3 94       	inc	r13
    1e66:	f7 01       	movw	r30, r14
    1e68:	80 81       	ld	r24, Z
    1e6a:	81 11       	cpse	r24, r1
    1e6c:	c0 cf       	rjmp	.-128    	; 0x1dee <xTaskResumeAll+0x30>
    1e6e:	cd 2b       	or	r28, r29
    1e70:	11 f0       	breq	.+4      	; 0x1e76 <xTaskResumeAll+0xb8>
    1e72:	0e 94 3f 0c 	call	0x187e	; 0x187e <prvResetNextTaskUnblockTime>
    1e76:	c0 91 62 07 	lds	r28, 0x0762	; 0x800762 <uxPendedTicks>
    1e7a:	cc 23       	and	r28, r28
    1e7c:	51 f0       	breq	.+20     	; 0x1e92 <xTaskResumeAll+0xd4>
    1e7e:	d1 e0       	ldi	r29, 0x01	; 1
    1e80:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <xTaskIncrementTick>
    1e84:	81 11       	cpse	r24, r1
    1e86:	d0 93 61 07 	sts	0x0761, r29	; 0x800761 <xYieldPending>
    1e8a:	c1 50       	subi	r28, 0x01	; 1
    1e8c:	c9 f7       	brne	.-14     	; 0x1e80 <xTaskResumeAll+0xc2>
    1e8e:	10 92 62 07 	sts	0x0762, r1	; 0x800762 <uxPendedTicks>
    1e92:	80 91 61 07 	lds	r24, 0x0761	; 0x800761 <xYieldPending>
    1e96:	88 23       	and	r24, r24
    1e98:	31 f0       	breq	.+12     	; 0x1ea6 <xTaskResumeAll+0xe8>
    1e9a:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortYield>
    1e9e:	81 e0       	ldi	r24, 0x01	; 1
    1ea0:	03 c0       	rjmp	.+6      	; 0x1ea8 <xTaskResumeAll+0xea>
    1ea2:	80 e0       	ldi	r24, 0x00	; 0
    1ea4:	01 c0       	rjmp	.+2      	; 0x1ea8 <xTaskResumeAll+0xea>
    1ea6:	80 e0       	ldi	r24, 0x00	; 0
    1ea8:	0f 90       	pop	r0
    1eaa:	0f be       	out	0x3f, r0	; 63
    1eac:	df 91       	pop	r29
    1eae:	cf 91       	pop	r28
    1eb0:	1f 91       	pop	r17
    1eb2:	0f 91       	pop	r16
    1eb4:	ff 90       	pop	r15
    1eb6:	ef 90       	pop	r14
    1eb8:	df 90       	pop	r13
    1eba:	08 95       	ret

00001ebc <vTaskDelay>:
    1ebc:	cf 93       	push	r28
    1ebe:	df 93       	push	r29
    1ec0:	ec 01       	movw	r28, r24
    1ec2:	89 2b       	or	r24, r25
    1ec4:	51 f0       	breq	.+20     	; 0x1eda <vTaskDelay+0x1e>
    1ec6:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vTaskSuspendAll>
    1eca:	60 e0       	ldi	r22, 0x00	; 0
    1ecc:	ce 01       	movw	r24, r28
    1ece:	0e 94 8a 0c 	call	0x1914	; 0x1914 <prvAddCurrentTaskToDelayedList>
    1ed2:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xTaskResumeAll>
    1ed6:	81 11       	cpse	r24, r1
    1ed8:	02 c0       	rjmp	.+4      	; 0x1ede <vTaskDelay+0x22>
    1eda:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortYield>
    1ede:	df 91       	pop	r29
    1ee0:	cf 91       	pop	r28
    1ee2:	08 95       	ret

00001ee4 <vTaskSwitchContext>:
    1ee4:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <uxSchedulerSuspended>
    1ee8:	88 23       	and	r24, r24
    1eea:	21 f0       	breq	.+8      	; 0x1ef4 <vTaskSwitchContext+0x10>
    1eec:	81 e0       	ldi	r24, 0x01	; 1
    1eee:	80 93 61 07 	sts	0x0761, r24	; 0x800761 <xYieldPending>
    1ef2:	08 95       	ret
    1ef4:	10 92 61 07 	sts	0x0761, r1	; 0x800761 <xYieldPending>
    1ef8:	20 91 64 07 	lds	r18, 0x0764	; 0x800764 <uxTopReadyPriority>
    1efc:	82 2f       	mov	r24, r18
    1efe:	90 e0       	ldi	r25, 0x00	; 0
    1f00:	fc 01       	movw	r30, r24
    1f02:	ee 0f       	add	r30, r30
    1f04:	ff 1f       	adc	r31, r31
    1f06:	ee 0f       	add	r30, r30
    1f08:	ff 1f       	adc	r31, r31
    1f0a:	ee 0f       	add	r30, r30
    1f0c:	ff 1f       	adc	r31, r31
    1f0e:	e8 0f       	add	r30, r24
    1f10:	f9 1f       	adc	r31, r25
    1f12:	e6 56       	subi	r30, 0x66	; 102
    1f14:	f8 4f       	sbci	r31, 0xF8	; 248
    1f16:	30 81       	ld	r19, Z
    1f18:	31 11       	cpse	r19, r1
    1f1a:	11 c0       	rjmp	.+34     	; 0x1f3e <vTaskSwitchContext+0x5a>
    1f1c:	21 50       	subi	r18, 0x01	; 1
    1f1e:	82 2f       	mov	r24, r18
    1f20:	90 e0       	ldi	r25, 0x00	; 0
    1f22:	fc 01       	movw	r30, r24
    1f24:	ee 0f       	add	r30, r30
    1f26:	ff 1f       	adc	r31, r31
    1f28:	ee 0f       	add	r30, r30
    1f2a:	ff 1f       	adc	r31, r31
    1f2c:	ee 0f       	add	r30, r30
    1f2e:	ff 1f       	adc	r31, r31
    1f30:	e8 0f       	add	r30, r24
    1f32:	f9 1f       	adc	r31, r25
    1f34:	e6 56       	subi	r30, 0x66	; 102
    1f36:	f8 4f       	sbci	r31, 0xF8	; 248
    1f38:	30 81       	ld	r19, Z
    1f3a:	33 23       	and	r19, r19
    1f3c:	79 f3       	breq	.-34     	; 0x1f1c <vTaskSwitchContext+0x38>
    1f3e:	ac 01       	movw	r20, r24
    1f40:	44 0f       	add	r20, r20
    1f42:	55 1f       	adc	r21, r21
    1f44:	44 0f       	add	r20, r20
    1f46:	55 1f       	adc	r21, r21
    1f48:	44 0f       	add	r20, r20
    1f4a:	55 1f       	adc	r21, r21
    1f4c:	48 0f       	add	r20, r24
    1f4e:	59 1f       	adc	r21, r25
    1f50:	da 01       	movw	r26, r20
    1f52:	a6 56       	subi	r26, 0x66	; 102
    1f54:	b8 4f       	sbci	r27, 0xF8	; 248
    1f56:	11 96       	adiw	r26, 0x01	; 1
    1f58:	ed 91       	ld	r30, X+
    1f5a:	fc 91       	ld	r31, X
    1f5c:	12 97       	sbiw	r26, 0x02	; 2
    1f5e:	02 80       	ldd	r0, Z+2	; 0x02
    1f60:	f3 81       	ldd	r31, Z+3	; 0x03
    1f62:	e0 2d       	mov	r30, r0
    1f64:	12 96       	adiw	r26, 0x02	; 2
    1f66:	fc 93       	st	X, r31
    1f68:	ee 93       	st	-X, r30
    1f6a:	11 97       	sbiw	r26, 0x01	; 1
    1f6c:	43 56       	subi	r20, 0x63	; 99
    1f6e:	58 4f       	sbci	r21, 0xF8	; 248
    1f70:	e4 17       	cp	r30, r20
    1f72:	f5 07       	cpc	r31, r21
    1f74:	29 f4       	brne	.+10     	; 0x1f80 <vTaskSwitchContext+0x9c>
    1f76:	42 81       	ldd	r20, Z+2	; 0x02
    1f78:	53 81       	ldd	r21, Z+3	; 0x03
    1f7a:	fd 01       	movw	r30, r26
    1f7c:	52 83       	std	Z+2, r21	; 0x02
    1f7e:	41 83       	std	Z+1, r20	; 0x01
    1f80:	fc 01       	movw	r30, r24
    1f82:	ee 0f       	add	r30, r30
    1f84:	ff 1f       	adc	r31, r31
    1f86:	ee 0f       	add	r30, r30
    1f88:	ff 1f       	adc	r31, r31
    1f8a:	ee 0f       	add	r30, r30
    1f8c:	ff 1f       	adc	r31, r31
    1f8e:	8e 0f       	add	r24, r30
    1f90:	9f 1f       	adc	r25, r31
    1f92:	fc 01       	movw	r30, r24
    1f94:	e6 56       	subi	r30, 0x66	; 102
    1f96:	f8 4f       	sbci	r31, 0xF8	; 248
    1f98:	01 80       	ldd	r0, Z+1	; 0x01
    1f9a:	f2 81       	ldd	r31, Z+2	; 0x02
    1f9c:	e0 2d       	mov	r30, r0
    1f9e:	86 81       	ldd	r24, Z+6	; 0x06
    1fa0:	97 81       	ldd	r25, Z+7	; 0x07
    1fa2:	90 93 bf 07 	sts	0x07BF, r25	; 0x8007bf <pxCurrentTCB+0x1>
    1fa6:	80 93 be 07 	sts	0x07BE, r24	; 0x8007be <pxCurrentTCB>
    1faa:	20 93 64 07 	sts	0x0764, r18	; 0x800764 <uxTopReadyPriority>
    1fae:	08 95       	ret

00001fb0 <vTaskSuspend>:
    1fb0:	0f 93       	push	r16
    1fb2:	1f 93       	push	r17
    1fb4:	cf 93       	push	r28
    1fb6:	df 93       	push	r29
    1fb8:	ec 01       	movw	r28, r24
    1fba:	0f b6       	in	r0, 0x3f	; 63
    1fbc:	f8 94       	cli
    1fbe:	0f 92       	push	r0
    1fc0:	89 2b       	or	r24, r25
    1fc2:	21 f4       	brne	.+8      	; 0x1fcc <vTaskSuspend+0x1c>
    1fc4:	c0 91 be 07 	lds	r28, 0x07BE	; 0x8007be <pxCurrentTCB>
    1fc8:	d0 91 bf 07 	lds	r29, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    1fcc:	8e 01       	movw	r16, r28
    1fce:	0e 5f       	subi	r16, 0xFE	; 254
    1fd0:	1f 4f       	sbci	r17, 0xFF	; 255
    1fd2:	c8 01       	movw	r24, r16
    1fd4:	0e 94 57 08 	call	0x10ae	; 0x10ae <uxListRemove>
    1fd8:	8c 89       	ldd	r24, Y+20	; 0x14
    1fda:	9d 89       	ldd	r25, Y+21	; 0x15
    1fdc:	89 2b       	or	r24, r25
    1fde:	21 f0       	breq	.+8      	; 0x1fe8 <vTaskSuspend+0x38>
    1fe0:	ce 01       	movw	r24, r28
    1fe2:	0c 96       	adiw	r24, 0x0c	; 12
    1fe4:	0e 94 57 08 	call	0x10ae	; 0x10ae <uxListRemove>
    1fe8:	b8 01       	movw	r22, r16
    1fea:	88 e6       	ldi	r24, 0x68	; 104
    1fec:	97 e0       	ldi	r25, 0x07	; 7
    1fee:	0e 94 05 08 	call	0x100a	; 0x100a <vListInsertEnd>
    1ff2:	8d a1       	ldd	r24, Y+37	; 0x25
    1ff4:	81 30       	cpi	r24, 0x01	; 1
    1ff6:	09 f4       	brne	.+2      	; 0x1ffa <vTaskSuspend+0x4a>
    1ff8:	1d a2       	std	Y+37, r1	; 0x25
    1ffa:	0f 90       	pop	r0
    1ffc:	0f be       	out	0x3f, r0	; 63
    1ffe:	80 91 63 07 	lds	r24, 0x0763	; 0x800763 <xSchedulerRunning>
    2002:	88 23       	and	r24, r24
    2004:	39 f0       	breq	.+14     	; 0x2014 <vTaskSuspend+0x64>
    2006:	0f b6       	in	r0, 0x3f	; 63
    2008:	f8 94       	cli
    200a:	0f 92       	push	r0
    200c:	0e 94 3f 0c 	call	0x187e	; 0x187e <prvResetNextTaskUnblockTime>
    2010:	0f 90       	pop	r0
    2012:	0f be       	out	0x3f, r0	; 63
    2014:	80 91 be 07 	lds	r24, 0x07BE	; 0x8007be <pxCurrentTCB>
    2018:	90 91 bf 07 	lds	r25, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    201c:	c8 17       	cp	r28, r24
    201e:	d9 07       	cpc	r29, r25
    2020:	a1 f4       	brne	.+40     	; 0x204a <vTaskSuspend+0x9a>
    2022:	80 91 63 07 	lds	r24, 0x0763	; 0x800763 <xSchedulerRunning>
    2026:	88 23       	and	r24, r24
    2028:	19 f0       	breq	.+6      	; 0x2030 <vTaskSuspend+0x80>
    202a:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortYield>
    202e:	0d c0       	rjmp	.+26     	; 0x204a <vTaskSuspend+0x9a>
    2030:	90 91 68 07 	lds	r25, 0x0768	; 0x800768 <xSuspendedTaskList>
    2034:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <uxCurrentNumberOfTasks>
    2038:	98 13       	cpse	r25, r24
    203a:	05 c0       	rjmp	.+10     	; 0x2046 <vTaskSuspend+0x96>
    203c:	10 92 bf 07 	sts	0x07BF, r1	; 0x8007bf <pxCurrentTCB+0x1>
    2040:	10 92 be 07 	sts	0x07BE, r1	; 0x8007be <pxCurrentTCB>
    2044:	02 c0       	rjmp	.+4      	; 0x204a <vTaskSuspend+0x9a>
    2046:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <vTaskSwitchContext>
    204a:	df 91       	pop	r29
    204c:	cf 91       	pop	r28
    204e:	1f 91       	pop	r17
    2050:	0f 91       	pop	r16
    2052:	08 95       	ret

00002054 <vTaskPlaceOnEventList>:
    2054:	cf 93       	push	r28
    2056:	df 93       	push	r29
    2058:	eb 01       	movw	r28, r22
    205a:	60 91 be 07 	lds	r22, 0x07BE	; 0x8007be <pxCurrentTCB>
    205e:	70 91 bf 07 	lds	r23, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    2062:	64 5f       	subi	r22, 0xF4	; 244
    2064:	7f 4f       	sbci	r23, 0xFF	; 255
    2066:	0e 94 26 08 	call	0x104c	; 0x104c <vListInsert>
    206a:	61 e0       	ldi	r22, 0x01	; 1
    206c:	ce 01       	movw	r24, r28
    206e:	0e 94 8a 0c 	call	0x1914	; 0x1914 <prvAddCurrentTaskToDelayedList>
    2072:	df 91       	pop	r29
    2074:	cf 91       	pop	r28
    2076:	08 95       	ret

00002078 <xTaskRemoveFromEventList>:
    2078:	0f 93       	push	r16
    207a:	1f 93       	push	r17
    207c:	cf 93       	push	r28
    207e:	df 93       	push	r29
    2080:	dc 01       	movw	r26, r24
    2082:	15 96       	adiw	r26, 0x05	; 5
    2084:	ed 91       	ld	r30, X+
    2086:	fc 91       	ld	r31, X
    2088:	16 97       	sbiw	r26, 0x06	; 6
    208a:	c6 81       	ldd	r28, Z+6	; 0x06
    208c:	d7 81       	ldd	r29, Z+7	; 0x07
    208e:	8e 01       	movw	r16, r28
    2090:	04 5f       	subi	r16, 0xF4	; 244
    2092:	1f 4f       	sbci	r17, 0xFF	; 255
    2094:	c8 01       	movw	r24, r16
    2096:	0e 94 57 08 	call	0x10ae	; 0x10ae <uxListRemove>
    209a:	80 91 5a 07 	lds	r24, 0x075A	; 0x80075a <uxSchedulerSuspended>
    209e:	81 11       	cpse	r24, r1
    20a0:	1c c0       	rjmp	.+56     	; 0x20da <xTaskRemoveFromEventList+0x62>
    20a2:	0a 50       	subi	r16, 0x0A	; 10
    20a4:	11 09       	sbc	r17, r1
    20a6:	c8 01       	movw	r24, r16
    20a8:	0e 94 57 08 	call	0x10ae	; 0x10ae <uxListRemove>
    20ac:	8e 89       	ldd	r24, Y+22	; 0x16
    20ae:	90 91 64 07 	lds	r25, 0x0764	; 0x800764 <uxTopReadyPriority>
    20b2:	98 17       	cp	r25, r24
    20b4:	10 f4       	brcc	.+4      	; 0x20ba <xTaskRemoveFromEventList+0x42>
    20b6:	80 93 64 07 	sts	0x0764, r24	; 0x800764 <uxTopReadyPriority>
    20ba:	90 e0       	ldi	r25, 0x00	; 0
    20bc:	9c 01       	movw	r18, r24
    20be:	22 0f       	add	r18, r18
    20c0:	33 1f       	adc	r19, r19
    20c2:	22 0f       	add	r18, r18
    20c4:	33 1f       	adc	r19, r19
    20c6:	22 0f       	add	r18, r18
    20c8:	33 1f       	adc	r19, r19
    20ca:	82 0f       	add	r24, r18
    20cc:	93 1f       	adc	r25, r19
    20ce:	b8 01       	movw	r22, r16
    20d0:	86 56       	subi	r24, 0x66	; 102
    20d2:	98 4f       	sbci	r25, 0xF8	; 248
    20d4:	0e 94 05 08 	call	0x100a	; 0x100a <vListInsertEnd>
    20d8:	05 c0       	rjmp	.+10     	; 0x20e4 <xTaskRemoveFromEventList+0x6c>
    20da:	b8 01       	movw	r22, r16
    20dc:	8b e7       	ldi	r24, 0x7B	; 123
    20de:	97 e0       	ldi	r25, 0x07	; 7
    20e0:	0e 94 05 08 	call	0x100a	; 0x100a <vListInsertEnd>
    20e4:	e0 91 be 07 	lds	r30, 0x07BE	; 0x8007be <pxCurrentTCB>
    20e8:	f0 91 bf 07 	lds	r31, 0x07BF	; 0x8007bf <pxCurrentTCB+0x1>
    20ec:	9e 89       	ldd	r25, Y+22	; 0x16
    20ee:	86 89       	ldd	r24, Z+22	; 0x16
    20f0:	89 17       	cp	r24, r25
    20f2:	20 f4       	brcc	.+8      	; 0x20fc <xTaskRemoveFromEventList+0x84>
    20f4:	81 e0       	ldi	r24, 0x01	; 1
    20f6:	80 93 61 07 	sts	0x0761, r24	; 0x800761 <xYieldPending>
    20fa:	01 c0       	rjmp	.+2      	; 0x20fe <xTaskRemoveFromEventList+0x86>
    20fc:	80 e0       	ldi	r24, 0x00	; 0
    20fe:	df 91       	pop	r29
    2100:	cf 91       	pop	r28
    2102:	1f 91       	pop	r17
    2104:	0f 91       	pop	r16
    2106:	08 95       	ret

00002108 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2108:	20 91 60 07 	lds	r18, 0x0760	; 0x800760 <xNumOfOverflows>
    210c:	fc 01       	movw	r30, r24
    210e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2110:	20 91 65 07 	lds	r18, 0x0765	; 0x800765 <xTickCount>
    2114:	30 91 66 07 	lds	r19, 0x0766	; 0x800766 <xTickCount+0x1>
    2118:	32 83       	std	Z+2, r19	; 0x02
    211a:	21 83       	std	Z+1, r18	; 0x01
    211c:	08 95       	ret

0000211e <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    211e:	cf 93       	push	r28
    2120:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2122:	0f b6       	in	r0, 0x3f	; 63
    2124:	f8 94       	cli
    2126:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2128:	20 91 65 07 	lds	r18, 0x0765	; 0x800765 <xTickCount>
    212c:	30 91 66 07 	lds	r19, 0x0766	; 0x800766 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    2130:	db 01       	movw	r26, r22
    2132:	4d 91       	ld	r20, X+
    2134:	5c 91       	ld	r21, X
    2136:	4f 3f       	cpi	r20, 0xFF	; 255
    2138:	bf ef       	ldi	r27, 0xFF	; 255
    213a:	5b 07       	cpc	r21, r27
    213c:	f1 f0       	breq	.+60     	; 0x217a <xTaskCheckForTimeOut+0x5c>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    213e:	ec 01       	movw	r28, r24
    2140:	e9 81       	ldd	r30, Y+1	; 0x01
    2142:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2144:	a0 91 60 07 	lds	r26, 0x0760	; 0x800760 <xNumOfOverflows>
    2148:	b8 81       	ld	r27, Y
    214a:	ba 17       	cp	r27, r26
    214c:	19 f0       	breq	.+6      	; 0x2154 <xTaskCheckForTimeOut+0x36>
    214e:	2e 17       	cp	r18, r30
    2150:	3f 07       	cpc	r19, r31
    2152:	a8 f4       	brcc	.+42     	; 0x217e <xTaskCheckForTimeOut+0x60>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    2154:	2e 1b       	sub	r18, r30
    2156:	3f 0b       	sbc	r19, r31
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    2158:	24 17       	cp	r18, r20
    215a:	35 07       	cpc	r19, r21
    215c:	48 f4       	brcc	.+18     	; 0x2170 <xTaskCheckForTimeOut+0x52>
    215e:	fb 01       	movw	r30, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    2160:	42 1b       	sub	r20, r18
    2162:	53 0b       	sbc	r21, r19
    2164:	51 83       	std	Z+1, r21	; 0x01
    2166:	40 83       	st	Z, r20
			vTaskInternalSetTimeOutState( pxTimeOut );
    2168:	0e 94 84 10 	call	0x2108	; 0x2108 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    216c:	80 e0       	ldi	r24, 0x00	; 0
    216e:	08 c0       	rjmp	.+16     	; 0x2180 <xTaskCheckForTimeOut+0x62>
		}
		else
		{
			*pxTicksToWait = 0;
    2170:	fb 01       	movw	r30, r22
    2172:	11 82       	std	Z+1, r1	; 0x01
    2174:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    2176:	81 e0       	ldi	r24, 0x01	; 1
    2178:	03 c0       	rjmp	.+6      	; 0x2180 <xTaskCheckForTimeOut+0x62>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    217a:	80 e0       	ldi	r24, 0x00	; 0
    217c:	01 c0       	rjmp	.+2      	; 0x2180 <xTaskCheckForTimeOut+0x62>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    217e:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    2180:	0f 90       	pop	r0
    2182:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2184:	df 91       	pop	r29
    2186:	cf 91       	pop	r28
    2188:	08 95       	ret

0000218a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    218a:	81 e0       	ldi	r24, 0x01	; 1
    218c:	80 93 61 07 	sts	0x0761, r24	; 0x800761 <xYieldPending>
    2190:	08 95       	ret

00002192 <__divmodsi4>:
    2192:	05 2e       	mov	r0, r21
    2194:	97 fb       	bst	r25, 7
    2196:	1e f4       	brtc	.+6      	; 0x219e <__divmodsi4+0xc>
    2198:	00 94       	com	r0
    219a:	0e 94 e0 10 	call	0x21c0	; 0x21c0 <__negsi2>
    219e:	57 fd       	sbrc	r21, 7
    21a0:	07 d0       	rcall	.+14     	; 0x21b0 <__divmodsi4_neg2>
    21a2:	0e 94 4f 12 	call	0x249e	; 0x249e <__udivmodsi4>
    21a6:	07 fc       	sbrc	r0, 7
    21a8:	03 d0       	rcall	.+6      	; 0x21b0 <__divmodsi4_neg2>
    21aa:	4e f4       	brtc	.+18     	; 0x21be <__divmodsi4_exit>
    21ac:	0c 94 e0 10 	jmp	0x21c0	; 0x21c0 <__negsi2>

000021b0 <__divmodsi4_neg2>:
    21b0:	50 95       	com	r21
    21b2:	40 95       	com	r20
    21b4:	30 95       	com	r19
    21b6:	21 95       	neg	r18
    21b8:	3f 4f       	sbci	r19, 0xFF	; 255
    21ba:	4f 4f       	sbci	r20, 0xFF	; 255
    21bc:	5f 4f       	sbci	r21, 0xFF	; 255

000021be <__divmodsi4_exit>:
    21be:	08 95       	ret

000021c0 <__negsi2>:
    21c0:	90 95       	com	r25
    21c2:	80 95       	com	r24
    21c4:	70 95       	com	r23
    21c6:	61 95       	neg	r22
    21c8:	7f 4f       	sbci	r23, 0xFF	; 255
    21ca:	8f 4f       	sbci	r24, 0xFF	; 255
    21cc:	9f 4f       	sbci	r25, 0xFF	; 255
    21ce:	08 95       	ret

000021d0 <__muldi3>:
    21d0:	df 93       	push	r29
    21d2:	cf 93       	push	r28
    21d4:	1f 93       	push	r17
    21d6:	0f 93       	push	r16
    21d8:	9a 9d       	mul	r25, r10
    21da:	f0 2d       	mov	r31, r0
    21dc:	21 9f       	mul	r18, r17
    21de:	f0 0d       	add	r31, r0
    21e0:	8b 9d       	mul	r24, r11
    21e2:	f0 0d       	add	r31, r0
    21e4:	8a 9d       	mul	r24, r10
    21e6:	e0 2d       	mov	r30, r0
    21e8:	f1 0d       	add	r31, r1
    21ea:	03 9f       	mul	r16, r19
    21ec:	f0 0d       	add	r31, r0
    21ee:	02 9f       	mul	r16, r18
    21f0:	e0 0d       	add	r30, r0
    21f2:	f1 1d       	adc	r31, r1
    21f4:	4e 9d       	mul	r20, r14
    21f6:	e0 0d       	add	r30, r0
    21f8:	f1 1d       	adc	r31, r1
    21fa:	5e 9d       	mul	r21, r14
    21fc:	f0 0d       	add	r31, r0
    21fe:	4f 9d       	mul	r20, r15
    2200:	f0 0d       	add	r31, r0
    2202:	7f 93       	push	r23
    2204:	6f 93       	push	r22
    2206:	bf 92       	push	r11
    2208:	af 92       	push	r10
    220a:	5f 93       	push	r21
    220c:	4f 93       	push	r20
    220e:	d5 01       	movw	r26, r10
    2210:	0e 94 71 12 	call	0x24e2	; 0x24e2 <__umulhisi3>
    2214:	8b 01       	movw	r16, r22
    2216:	ac 01       	movw	r20, r24
    2218:	d7 01       	movw	r26, r14
    221a:	0e 94 71 12 	call	0x24e2	; 0x24e2 <__umulhisi3>
    221e:	eb 01       	movw	r28, r22
    2220:	e8 0f       	add	r30, r24
    2222:	f9 1f       	adc	r31, r25
    2224:	d6 01       	movw	r26, r12
    2226:	0e 94 38 11 	call	0x2270	; 0x2270 <__muldi3_6>
    222a:	2f 91       	pop	r18
    222c:	3f 91       	pop	r19
    222e:	d6 01       	movw	r26, r12
    2230:	0e 94 71 12 	call	0x24e2	; 0x24e2 <__umulhisi3>
    2234:	c6 0f       	add	r28, r22
    2236:	d7 1f       	adc	r29, r23
    2238:	e8 1f       	adc	r30, r24
    223a:	f9 1f       	adc	r31, r25
    223c:	af 91       	pop	r26
    223e:	bf 91       	pop	r27
    2240:	0e 94 38 11 	call	0x2270	; 0x2270 <__muldi3_6>
    2244:	2f 91       	pop	r18
    2246:	3f 91       	pop	r19
    2248:	0e 94 71 12 	call	0x24e2	; 0x24e2 <__umulhisi3>
    224c:	c6 0f       	add	r28, r22
    224e:	d7 1f       	adc	r29, r23
    2250:	e8 1f       	adc	r30, r24
    2252:	f9 1f       	adc	r31, r25
    2254:	d6 01       	movw	r26, r12
    2256:	0e 94 71 12 	call	0x24e2	; 0x24e2 <__umulhisi3>
    225a:	e6 0f       	add	r30, r22
    225c:	f7 1f       	adc	r31, r23
    225e:	98 01       	movw	r18, r16
    2260:	be 01       	movw	r22, r28
    2262:	cf 01       	movw	r24, r30
    2264:	11 24       	eor	r1, r1
    2266:	0f 91       	pop	r16
    2268:	1f 91       	pop	r17
    226a:	cf 91       	pop	r28
    226c:	df 91       	pop	r29
    226e:	08 95       	ret

00002270 <__muldi3_6>:
    2270:	0e 94 71 12 	call	0x24e2	; 0x24e2 <__umulhisi3>
    2274:	46 0f       	add	r20, r22
    2276:	57 1f       	adc	r21, r23
    2278:	c8 1f       	adc	r28, r24
    227a:	d9 1f       	adc	r29, r25
    227c:	08 f4       	brcc	.+2      	; 0x2280 <__muldi3_6+0x10>
    227e:	31 96       	adiw	r30, 0x01	; 1
    2280:	08 95       	ret

00002282 <__moddi3>:
    2282:	68 94       	set
    2284:	01 c0       	rjmp	.+2      	; 0x2288 <__divdi3_moddi3>

00002286 <__divdi3>:
    2286:	e8 94       	clt

00002288 <__divdi3_moddi3>:
    2288:	f9 2f       	mov	r31, r25
    228a:	f1 2b       	or	r31, r17
    228c:	12 f0       	brmi	.+4      	; 0x2292 <__divdi3_moddi3+0xa>
    228e:	0c 94 75 11 	jmp	0x22ea	; 0x22ea <__udivdi3_umoddi3>
    2292:	a0 e0       	ldi	r26, 0x00	; 0
    2294:	b0 e0       	ldi	r27, 0x00	; 0
    2296:	ef e4       	ldi	r30, 0x4F	; 79
    2298:	f1 e1       	ldi	r31, 0x11	; 17
    229a:	0c 94 e7 11 	jmp	0x23ce	; 0x23ce <__prologue_saves__+0xc>
    229e:	09 2e       	mov	r0, r25
    22a0:	05 94       	asr	r0
    22a2:	22 f4       	brpl	.+8      	; 0x22ac <__divdi3_moddi3+0x24>
    22a4:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <__negdi2>
    22a8:	11 23       	and	r17, r17
    22aa:	92 f4       	brpl	.+36     	; 0x22d0 <__divdi3_moddi3+0x48>
    22ac:	f0 e8       	ldi	r31, 0x80	; 128
    22ae:	0f 26       	eor	r0, r31
    22b0:	ff ef       	ldi	r31, 0xFF	; 255
    22b2:	e0 94       	com	r14
    22b4:	f0 94       	com	r15
    22b6:	00 95       	com	r16
    22b8:	10 95       	com	r17
    22ba:	b0 94       	com	r11
    22bc:	c0 94       	com	r12
    22be:	d0 94       	com	r13
    22c0:	a1 94       	neg	r10
    22c2:	bf 0a       	sbc	r11, r31
    22c4:	cf 0a       	sbc	r12, r31
    22c6:	df 0a       	sbc	r13, r31
    22c8:	ef 0a       	sbc	r14, r31
    22ca:	ff 0a       	sbc	r15, r31
    22cc:	0f 0b       	sbc	r16, r31
    22ce:	1f 0b       	sbc	r17, r31
    22d0:	0e 94 80 11 	call	0x2300	; 0x2300 <__udivmod64>
    22d4:	07 fc       	sbrc	r0, 7
    22d6:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <__negdi2>
    22da:	cd b7       	in	r28, 0x3d	; 61
    22dc:	de b7       	in	r29, 0x3e	; 62
    22de:	ec e0       	ldi	r30, 0x0C	; 12
    22e0:	0c 94 03 12 	jmp	0x2406	; 0x2406 <__epilogue_restores__+0xc>

000022e4 <__umoddi3>:
    22e4:	68 94       	set
    22e6:	01 c0       	rjmp	.+2      	; 0x22ea <__udivdi3_umoddi3>

000022e8 <__udivdi3>:
    22e8:	e8 94       	clt

000022ea <__udivdi3_umoddi3>:
    22ea:	8f 92       	push	r8
    22ec:	9f 92       	push	r9
    22ee:	cf 93       	push	r28
    22f0:	df 93       	push	r29
    22f2:	0e 94 80 11 	call	0x2300	; 0x2300 <__udivmod64>
    22f6:	df 91       	pop	r29
    22f8:	cf 91       	pop	r28
    22fa:	9f 90       	pop	r9
    22fc:	8f 90       	pop	r8
    22fe:	08 95       	ret

00002300 <__udivmod64>:
    2300:	88 24       	eor	r8, r8
    2302:	99 24       	eor	r9, r9
    2304:	f4 01       	movw	r30, r8
    2306:	e4 01       	movw	r28, r8
    2308:	b0 e4       	ldi	r27, 0x40	; 64
    230a:	9f 93       	push	r25
    230c:	aa 27       	eor	r26, r26
    230e:	9a 15       	cp	r25, r10
    2310:	8b 04       	cpc	r8, r11
    2312:	9c 04       	cpc	r9, r12
    2314:	ed 05       	cpc	r30, r13
    2316:	fe 05       	cpc	r31, r14
    2318:	cf 05       	cpc	r28, r15
    231a:	d0 07       	cpc	r29, r16
    231c:	a1 07       	cpc	r26, r17
    231e:	98 f4       	brcc	.+38     	; 0x2346 <__udivmod64+0x46>
    2320:	ad 2f       	mov	r26, r29
    2322:	dc 2f       	mov	r29, r28
    2324:	cf 2f       	mov	r28, r31
    2326:	fe 2f       	mov	r31, r30
    2328:	e9 2d       	mov	r30, r9
    232a:	98 2c       	mov	r9, r8
    232c:	89 2e       	mov	r8, r25
    232e:	98 2f       	mov	r25, r24
    2330:	87 2f       	mov	r24, r23
    2332:	76 2f       	mov	r23, r22
    2334:	65 2f       	mov	r22, r21
    2336:	54 2f       	mov	r21, r20
    2338:	43 2f       	mov	r20, r19
    233a:	32 2f       	mov	r19, r18
    233c:	22 27       	eor	r18, r18
    233e:	b8 50       	subi	r27, 0x08	; 8
    2340:	31 f7       	brne	.-52     	; 0x230e <__udivmod64+0xe>
    2342:	bf 91       	pop	r27
    2344:	27 c0       	rjmp	.+78     	; 0x2394 <__udivmod64+0x94>
    2346:	1b 2e       	mov	r1, r27
    2348:	bf 91       	pop	r27
    234a:	bb 27       	eor	r27, r27
    234c:	22 0f       	add	r18, r18
    234e:	33 1f       	adc	r19, r19
    2350:	44 1f       	adc	r20, r20
    2352:	55 1f       	adc	r21, r21
    2354:	66 1f       	adc	r22, r22
    2356:	77 1f       	adc	r23, r23
    2358:	88 1f       	adc	r24, r24
    235a:	99 1f       	adc	r25, r25
    235c:	88 1c       	adc	r8, r8
    235e:	99 1c       	adc	r9, r9
    2360:	ee 1f       	adc	r30, r30
    2362:	ff 1f       	adc	r31, r31
    2364:	cc 1f       	adc	r28, r28
    2366:	dd 1f       	adc	r29, r29
    2368:	aa 1f       	adc	r26, r26
    236a:	bb 1f       	adc	r27, r27
    236c:	8a 14       	cp	r8, r10
    236e:	9b 04       	cpc	r9, r11
    2370:	ec 05       	cpc	r30, r12
    2372:	fd 05       	cpc	r31, r13
    2374:	ce 05       	cpc	r28, r14
    2376:	df 05       	cpc	r29, r15
    2378:	a0 07       	cpc	r26, r16
    237a:	b1 07       	cpc	r27, r17
    237c:	48 f0       	brcs	.+18     	; 0x2390 <__udivmod64+0x90>
    237e:	8a 18       	sub	r8, r10
    2380:	9b 08       	sbc	r9, r11
    2382:	ec 09       	sbc	r30, r12
    2384:	fd 09       	sbc	r31, r13
    2386:	ce 09       	sbc	r28, r14
    2388:	df 09       	sbc	r29, r15
    238a:	a0 0b       	sbc	r26, r16
    238c:	b1 0b       	sbc	r27, r17
    238e:	21 60       	ori	r18, 0x01	; 1
    2390:	1a 94       	dec	r1
    2392:	e1 f6       	brne	.-72     	; 0x234c <__udivmod64+0x4c>
    2394:	2e f4       	brtc	.+10     	; 0x23a0 <__udivmod64+0xa0>
    2396:	94 01       	movw	r18, r8
    2398:	af 01       	movw	r20, r30
    239a:	be 01       	movw	r22, r28
    239c:	cd 01       	movw	r24, r26
    239e:	00 0c       	add	r0, r0
    23a0:	08 95       	ret

000023a2 <__negdi2>:
    23a2:	60 95       	com	r22
    23a4:	70 95       	com	r23
    23a6:	80 95       	com	r24
    23a8:	90 95       	com	r25
    23aa:	30 95       	com	r19
    23ac:	40 95       	com	r20
    23ae:	50 95       	com	r21
    23b0:	21 95       	neg	r18
    23b2:	3f 4f       	sbci	r19, 0xFF	; 255
    23b4:	4f 4f       	sbci	r20, 0xFF	; 255
    23b6:	5f 4f       	sbci	r21, 0xFF	; 255
    23b8:	6f 4f       	sbci	r22, 0xFF	; 255
    23ba:	7f 4f       	sbci	r23, 0xFF	; 255
    23bc:	8f 4f       	sbci	r24, 0xFF	; 255
    23be:	9f 4f       	sbci	r25, 0xFF	; 255
    23c0:	08 95       	ret

000023c2 <__prologue_saves__>:
    23c2:	2f 92       	push	r2
    23c4:	3f 92       	push	r3
    23c6:	4f 92       	push	r4
    23c8:	5f 92       	push	r5
    23ca:	6f 92       	push	r6
    23cc:	7f 92       	push	r7
    23ce:	8f 92       	push	r8
    23d0:	9f 92       	push	r9
    23d2:	af 92       	push	r10
    23d4:	bf 92       	push	r11
    23d6:	cf 92       	push	r12
    23d8:	df 92       	push	r13
    23da:	ef 92       	push	r14
    23dc:	ff 92       	push	r15
    23de:	0f 93       	push	r16
    23e0:	1f 93       	push	r17
    23e2:	cf 93       	push	r28
    23e4:	df 93       	push	r29
    23e6:	cd b7       	in	r28, 0x3d	; 61
    23e8:	de b7       	in	r29, 0x3e	; 62
    23ea:	ca 1b       	sub	r28, r26
    23ec:	db 0b       	sbc	r29, r27
    23ee:	0f b6       	in	r0, 0x3f	; 63
    23f0:	f8 94       	cli
    23f2:	de bf       	out	0x3e, r29	; 62
    23f4:	0f be       	out	0x3f, r0	; 63
    23f6:	cd bf       	out	0x3d, r28	; 61
    23f8:	09 94       	ijmp

000023fa <__epilogue_restores__>:
    23fa:	2a 88       	ldd	r2, Y+18	; 0x12
    23fc:	39 88       	ldd	r3, Y+17	; 0x11
    23fe:	48 88       	ldd	r4, Y+16	; 0x10
    2400:	5f 84       	ldd	r5, Y+15	; 0x0f
    2402:	6e 84       	ldd	r6, Y+14	; 0x0e
    2404:	7d 84       	ldd	r7, Y+13	; 0x0d
    2406:	8c 84       	ldd	r8, Y+12	; 0x0c
    2408:	9b 84       	ldd	r9, Y+11	; 0x0b
    240a:	aa 84       	ldd	r10, Y+10	; 0x0a
    240c:	b9 84       	ldd	r11, Y+9	; 0x09
    240e:	c8 84       	ldd	r12, Y+8	; 0x08
    2410:	df 80       	ldd	r13, Y+7	; 0x07
    2412:	ee 80       	ldd	r14, Y+6	; 0x06
    2414:	fd 80       	ldd	r15, Y+5	; 0x05
    2416:	0c 81       	ldd	r16, Y+4	; 0x04
    2418:	1b 81       	ldd	r17, Y+3	; 0x03
    241a:	aa 81       	ldd	r26, Y+2	; 0x02
    241c:	b9 81       	ldd	r27, Y+1	; 0x01
    241e:	ce 0f       	add	r28, r30
    2420:	d1 1d       	adc	r29, r1
    2422:	0f b6       	in	r0, 0x3f	; 63
    2424:	f8 94       	cli
    2426:	de bf       	out	0x3e, r29	; 62
    2428:	0f be       	out	0x3f, r0	; 63
    242a:	cd bf       	out	0x3d, r28	; 61
    242c:	ed 01       	movw	r28, r26
    242e:	08 95       	ret

00002430 <__ashldi3>:
    2430:	0f 93       	push	r16
    2432:	08 30       	cpi	r16, 0x08	; 8
    2434:	90 f0       	brcs	.+36     	; 0x245a <__ashldi3+0x2a>
    2436:	98 2f       	mov	r25, r24
    2438:	87 2f       	mov	r24, r23
    243a:	76 2f       	mov	r23, r22
    243c:	65 2f       	mov	r22, r21
    243e:	54 2f       	mov	r21, r20
    2440:	43 2f       	mov	r20, r19
    2442:	32 2f       	mov	r19, r18
    2444:	22 27       	eor	r18, r18
    2446:	08 50       	subi	r16, 0x08	; 8
    2448:	f4 cf       	rjmp	.-24     	; 0x2432 <__ashldi3+0x2>
    244a:	22 0f       	add	r18, r18
    244c:	33 1f       	adc	r19, r19
    244e:	44 1f       	adc	r20, r20
    2450:	55 1f       	adc	r21, r21
    2452:	66 1f       	adc	r22, r22
    2454:	77 1f       	adc	r23, r23
    2456:	88 1f       	adc	r24, r24
    2458:	99 1f       	adc	r25, r25
    245a:	0a 95       	dec	r16
    245c:	b2 f7       	brpl	.-20     	; 0x244a <__ashldi3+0x1a>
    245e:	0f 91       	pop	r16
    2460:	08 95       	ret

00002462 <__adddi3>:
    2462:	2a 0d       	add	r18, r10
    2464:	3b 1d       	adc	r19, r11
    2466:	4c 1d       	adc	r20, r12
    2468:	5d 1d       	adc	r21, r13
    246a:	6e 1d       	adc	r22, r14
    246c:	7f 1d       	adc	r23, r15
    246e:	80 1f       	adc	r24, r16
    2470:	91 1f       	adc	r25, r17
    2472:	08 95       	ret

00002474 <__subdi3>:
    2474:	2a 19       	sub	r18, r10
    2476:	3b 09       	sbc	r19, r11
    2478:	4c 09       	sbc	r20, r12
    247a:	5d 09       	sbc	r21, r13
    247c:	6e 09       	sbc	r22, r14
    247e:	7f 09       	sbc	r23, r15
    2480:	80 0b       	sbc	r24, r16
    2482:	91 0b       	sbc	r25, r17
    2484:	08 95       	ret

00002486 <__cmpdi2_s8>:
    2486:	00 24       	eor	r0, r0
    2488:	a7 fd       	sbrc	r26, 7
    248a:	00 94       	com	r0
    248c:	2a 17       	cp	r18, r26
    248e:	30 05       	cpc	r19, r0
    2490:	40 05       	cpc	r20, r0
    2492:	50 05       	cpc	r21, r0
    2494:	60 05       	cpc	r22, r0
    2496:	70 05       	cpc	r23, r0
    2498:	80 05       	cpc	r24, r0
    249a:	90 05       	cpc	r25, r0
    249c:	08 95       	ret

0000249e <__udivmodsi4>:
    249e:	a1 e2       	ldi	r26, 0x21	; 33
    24a0:	1a 2e       	mov	r1, r26
    24a2:	aa 1b       	sub	r26, r26
    24a4:	bb 1b       	sub	r27, r27
    24a6:	fd 01       	movw	r30, r26
    24a8:	0d c0       	rjmp	.+26     	; 0x24c4 <__udivmodsi4_ep>

000024aa <__udivmodsi4_loop>:
    24aa:	aa 1f       	adc	r26, r26
    24ac:	bb 1f       	adc	r27, r27
    24ae:	ee 1f       	adc	r30, r30
    24b0:	ff 1f       	adc	r31, r31
    24b2:	a2 17       	cp	r26, r18
    24b4:	b3 07       	cpc	r27, r19
    24b6:	e4 07       	cpc	r30, r20
    24b8:	f5 07       	cpc	r31, r21
    24ba:	20 f0       	brcs	.+8      	; 0x24c4 <__udivmodsi4_ep>
    24bc:	a2 1b       	sub	r26, r18
    24be:	b3 0b       	sbc	r27, r19
    24c0:	e4 0b       	sbc	r30, r20
    24c2:	f5 0b       	sbc	r31, r21

000024c4 <__udivmodsi4_ep>:
    24c4:	66 1f       	adc	r22, r22
    24c6:	77 1f       	adc	r23, r23
    24c8:	88 1f       	adc	r24, r24
    24ca:	99 1f       	adc	r25, r25
    24cc:	1a 94       	dec	r1
    24ce:	69 f7       	brne	.-38     	; 0x24aa <__udivmodsi4_loop>
    24d0:	60 95       	com	r22
    24d2:	70 95       	com	r23
    24d4:	80 95       	com	r24
    24d6:	90 95       	com	r25
    24d8:	9b 01       	movw	r18, r22
    24da:	ac 01       	movw	r20, r24
    24dc:	bd 01       	movw	r22, r26
    24de:	cf 01       	movw	r24, r30
    24e0:	08 95       	ret

000024e2 <__umulhisi3>:
    24e2:	a2 9f       	mul	r26, r18
    24e4:	b0 01       	movw	r22, r0
    24e6:	b3 9f       	mul	r27, r19
    24e8:	c0 01       	movw	r24, r0
    24ea:	a3 9f       	mul	r26, r19
    24ec:	70 0d       	add	r23, r0
    24ee:	81 1d       	adc	r24, r1
    24f0:	11 24       	eor	r1, r1
    24f2:	91 1d       	adc	r25, r1
    24f4:	b2 9f       	mul	r27, r18
    24f6:	70 0d       	add	r23, r0
    24f8:	81 1d       	adc	r24, r1
    24fa:	11 24       	eor	r1, r1
    24fc:	91 1d       	adc	r25, r1
    24fe:	08 95       	ret

00002500 <memcpy>:
    2500:	fb 01       	movw	r30, r22
    2502:	dc 01       	movw	r26, r24
    2504:	02 c0       	rjmp	.+4      	; 0x250a <memcpy+0xa>
    2506:	01 90       	ld	r0, Z+
    2508:	0d 92       	st	X+, r0
    250a:	41 50       	subi	r20, 0x01	; 1
    250c:	50 40       	sbci	r21, 0x00	; 0
    250e:	d8 f7       	brcc	.-10     	; 0x2506 <memcpy+0x6>
    2510:	08 95       	ret

00002512 <_exit>:
    2512:	f8 94       	cli

00002514 <__stop_program>:
    2514:	ff cf       	rjmp	.-2      	; 0x2514 <__stop_program>
